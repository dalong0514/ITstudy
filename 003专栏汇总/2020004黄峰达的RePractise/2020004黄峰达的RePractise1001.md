等等

于是回我们便可以创建一个简单的示例来展示这个最简单的 DSL

Func = (function() {

    this.add = function(){

        console.log('1');

        return this;

    };

    this.result = function(){

        console.log('2');

        return this;

    };

    return this;

});

var func = new Func();

func.add().result();

然而这看上去像是表达式生成器。

DSL 表达式生成器

表达式生成器对象提供一组连贯接口，之后将连贯接口调用转换为对底层命令 - 查询 API 的调用。

这样的 API，我们可以在一些关于数据库的 API 中看到:

var query =

  SQL('select name, desc from widgets')

   .WHERE('price < ', $(params.max_price), AND,

          'clearance = ', $(params.clearance))

   .ORDERBY('name asc');

链式调用有一个问题就是收尾，同上的代码里面我们没有收尾，这让人很迷惑。。加上一个 query 和 end 似乎是一个不错的结果。

Pipe and Filter 模式实战

所以，这个模式实际上更适合处理数据，如用 Hadoop 处理数据的时候，我们会用类似于如下的方法来处理我们的数据:

A = FOREACH LOGS_BASE GENERATE ToDate(timestamp, 'dd/MMM/yyyy:HH:mm:ss Z') as date, ip, url,(int)status,(int)bytes,referrer,useragent;

B = GROUP A BY (timestamp);

C = FOREACH B GENERATE FLATTEN(group) as (timestamp), COUNT(A) as count;

D = ORDER C BY timestamp,count desc;

每一次都是在上一次处理完的结果后，再处理的。

参考书目

《Head First 设计模式》

《设计模式》

《敏捷软件开发 原则、模式与实践》

《 面向模式的软件架构：模式系统》

《Java 应用架构设计》

数据与模型篇

无论是 MVC、MVP 或者 MVVP，都离不开这些基本的要素：数据、表现、领域。

数据

信息源于数据，我们在网站上看到的内容都应该是属于信息的范畴。这些信息是应用从数据库中根据业务需求查找、过滤出来的数据。

数据通常以文件的形式存储，毕竟文件是存储信息的基本单位。只是由于业务本身对于 Create、Update、Query、Index 等有不同的组合需求就引发了不同的数据存储软件。

如上章所说，View 层直接从 Model 层取数据，无遗也会暴露数据的模型。作为一个前端开发人员，我们对数据的操作有三种类型：

数据库。由于 Node.js 在最近几年里发展迅猛，越来越多的开发者选择使用 Node.js 作为后台语言。这与传统的 Model 层并无多大不同，要么直接操作数据库，要么间接操作数据库。即使在 NoSQL 数据库中也是如此。

搜索引擎。对于以查询为主的领域来说，搜索引擎是一个更好的选择，而搜索引擎又不好直接向 View 层暴露接口。这和招聘信息一样，都在暴露公司的技术栈。

RESTful。RESTful 相当于是 CRUD 的衍生，只是传输介质变了。

LocalStorage。LocalStorage 算是另外一种方式的 CRUD。

说了这么多都是废话，他们都是可以用类 CRUD 的方式操作。

数据库

数据库里存储着大量的数据，在我们对系统建模的时候，也在决定系统的基础模型。

在传统 SQL 数据库中，我们可能会依赖于 ORM，也可能会自己写 SQL。在那之间，我们需要先定义 Model，如下是 Node.js 的 ORM 框架 Sequelize 的一个示例：

var User = sequelize.define('user', {

  firstName: {

    type: Sequelize.STRING,

    field: 'first_name' // Will result in an attribute that is firstName when user facing but first_name in the database

  },

  lastName: {

    type: Sequelize.STRING

  }

}, {

  freezeTableName: true // Model tableName will be the same as the model name

});

User.sync({force: true}).then(function () {

  // Table created

  return User.create({

    firstName: 'John',

    lastName: 'Hancock'

  });

});

像如 MongoDB 这类的数据库，也是存在数据模型，但说的却是嵌入子文档。在业务量大的情况下，数据库在考验公司的技术能力，想想便觉得 Amazon RDS 挺好的。

建模

领域篇

DDD

DSL

DSL (domain-specific languages) 即领域特定语言，唯一能够确定 DSL 边界的方法是考虑「一门语言的一种特定用法」和「该语言的设计者或使用者的意图。在试图设计一个 DSL 的时候，发现了一些有意思的简单的示例。

DSL 示例

jQuery 最流行的 DSL

jQuery 是一个 Internal DSL 的典型的例子。它是在一门现成语言内实现针对领域问题的描述。

$('.mydiv').addClass('flash').draggable().css('color', 'blue')

这也就是其最出名的链式方法调用。

Cucumber.js

Cucumber, the popular Behaviour-Driven Development tool, brought to your JavaScript stack。它是使用通用语言描述该领域的问题。

Feature: Example feature

  As a user of cucumber.js

  I want to have documentation on cucumber

  So that I can concentrate on building awesome applications

  Scenario: Reading documentation

    Given I am on the Cucumber.js GitHub repository

    When I go to the README file

    Then I should see "Usage" as the page title

CoffeeScript

发明一门全新的语言描述该领域的问题。

math =

  root:   Math.sqrt

  square: square

  cube:   (x) -> x * square x

JavaScript DSL 示例

所以由上面的结论我们可以知道的是，难度等级应该是

内部 DSL <外部 DSL < 语言工作台 (这是怎么翻译的)

接着在网上找到了一个高级一点的内部 DSL 示例，如果我们要做 jQuery 式的链式方法调用也是简单的，但是似乎没有足够的理由去说服其他人。

原文在: http://alexyoung.org/2009/10/22/javascript-dsl/，相当于是一个微测试框架。

var DSLRunner = {

  run: function(methods) {

    this.ingredients = [];

    this.methods     = methods;

    this.executeAndRemove('first');

    for (var key in this.methods) {

      if (key !== 'last' && key.match(/^bake/)) {

        this.executeAndRemove(key);

      }

    }

    this.executeAndRemove('last');

  },

  addIngredient: function(ingredient) {

    this.ingredients.push(ingredient);

  },

  executeAndRemove: function(methodName) {

    var output = this.methods[methodName]();

    delete(this.methods[methodName]);

    return output;

  }

};

DSLRunner.run({

  first: function() {

    console.log("I happen first");

  },

  bakeCake: function() {

    console.log("Commencing cake baking");

  },

  bakeBread: function() {

    console.log("Baking bread");

  },

  last: function() {

    console.log("last");

  }

});

这个想法，看上去就是定义了一些 map，然后执行。

接着，又看到了一个有意思的 DSL，作者是在解决表单验证的问题《JavaScript DSL Because I’m Tired of Writing If.. If…If…》：

 var rules =

    ['Username',

      ['is not empty', 'Username is required.'],

      ['is not longer than', 7, 'Username is too long.']],

    ['Name',

      ['is not empty', 'Name is required.']],

    ['Password',

      ['length is between', 4, 6, 'Password is not acceptable.']]];

有一个 map 对应了上面的方法

 var methods = [

    ['is not empty', isNotEmpty],

    ['is not longer than', isNotLongerThan],

    ['length is between', isBetween]];

原文只给了一部分代码

var methodPair = find(methods, function(method) {

    return car(method) === car(innerRule);

});

var methodToUse = peek(methodPair);

return function(obj) {

    var error = peek(innerRule);                           //error is the last index

    var values = sink(cdr(innerRule));                     //get everything but the error

    return methodToUse(obj, propertyName, error, values);  //construct the validation call

};

