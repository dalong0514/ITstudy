# 0202 理论 2：如何做到「对扩展开放、修改关闭」？扩展和修改各指什么？

王争 2019-12-09



2.0x



讲述：冯永吉 大小：17.33M 时长：18:54

在上一节课中，我们学习了单一职责原则。今天，我们来学习 SOLID 中的第二个原则：开闭原则。我个人觉得，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。

之所以说这条原则难理解，那是因为，「怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？」等等这些问题，都比较难理解。

之所以说这条原则难掌握，那是因为，「如何做到‘对扩展开放、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？」等等这些问题，都比较难掌握。

之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

所以说，今天的内容非常重要，希望你能集中精力，跟上我的思路，将开闭原则理解透彻，这样才能更好地理解后面章节的内容。话不多说，让我们正式开始今天的学习吧！

如何理解「对扩展开放、修改关闭」？

开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该「对扩展开放、对修改关闭」。

这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

为了让你更好地理解这个原则，我举一个例子来进一步解释一下。这是一段 API 接口监控告警的代码。

其中，AlertRule 存储告警规则，可以自由设置。Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel 表示通知的紧急程度，包括 SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。关于 API 接口监控告警这部分，更加详细的业务需求分析和设计，我们会在后面的设计模式模块再拿出来进一步讲解，这里你只要简单知道这些，就够我们今天用了。

public class Alert {

private AlertRule rule;

private Notification notification;

public Alert(AlertRule rule, Notification notification) {

this.rule = rule;

this.notification = notification;

}

public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {

long tps = requestCount / durationOfSeconds;

if (tps > rule.getMatchedRule(api).getMaxTps()) {

notification.notify(NotificationEmergencyLevel.URGENCY, "...");

}

if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {

notification.notify(NotificationEmergencyLevel.SEVERE, "...");

}

}

}

上面这段代码非常简单，业务逻辑主要集中在 check () 函数中。当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。

现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改 check () 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数；第二处是在 check () 函数中添加新的告警逻辑。具体的代码改动如下所示：

public class Alert {

//... 省略 AlertRule/Notification 属性和构造函数...



// 改动一：添加参数 timeoutCount

public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {

long tps = requestCount / durationOfSeconds;

if (tps > rule.getMatchedRule(api).getMaxTps()) {

notification.notify(NotificationEmergencyLevel.URGENCY, "...");

}

if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {

notification.notify(NotificationEmergencyLevel.SEVERE, "...");

}

// 改动二：添加接口超时处理逻辑

long timeoutTps = timeoutCount / durationOfSeconds;

if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {

notification.notify(NotificationEmergencyLevel.URGENCY, "...");

}

}

}

这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check () 函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。

上面的代码改动是基于「修改」的方式来实现新功能的。如果我们遵循开闭原则，也就是「对扩展开放、对修改关闭」。那如何通过「扩展」的方式，来实现同样的功能呢？

我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：

第一部分是将 check () 函数的多个入参封装成 ApiStatInfo 类；

第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。

具体的代码实现如下所示：

public class Alert {

private List<AlertHandler> alertHandlers = new ArrayList<>();



public void addAlertHandler(AlertHandler alertHandler) {

this.alertHandlers.add(alertHandler);

}

public void check(ApiStatInfo apiStatInfo) {

for (AlertHandler handler : alertHandlers) {

handler.check(apiStatInfo);

}

}

}

public class ApiStatInfo {// 省略 constructor/getter/setter 方法

private String api;

private long requestCount;

private long errorCount;

private long durationOfSeconds;

}

public abstract class AlertHandler {

protected AlertRule rule;

protected Notification notification;

public AlertHandler(AlertRule rule, Notification notification) {

this.rule = rule;

this.notification = notification;

}

public abstract void check(ApiStatInfo apiStatInfo);

}

public class TpsAlertHandler extends AlertHandler {

public TpsAlertHandler(AlertRule rule, Notification notification) {

super(rule, notification);

}

@Override

public void check(ApiStatInfo apiStatInfo) {

long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();

if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {

notification.notify(NotificationEmergencyLevel.URGENCY, "...");

}

}

}

public class ErrorAlertHandler extends AlertHandler {

public ErrorAlertHandler(AlertRule rule, Notification notification){

super(rule, notification);

}

@Override

public void check(ApiStatInfo apiStatInfo) {

if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {

notification.notify(NotificationEmergencyLevel.SEVERE, "...");

}

}

}

上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？具体的使用代码我也写在这里了。

其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。

public class ApplicationContext {

private AlertRule alertRule;

private Notification notification;

private Alert alert;



public void initializeBeans() {

alertRule = new AlertRule (/*. 省略参数.*/); // 省略一些初始化代码

notification = new Notification (/*. 省略参数.*/); // 省略一些初始化代码

alert = new Alert();

alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));

alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));

}

public Alert getAlert() { return alert; }

// 饿汉式单例

private static final ApplicationContext instance = new ApplicationContext();

private ApplicationContext() {

initializeBeans();

}

public static ApplicationContext getInstance() {

return instance;

}

}

public class Demo {

public static void main(String[] args) {

ApiStatInfo apiStatInfo = new ApiStatInfo();

//... 省略设置 apiStatInfo 数据值的代码

ApplicationContext.getInstance().getAlert().check(apiStatInfo);

}

}

现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有下面四处。

第一处改动是：在 ApiStatInfo 类中添加新的属性 timeoutCount。

第二处改动是：添加新的 TimeoutAlertHander 类。

第三处改动是：在 ApplicationContext 类的 initializeBeans () 方法中，往 alert 对象中注册新的 timeoutAlertHandler。

第四处改动是：在使用 Alert 类的时候，需要给 check () 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。

改动之后的代码如下所示：

public class Alert {// 代码未改动...}

public class ApiStatInfo {// 省略 constructor/getter/setter 方法

private String api;

private long requestCount;

private long errorCount;

private long durationOfSeconds;

private long timeoutCount; // 改动一：添加新字段

}

public abstract class AlertHandler {// 代码未改动...}

public class TpsAlertHandler extends AlertHandler {// 代码未改动...}

public class ErrorAlertHandler extends AlertHandler {// 代码未改动...}

// 改动二：添加新的 handler

public class TimeoutAlertHandler extends AlertHandler {// 省略代码...}

public class ApplicationContext {

private AlertRule alertRule;

private Notification notification;

private Alert alert;



public void initializeBeans() {

alertRule = new AlertRule (/*. 省略参数.*/); // 省略一些初始化代码

notification = new Notification (/*. 省略参数.*/); // 省略一些初始化代码

alert = new Alert();

alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));

alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));

// 改动三：注册 handler

alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));

}

//... 省略其他未改动代码...

}

public class Demo {

public static void main(String[] args) {

ApiStatInfo apiStatInfo = new ApiStatInfo();

//... 省略 apiStatInfo 的 set 字段代码

apiStatInfo.setTimeoutCount (289); // 改动四：设置 tiemoutCount 值

ApplicationContext.getInstance().getAlert().check(apiStatInfo);

}

重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check () 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。

修改代码就意味着违背开闭原则吗？

看了上面重构之后的代码，你可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的 handler 类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？

我们先来分析一下改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。

实际上，我们不仅往 ApiStatInfo 类中添加了属性，还添加了对应的 getter/setter 方法。那这个问题就转化为：给类中添加新的属性和方法，算作「修改」还是「扩展」？

我们再一块回忆一下开闭原则的定义：软件实体（模块、类、方法等）应该「对扩展开放、对修改关闭」。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为「修改」，在细代码粒度下，又可以被认定为「扩展」。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为「修改」；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为「扩展」。

实际上，我们也没必要纠结某个代码改动是「修改」还是「扩展」，更没必要太纠结它是否违反「开闭原则」。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。

我们再来分析一下改动三和改动四：在 ApplicationContext 类的 initializeBeans () 方法中，往 alert 对象中注册新的 timeoutAlertHandler；在使用 Alert 类的时候，需要给 check () 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。

这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是「扩展」，而是地地道道的「修改」。不过，有些修改是在所难免的，是可以被接受的。为什么这么说呢？我来解释一下。

在重构之后的 Alert 代码中，我们的核心逻辑集中在 Alert 类及其各个 handler 中，当我们在添加新的告警逻辑的时候，Alert 类完全不需要修改，而只需要扩展一个新 handler 类。如果我们把 Alert 类及各个 handler 类合起来看作一个「模块」，那模块本身在添加新的功能的时候，完全满足开闭原则。

而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不「修改」，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。

如何做到「对扩展开放、修改关闭」？

在刚刚的例子中，我们通过引入一组 handler 的方式来实现支持开闭原则。如果你没有太多复杂代码的设计和开发经验，你可能会有这样的疑问：这样的代码设计思路我怎么想不到呢？你是怎么想到的呢？

先给你个结论，之所以我能想到，靠的就是理论知识和实战经验，这些需要你慢慢学习和积累。对于如何做到「对扩展开放、修改关闭」，我们也有一些指导思想和具体的方法论，我们一块来看一下。

实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的「金标准」。如果某段代码在应对未来需求变化的时候，能够做到「对扩展开放、对修改关闭」，那就说明这段代码的扩展性比较好。所以，问如何才能做到「对扩展开放、对修改关闭」，也就粗略地等同于在问，如何才能写出扩展性好的代码。

在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些「潜意识」可能比任何开发技巧都重要。

在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到「对扩展开放、对修改关闭」。

还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。

我们前面讲到，代码的扩展性是代码质量评判的最重要的标准之一。实际上，我们整个专栏的大部分知识点都是围绕扩展性问题来讲解的。专栏中讲到的很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。设计模式这一部分内容比较多，后面课程中我们能会详细讲到，这里就不展开了。今天我重点讲一下，如何利用多态、依赖注入、基于接口而非实现编程，来实现「对扩展开放、对修改关闭」。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了「很多设计原则、思想、模式都是相通的」这一思想。

接下来，我就通过一个例子来解释一下，如何利用这几个设计思想或原则来实现「对扩展开放、对修改关闭」。注意，依赖注入后面会讲到，如果你对这块不了解，可以暂时先忽略这个概念，只关注多态、基于接口而非实现编程以及抽象意识。

比如，我们代码中通过 Kafka 来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：

// 这一部分体现了抽象意识

public interface MessageQueue { //... }

public class KafkaMessageQueue implements MessageQueue { //... }

public class RocketMQMessageQueue implements MessageQueue {//...}

public interface MessageFromatter { //... }

public class JsonMessageFromatter implements MessageFromatter {//...}

public class ProtoBufMessageFromatter implements MessageFromatter {//...}

public class Demo {

private MessageQueue msgQueue; // 基于接口而非实现编程

public Demo (MessageQueue msgQueue) { // 依赖注入

this.msgQueue = msgQueue;

}



//msgFormatter：多态、依赖注入

public void sendNotification(Notification notification, MessageFormatter msgFormatter) {

//...

}

}

对于如何写出扩展性好的代码、如何实现「对扩展开放、对修改关闭」这个问题，我今天只是比较笼统地总结了一下，详细的知识我们在后面的章节中慢慢学习。

如何在项目中灵活应用开闭原则？

前面我们提到，写出支持「对扩展开放、对修改关闭」的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？

如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解「它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？」等问题。

不过，有一句话说得好，「唯一不变的只有变化本身」。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。

最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。

而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的 Alert 告警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。

在我们之前举的 Alert 告警的例子中，如果告警规则并不是很多、也不复杂，那 check () 函数中的 if 语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。相反，如果告警规则很多、很复杂，check () 函数的 if 语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。

重点回顾

今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的的重点内容。

1. 如何理解「对扩展开放、对修改关闭」？

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为「修改」；在细代码粒度下，可能又被认定为「扩展」。

2. 如何做到「对扩展开放、修改关闭」？

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

课堂讨论

学习设计原则，要多问个为什么。不能把设计原则当真理，而是要理解设计原则背后的思想。搞清楚这个，比单纯理解原则讲的是啥，更能让你灵活应用原则。所以，今天课堂讨论的话题是，为什么我们要「对扩展开放、对修改关闭」？

欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview

© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (216)

下雨天

对拓展开放是为了应对变化 (需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！

2019-12-09

辣么大

开闭原则：基于接口或抽象实现「封闭」，基于实现接口或继承实现「开放」（拓展）。

争哥的第一个例子，AlertHandler 为抽象，一般是固定不变的。子类 TpsAlertHandler 为继承；再看第二个例子，MessageQueue，MessageFormater 为接口，具体实现为 KafkaMessageQueue 和 JsonMessageFromatter 等。以后替换或者增加其他的 AlertHandler 和 message queue 很容易。

两个例子中的抽象类和接口是固定的（封闭），继承或实现是可扩展的。通过「抽象 - 具体」体现了开闭原则，增加了软件的可维护性。

开闭原则具体应用，需要慢慢积累经验。争哥也说了，首先需要有对业务深刻的理解。其次就是学习一些设计原则和模式了。

补充：

1、Bertrand Meyer 1988 年提出 open-closed principle。

2、再推荐一篇经典文章 Robert C. Martin 2006 年写的 The Open-Closed Principle。不方便下载的话，我放到 github 上了：https://github.com/gdhucoder/Algorithms4/tree/master/designpattern/pdf

2019-12-09

Paul Shan

基于一定的粒度（例如模块，类，属性等），扩展是平行地增加，修改是变更更细粒度的子集。扩展和修改和具体的粒度有关。不同的粒度下，扩展和修改定义不同。

我个人以为，扩展的结果是引入了更多的平行结构（例如相似的派生类 handler），以及支持这些平行结构的代码（利用多态，在关键的地方使用接口）。这些引入会让代码结构变的扁平一些，但是也更晦涩一些。修改，往往会增加代码的深度（这里指更低粒度的复杂度），例如，文中 log 例子，修改后，check 函数有五个参数，内部的 if else 逻辑更多。但是，如果从参数以及 if 作用域的角度，这也可算作扩展。所以，扩展还是修改更本质的区别在于修改发生的粒度和层次。

通常偏好修改发生在更高的层次上，这要求我们能够用接口和组合把系统合理的切分，做到高内聚和低耦合。高内聚可以让修改发生在更高层次上，替换掉整个低层次实现细节。低耦合，可以让模块之间的调用最小化，可以让高层次的修改最小化。

支持高层次的平行结构不是免费的，除非有明确的收益（例如文中隔离 Kafka 实现细节的例子），不然还是让重构等待到需要的那一刻，预测未来的大部分平行结构其实不会被真正用到。

2019-12-09

墨雨

听前一部分的时候觉得，哇原来代码还可以这样重构，我以后写代码一定要这么写！看到最后，恩…… 还是要结合具体业务需求，考虑实现开闭的代价，取舍哪些需要适应开闭原则哪些可以忽略，避免过度设计。整体来说在写代码的时候要多思考一下如何应对短期内可能面临的变化。知识 + 经验 + 多思考，看起来编程没有银弹，多思考，多总结。

2019-12-09

古杨

我所在的公司，现在写代码入参全用 map，写了两年我都不知道什么叫对象了。感觉自己废了☹️

2019-12-26

(´ 田 ω 田 `)

修改老功能，可能需要重新进行各种功能验证、测试，并且如果是接收的遗留代码，更是费时费力；

但是扩展的话，只需要对自己新增加的功能进行测试，工作量会小很多。

2019-12-09

feifei

文中的 alter 一步一步的改造，看的眼花缭乱的😂，我就问下，为什么不能直接在原始的 Alter 类中，重载一个只有新增业务参数的 check 放到的，这样不就最简单，原先开发好也不用动，这样对于 Alter 类来说不是对扩展开放，对修改关爱了吗？请教下大神，我这种用重载的思路有啥，不好的地方

作者回复：重载可以。但如果报警规则很多的花 类会无限膨胀 可读性比较茶

2019-12-18

知行合一

对原有代码改动越少，引入问题的概率越小。在熟悉业务的情况下，多思考一步，为了未来需求预留扩展点，就是有扩展性的代码。但凡事都有个度，扩展性和可读性需要不断权衡，需求在不断变化，系统也在不断演化，通过不断重构来解决过度设计的问题。

2019-12-09

木木

文章写的是真的好，很容易读懂。主要的还是要知道为什么要这么做。感谢老师。

2019-12-11

deepz

老师您好，我把代码实践了后发现，单例初始化那块可能有点问题。private static final ApplicationContext instance = new ApplicationContext ();

private ApplicationContext() {

instance.initializeBeans();

}

这个「instance」报了空指针。

2019-12-10

梦倚栏杆

关于修改后的报警规则代码实现有两个疑问：

1. ApiStateInfo class 是充血模型还是贫血模型。

2. 其实各个 handler 侧重的是不同的方方面面，比如错误次数，超时次数。统一接收 ApiStateInfo 和 某一个 handler 接收具体的类比如：ErrorRequestApiStateInfo, TimeOutStateInfo，哪种方式好呢？比较依据是什么

作者回复: 1. 是贫血模型

2. 不好讲，拆分之后，类增加，维护成本高一些，但职责更单一，更加高内聚、低耦合，扩展性更好些。

2019-12-09

李小四

设计模式_16

# 作业：

开闭原则核心好处是：

- 减少因为新增功能而增加的工作量

- 减少因为新增功能而增加的出错数

# 感想：

之前一直有一些执念，想要找到某一原则非黑即白的分割线。比如开闭原则，有两个极端：

- 任何的「修改」都不能接受

- 任何不能「扩展」的代码都不能接受

然后就进入了「走火入魔」的状态，最终陷入对原则的怀疑。

需求变更对于代码结构影响很大时，要提高对其扩展的权重；读到这里时，我拍了一下大腿，我想，我更加理解开闭原则了。

2019-12-09

CoderJ

计算机技术就是一门权衡的技术！

2020-03-28

👽

简单来说，就是尽量减少调用方为了应对而导致的变更。

就例如本文的例子，为了应对变化需要增加函数的参数的时候。所有调用方都需要改代码。

而如果依照开闭原则，则增加 handler 以及相应修改即可。并不会影响调用方。

其实个人认为，也是通过了 类似于「中间件」的形式。例如，小明，作为公司代表需要跟各个国外公司的人谈业务。他去跟美国人谈业务，需要学英语；跟日本谈业务，要学日语；跟毛子谈业务，又要学毛子语。

这时候，的解决方案：

1，跟各个国家说好，大家都说英语。或者都说汉语。就算再有其他的国家，也让他强制用英语。

2，小明自己只用汉语。然后谈业务时，带个多语种翻译，去谈业务时把翻译带上。这时候，如果有新的国家需要新的语种，那么就让翻译去掌握更多的语种。

应对今天的例子，翻译掌握的语种，其实就是 handler。小明和各国代表谈业务时，各自都不需要变更自己的接口。只需要对【翻译】进行扩展即可。

2019-12-10

wenxueliu

spring 是如何应用开闭原则的，可以参考本文 https://blog.csdn.net/wenxueliu/article/details/103467359

2019-12-10

哈喽沃德

我想这篇对扩展开放，多修改关闭的文章应该会成为争哥这个设计模式系列最好的文章。很难想象，一个杰出的程序员的语言思维逻辑也是如此清晰。

2019-12-10

土豆哪里挖

什么时候出其他语言的 demo 呢，不懂 java，理解起来太痛苦了

作者回复：关注我的 github：https://github.com/wangzheng0822

2019-12-09

随心而至

结合徐式伟老师的课效果更好

第一，模块的业务要稳定。模块的业务遵循「只读」设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是架构治理的基础哲学。

第二，模块的业务变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为「最小化的核心系统 + 多个彼此正交的周边系统」。事实上回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。

文章链接：https://time.geekbang.org/column/article/175236

2019-12-12

辉仔 lovers

老师 您好，请教几个问题

AlertHandler 使用的是抽象类，而不是接口。就是为了让子类去继承构造方法吗？

这个扩展跟 spring 中 handlerMapping 的写法一样，类似于策略模式吧？

单例模式的时候 使用静态代码块来初始化添加 handler 随着类加载一次是不是就不用搞成单例的了？

static{

alertRule = new AlertRule (/*. 省略参数.*/); // 省略一些初始化代码

notification = new Notification (/*. 省略参数.*/); // 省略一些初始化代码

alert = new Alert(alertRule,notification);

alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));

alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));

}

我们是不是可以把实现类（不同的 handler）放到配置文件中。使用 jdk 的 spi 扩展机制。更加灵活一些？

2019-12-09

小晏子

对于课后题，想到 2 点:

1，减少出错概率，修改出错的概率比扩展要大

2，边界的问题，比如用户边界，尽量减少用户侧代码的改动，比如文中 alert 的事例，check 函数本身的修改意味着所有使用的地方都要修改，而使用了开闭原则的代码对于老用户是无须修改的，降低了用户修改的成本。

2019-12-09

Kingram

为什么要遵循开闭原则？

1、修改原有复杂的业务代码本来就存在一定的风险，同时耗费精力，可能影响到别的你不知道的地方，导致程序运行故障。

2、修改代码同时单元测试也要跟着修改，浪费时间精力。

3、可扩展性差的代码同时封装性也会差，违背面向对象设计原则。

补充：但是注意不要过度设计呦

作者回复：嗯呢 ������

2020-11-26

航哥很帅

之所以会有对扩展开放，对修改关闭的原则，是因为对扩展开放能够应对业务需求的变化，从而实现已有功能的扩展，而对修改关闭是为了保证在扩展新的需求是，能够保证已有功能的稳定。

对扩展开放，对修改关闭原则，听起来很简单，就是指我们在开发时尽可能的少修改已有的代码，而应该增加新的代码来实现新的功能。但对于这个原则，往往是很难绝对执行的，因为即使是完全增加新的功能，也很难做到百分百不修改原来的代码。所以，对扩展开放，对修改关闭的原则，用大白话来说就是在尽可能少修改以后功能代码的情况下，通过增加新的功能代码来实现新的功能。

如果想做到对扩展开放，对修改关闭，作为一个程序员要有扩展意识、封装意识和抽象意识。这三个意识听起来很简单，但要真正的做到必须要多实践多练习才能够慢慢的心领神会。

作者回复：总结的好

2020-11-17

Younger Ku

对修改关闭：代码主要是为了实现业务，不让修改是因为直接修改的话可能会影响业务系统的正常运行。对扩展开放：系统预留扩展点，这些扩展点的改动通常不是直接实现业务的需求，而是辅助实现业务的代码，使得新扩展的功能与之前功能保持一种隔离，同时又能灵活切换。

2020-09-09

了 @事 @牵

争哥，

public class MessageFormatter implements MessageFormatter {//...}

这段代码是不是有问题？

作者回复：是的，我改下，多谢指出

2020-07-04

Remember 九离

PHPer 的朋友 我根据上面需求实现了一遍，感兴趣的可以看下: https://github.com/wuqinqiang/php-design-patterns/tree/master/src/object/ocp

2020-03-01

薯片

if 分支很多，用 handler 导致类爆炸怎么处理？

作者回复：没看懂你说的 为什么 handler 类会爆炸呢

2019-12-29

L.

学到了，谢谢老师；

2019-12-09

编程界的小学生

个人分析的原因

1. 不这么做的话将来某个方法会越积越多，代码行数越来越长，等回过头来修改的时候自己可能都要读上十分钟才能找到下手的机会。

2. 确实有好处，每次只修改修改具体实现，而对外是无感知的，调用方并不关心实现细节。

3. 需求下来后，分析出某块东西可能会频繁更改后，且采取了这种对修改关闭，对扩展开放的思想来编码后，那以后需求变动的时候才知道什么叫真香。

2019-12-09

tingye

例子中的 AlertRule 类也需要修改，添加 MaxTimeout 定义。可以考虑把规则按统一的格式写入数据库，统一解析，这样扩展规则只要添加规则数据就行了，不用改代码

2019-12-09

黄林晴

打卡✔

2019-12-09

业余爱好者

扩展指的是「修改」或替换一个系统的功能，修改指的是对系统整体结构的篡改。系统的整体架构是不应该有大变动的，它相当于系统的本质，是相对稳定的部分。如果乱动的话，系统会变得连妈都不认识。

开闭原则不仅用于软件开发，拿计算机硬件设计为例。计算机的本质在于计算，这是计算机稳定的部分，是不应该乱动的。对应与计算机中的硬件就是 CPU，CPU 的指令集可以说相当稳定，几十年来几乎只是从 16 位变成 32 位，64 位。（这里是不是也体现了开闭？当然这不是重点）。而 io 的部分是异变的，磁盘，显示器，鼠标，打印机，不一而足。稳定的是什么，是输入输出（相当于没说，本来就是 io 嘛）。对于计算机来说，它不管你使用什么 io 设备。在我 CPU 看来，就是在执行一条 io 指令（指令本身是稳定的），具体 io 逻辑的实现交给各种设备控制器。妥妥的开闭原则。

2019-12-09

aya

【我们都需要在扩展性和可读性之间做权衡】说得太好了，优秀开发人员分得清原则和真理，面对随时的变化做权衡的能力才是最重要的

2019-12-09

snake

有点像策略模式

2020-12-21

Geek_2495de

为什么我们要「对扩展开放、对修改关闭」。我理解出了两个问题：

第一个：为什么要遵循开闭原则：

这是一种可以提高扩展性的原则。意味着，我们将来遇到新的需求时，可以投入比较少的人力时间成本去做开发、测试、上线回归。

第二个：为什么开闭原则里面：是对「扩展」开放，对「修改」关闭

如果关闭扩展，开放修改。那一个需求 B 的增加，意味着从 A 变成 A'+B。原来跟 A 都有关的地方都要考虑。如果 A 原有 100 个逻辑，对开发和测试的要求要更大，也容易因为考虑不周，导致上线后不够稳定。

2020-12-13

天下行走

我们组的一位老员工就是一个模块就是像上面改良后的 Alert 做的设计，后边来的我们真的看的那叫一个痛苦啊，找一个逻辑每次都要一层层回溯，一个个类的理解，绝大多函数不超过 10 行代码，还包括 trycatch，真的遭罪。所以这种抽象个人理解是不是可以说如果没有最后自信组织好层次关系，别一上来就堆这一堆类，给后人挖坑倒不至于，让后人加班是真的。

2020-12-06

龙猫

回头再看第二遍，这个例子不就是责任链模式的变体 + 工厂模式吗

作者回复：嗯嗯

2020-11-29

1234567890

老师请教你个问题，什么是粗粒度代码什么是细粒度代码？

作者回复：这个要根据实际情况来定

2020-11-27

🍃

不会 java 的我理解起来有点吃力啊

作者回复：还好吧，理解思路为主

2020-11-26

fenciso

对修改关闭，是为了增加新功能，但不影响已有的功能，增加不必要的成本。对拓展开发就是为了应对不断变化的功能需求

作者回复：对的

2020-11-22

Leo

为什么我们要「对扩展开放、对修改关闭」?

写代码一方面是为了满足功能需求，另一方面是为了让「他人」读懂，而不是自嗨。设计模式不是为了展现自己的能力，而是为了应对变化，很多软件需要做成插件、或者可插拔架构，都是为了方便其他人拓展。

「对扩展开放」是为了适应变化，「对修改关闭」是把代码封装好，减少不必要的错误改动。

作者回复：嗯嗯������

2020-11-20

间接性失忆患者

对开闭原则的使用一直很纠结，感谢老师这么实用的建议和距离。有种豁然开朗的感觉，终于不会再纠结这个了。

2020-10-30

Alex

对扩展开放，对修改关闭，可在增加功能时尽量少的引入问题

2020-10-25

微末凡尘

对扩展开放是为了应对变化，对修改关闭是为了保证现有代码的稳定性，最终结果是为了让系统更加的有弹性～

2020-10-22

朱月俊

打个比方，从古至今，管理一个团队，组织，企业，社会，国家，世界都需要合适的规则，才能够让系统内部的角色往效率更高的方向发展，收益更大。

对代码也是，如果代码未来发展想要前途无量，也需要规则去指导，而对扩展开放，对修改关闭就是一个战略性规则。

2020-09-26

Ilearning99

对扩展开放，保证了程序的灵活度，对修改关闭，保证程序不影响现有代码运行

2020-09-13

Kang

基于接口而非实现编程，这个我深有体会，我们在做集群内本地缓存的同步方案的时候，就是基于接口，然后使用不同的技术框架实现了，经过压测和实践选择了比较合适我们的，我们基于 zk，redis，mq，分别都实现了，可供不同场景不同系统选择，并且后期也可以快速替换，非常赞同和深有体会 基于接口而非实现编程！

2020-09-11

大力

对修改开放的话，对之前的代码的改动很可能会牵一发而动全身，除了要花更多时间做改动以外，还要花更多时间做测试，性价比低。

2020-09-05

liliumss

如果使用 spring 框架，可以使用把同一类的接口自动获得防止到特定集合去，这样 applictionContext 也不需要修改了，很完美

2020-09-05

JerryZhu

对扩展开放，是很容易面对未来不确定的需求变更，扩展方便了 才能以更小的改动对整个新需求的匹配，也可以让上游系统少改动，甚至不改动，无感的适配新的需求。对修改关闭，也不是说要完全杜绝修改，对于新需求而言，不可能完全不修改任何原有代码就能实现的，而我们需要做到的是，尽量少的对原有代码进行层层修改，不然代价会非常大的，导致最后可读性变差，可维护性更差

2020-09-04

宇天飞

1、对修改关闭：为了兼容性。保证原有的系统行为不受影响、包括测试性。

2、对扩展开放：为了增加更多的功能、更大的价值

2020-09-03

Hunter_Dark

在 spring 框架中，这些设计怎么用？

2020-09-03

X_L～

感谢争哥，很清楚，写代码时的潜意识确实很重要，像内功一样

2020-09-02

Geek_35cfdd

为什么要对扩展开放，对修改关闭。还是分情况的，如果是简单的系统，业务逻辑单一且缺少变化，那么可以不用设计出复杂的代码去满足这个设计原则。如果对于复杂系统，业务逻辑根据场景多变，且各个场景业务逻辑不同。这个时候就需要好好设计代码，在新增场景有新的业务规则时可以横向扩展，避免影响之前的老代码，一方面是回顾成本大，第二是容易导致不了解这块的人无法覆盖全导致出线上问题。

2020-09-02

郑大钱

「对拓展开放是为了应对变化 (需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！」

简直就是写出好代码的精髓！

代码的扩展性会跟可读性相冲突，难怪我在阅读开源代码的时候，觉得很吃力，就算勉强了解了它的功能，也不能识别它的设计模式，也很难借鉴。

2020-08-31

蛀牙

学到这一课有种渐入佳境的感觉。突然理解了设计模式的美。这样先给个简单的实现，再给个运用开闭原则的实现非常贴合我的思维模式，就是在我的现有基础上实现了拔高。

而且这个例子确实是在工作中会遇到的实例，有助于遇到类似问题时的思维迁移。

2020-08-25

。华伟

不破坏原有代码的正常运行，不破坏原有代码的单元测试

2020-08-25

火影。海诺

对修改关闭是服务于分装思想的，是为了对现在代码负责，对扩展开放是为了以后代码能基于现在代码的一个功能扩展，为了未来服务

2020-08-17

阿骨打

自己又画了一遍整个思路，第一次学设计模式，确实 Handler 这个类让我受益匪浅，已经理解了开闭原则，确实扩展性太强了，只是感觉 Class 会增加很多，这是不是也不好呢

2020-08-16

站在岸上的鱼

如何在不改动原有代码逻辑的情况下，新增功能。

2020-08-11

龙猫

mybatis 的数据类型转换也用到了第一个例子的方式，定义了不同 handler 类处理 java 对应的数据库类型。真正做到了可插拔、可扩展的方式，而不是像大部分代码一样用 if...else... 判断

2020-08-06

杨逸林

第一部分的代码不就是 Spring MVC 中的，HandlerMapping 中取 Handler，它将所有标记为 @RequestMapping 的方法包装成 MethodHandler 然后在 DispatcherServlet 中调用对应的 Handler 吗？

第二部分，Spring Cloud 的 DiscoveryClient 就是服务注册的接口，Spring 中有很多这种定义了的组建接口，也是 Java 的 SPI 很好的实现

2020-08-05

Geek_31594d

对扩展开放、对修改关闭，大体理解为对原有的功能实现方式在不必要的情况不要去修改，因为每次修改都要重新进行单元测试，扩展可以认为对新类 模块 方法 属性的新增 增强

2020-08-05

写代码的

我觉得开闭原则的一个关键点就是一个模块的新增功能不会影响到这个模块的对外接口。比如例子中的 check 方法，因为新增功能导致了方法参数的增加，从而导致了所有使用这个方法的地方都得修改。

2020-07-29

幽林萌逐

打卡，新的一天看了 handler 这个思想我 get 了新的姿势，准备重构一个正在开发的服务了

2020-07-27

hex

现在一直在写不扩展代码啊。码农。看了这篇之后感觉飘起来了

2020-07-22

D 灯先生

对扩展开放、对修改关闭，可以对应为两个扩展

一，对扩展开放是为了更好的扩展业务，因为业务一直在演进变化，我们期望能通过最小的开发量和时间代价最快速实现业务扩展

二、对修改关闭是为了更好的代码扩展及维护，由于有第一点铺垫，在实际开发中，唯一不变的就是业务的变化，我们不可能每次业务的迭代都将代码推倒重来，这样代价太大了。所以，兼顾到代码的可扩展和维护是非常有必要的。

总结下来，"对扩展开放、对修改关闭" 实际上是对以上两个扩展的一个平衡，能够作为兼顾两者的一个方法论。但事件总是有两面性，在实现单一职责的同时免不了增加代码的复杂度，对于阅读理解代码会造成一定的困难。

2020-07-12

超超

对扩展开放，对修改关闭原则实施是建立在业务充分熟悉理解基础之上的，不是凭空臆想的结果，而是针对业务逻辑经常适配修改点或可察觉的未来扩展业务功能点，提炼修改点的「不变」内在逻辑，提炼成框架，实现新增功能时不影响原有逻辑或单元测试 LLT 用例。

2020-07-08

LH

经常碰到有的人接手别人代码的时候在哪里 pen，不好扩展，代码可读性不好云云。有功夫 pen 你就去重构啊

2020-06-30

杨锋

对扩展开放，对修改关闭好处很多。最主要是可以有效规避因为修改原逻辑产生新的问题。

2020-06-25

被过去推开

为什么要对修改关闭？对我而言，最主要的原因是不想因为新需求，而去影响已经十分稳定的功能

2020-06-25

大方方

参数类的修改那里 也可以应用多态扩展吗？ 比如设置一个抽象或者接口来作为参数类 IParameter or IData，然后根据需要，去扩展所需的新参数类 MyData。然后在具体扩展出的 handler 里比如 Myhandler ，将收到的 idata 再 unbox 成该 Myhandler 对应的扩展参数类 Mydata 。缺点就是有一次开箱操作，但是参数类的代码设计会和 handler 一样变成纯扩展，不用再纠结是不是修改操作了

2020-06-25

见南山

对扩展开放，对修改关闭。

老代码很可能不是当前维护人开发的，测试用例、功能点等有可能会忽略掉某些细节，直接修改，容易引入 bug，而且，即使细节全部清楚，对原有代码修改后，对应的测试同样需要修改，新功能 + 老功能一起测试，徒增工作量啊，还容易出错。

2020-06-23

maybe a miracle

思考题：为什么对修改关闭？修改意味着引入风险，对现有系统可能造成影响，本来已经测试通过的系统，因为修改了，必须重新测试。而原来的单元测试也已经不能用，测试成本太大。为什么对扩展开放？通过添加新类新属性新方法来实现功能的扩展，不需要修改原有的东西，只需要测试新增的部分，成本最小最可靠。

2020-06-14

marsly

把变动划到易控的范围内

2020-06-08

今夕何夕

开闭原则是为了提高代码的扩展性，对已有代码的修改往往会造成不可预知的错误。对修改关闭是为了提高代码的稳定性。

2020-06-08

马球先生

为什么我们要「对扩展开放、对修改关闭」？

对于已有的功能，可以比较放心质量，不用再重新全部测试一遍。

只需要保证新添加的部分功能是正确的就好。

2020-06-04

小强哥

Alert 优化后的例子同时也支持了报警方式的可插拔，比如：可以任意组合报警方式，而原来的 if else 是不支持的

2020-06-03

scmath

不变的部分是扩展点，是依赖注入，变化的部分封装为接口，根据接口编写多个实现，通过装配 component 完成扩展和开闭原则，通过增加接口实现和在装配是用哪个接口实现，隔离变化，实现修改关闭扩展开放。

装配层决定着系统的行为。

2020-06-02

scmath

对象和方法的封装命名分层：

首先把需求中的名词分组封装为实体，把动词封装为方法，OOA 过程的划分非常重要直接影响可读和可扩展。属性用名词开始，方法用动词开始如 initXxx、updateXxx。设计属性时有子对象 (UML 的关联组合聚合关系)。数据实体的子对象的 repository 实现可以在主对象提供 get 方法关联表一次取出数据，也可以分拆到子对象的 repository 中在 service 层组合，insert、update 建议在子对象的 repository 中完成。

预留扩展点：

考虑未来的可能的变更，把变化的和不变化的分开，「变化的封装成接口」，「不变化的依赖接口」，这样在有新需求时，实现接口后，在装配层组合功能替换原有功能。

一个接口多个实现，这些实现同时使用，可以考虑引入 handler 的概念，把多个实现放入切片或 map 中。

2020-06-02

scmath

开闭原则关键是考虑现在和未来的需求预留扩展点点，扩展点是调用接口、抽象类、函数作为函数的形参传入函数，装配层在外部实例化不同对象传入，实现多种业务的支持。

扩展点一般预留在 service 层，本 package 的 service 的依赖对应 package 的 repository，不依赖其他 package 的 repository，可以依赖其他 package 的 service。所以扩展点的入参和返回值是 BO, 不要出现 entity 和 VO 对象。

2020-06-01

乖，摸摸头

争哥，我看你是把提示规则写在了 alertRule 里面，每个 Handler 对应 alertRule 里面的一个方法，那如果我要是有几百个 Handler ，alertRule 里面就得有几百个 方法，把 alertRule 提示规则 写到 Handler 里面会不会好些，这样违背了 单一职责吗？

2020-05-26

朝小树

学了面向对象和原则，感觉懂了一些，但是对于一些东西是否修改还是要根据经验去考虑。

2020-05-24

Randy

课堂讨论：为什么我们要「对扩展开放、对修改关闭」？

软件开发种唯一不变的就是变化

对扩展开放：主要目的是便于添加新的功能或者模块。在要添加新功能的时候，不至于要推翻原有代码而从头重构

对修改关闭：因为修改原有代码会增加引入 bug 的风险，增加了修改软件开发和测试的成本

2020-05-21

Geek_1f0e17

我感觉在原始样例中做修改最麻烦的就是添加一个接口参数后所有调用的地方都得加参数，那其实最简单的就是多个参数变为一个对象，对对象加一个属性不影响现有接口，check 方法里的加个 if

2020-05-20

林毅鑫

听的有点似懂非懂，再刷几遍。

2020-05-20

anders

为什么我们要「对扩展开放、对修改关闭」：

- 减少「修改代码」带来的新不确定性：最简单的理解，如果修改涉及三个类，最坏的情况就是为三个类带来了不确定性，这种不确定最坏的结果就是三个类都出 bug。而如果只涉及一个类的话，问题就简单多了。这也是为什么出现依赖注入，控制反转，以及一系列设计模式被总结出来的原因。

另外关于扩展，就像作者说的，包含两方面的内容：要实现的可扩展，已经如何实现扩展。

一个是意识问题，一个是技能知识问题。

而个人理解的可「扩展」，实际上是要实现一套「规则」「框架」「流程」「协议」，以便让其他适配或者基于他实现新的功能。小到作者的例子 Alert，中到一个库，框架（如混合 app 中常用的 jsbridge 协议 ），大到通信协议，架构，都是「框架」「规则」的具体实现...

2020-05-17

246 小言

少改动少出问题，系统稳定，早点下班

2020-05-16

孟令超

我觉得是为了保证系统的稳定性，在 添加功能和或者修改功能时候不会影响原来的功能

2020-05-08

scmath

把多个根据条件依赖外部类的代码变成可以多态的接口，把原来依赖的外部类变成接口实现

2020-05-08

JKwar

对修改关闭是为了保持已有代码的稳定性，不用牵一发而动全身，对扩展修改是为了应对不断变化的需求。以前做过分享功能就是类似的，开始只知道 if else 后来看了大话设计模式，重构成策略模式了，跟本章例子一致。现在看了一遍有了新的理解，终于知道扩展的尺度，还是要跟产品多多沟通啊，了解那些业务是要长久做下去的，那些是随时可能改的。

2020-05-06

妙子爸

防止短期内进行大量的代码重构，测试用例失效，上游系统改造。

2020-05-03

KID

基于工作中的理解，修改会造成多处代码需要同步修改，这样容易漏改，也徒增很多无谓的工作量。在代码设计中，我最喜欢就是做到即使以后修改或新增功能，尽量能在源头处改变少量代码，即可实现不同的功能，这就是扩展。

2020-04-27

Geek_小白

开发多年还是对扩展开放做的不好 业务多了 修改极其复杂。泛型和继承 接口编程用的比较多。

2020-04-27

Magic

如果新增需求需要频繁的修改已有代码逻辑，那带来的工作量和 bug 率都会剧增，原因为：

1 已有代码会越改越乱，越改越多，最后往往 if else 遍地，成了 4 不像。改的人小心翼翼，如履薄冰

2 每次修改后，都要进行完整的回归测试，单元测试。如果本身的自动化测试体系做的不好，那么工作量将是惊人的

3 1 和 2 所带来的复杂度和工作量，让 bug 变得不可避免。996 的工作强度，并发的开发任务，更是让这一风险加剧

2020-04-27

鹤鹤有名

对扩展开放是为了是我们设计的架构能够灵活的应对各种新的需求，对修改关闭是避免对原有代码破环性的修改，打乱最初设计好的思路保证原有结构的完整性。

2020-04-04

Ray

争哥，把 Alert 类 check 方法的参数封装为一个 ApiStatInfo 类，这是不是类似之前讲到的贫血模型

alertRule = new AlertRule (/*. 省略参数.*/); notification = new Notification (）

AlertRule、Notification 这两个类是在哪里定义的呢 没看懂这部分的代码

2020-04-02

Ray

「对扩展开放，对修改关闭」就像文章中提到的最根本的问题是解决代码的扩展性问题。

实际开发过程中往往很多时候都只是考虑当下需求的实现，而为做长远设计，导致添加新的需求时如果变动过大不得不重新定义一套。

所以在今后的开发中，首先要了解清楚业务需求，在做设计时多问一个为什么或是多想一点，锻炼抽象意识

不多说了 把文章的代码实现以下去

2020-04-02

小明

请问，如果 AlertHandler 类里面需要用到 Alert 中的信息，这个该怎么弄？

2020-04-02

进击的前端 er

看了两边，再看看留言，收货颇丰！！！

2020-03-31

面向百度编程

争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子，对于工厂模式，根据需求创建想要的对象，难免会去修改代码，这并不符合开闭原则，但是很符合那种比较简单的系统，但是如果你用工厂方法模式，符合开闭原则，但是用在简单的系统真的好么，其实不会，他可能会产生类爆炸，难以管理的情况。依我看来，每种原则，都有其不足之处，想要用好更难，但在项目中，找到解决问题最适合的原则，最适合的场景，和最适合的设计模式，才是最棒的

2020-03-30

面向百度编程

争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子

2020-03-30

墨鱼

对扩展开放是为了方便以后扩展，写之前先考虑一下短期可能有扩展需求的先留着坑。对修改关闭是为了维护代码的稳定性。起码保证以前的测试能正常通过。

2020-03-29

Nick

看完后打算到项目中找到这部分复杂的 if else 代码，跟兄弟们一起重构掉。

2020-03-29

白杨

感觉这几个原则里，这个是最有用的，如果一个方法老是被修修改改以适用新场景，说明不是个好设计

2020-03-29

Skylar

对扩展开放，提高程序的灵活性；对修改关闭，提高程序的可维护性和稳定性

2020-03-29

鸳鸯戏水蝶

告警的例子很棒，学到了。

2020-03-28

白杨

有些变化是不可控的，对扩展开放尽可能的对这种不可控的变化提供了可能，而且隔离了变化与已有的逻辑，同时，对扩展出的变化就易于做单元测试了

2020-03-28

袁帅

在原有的代码上修改可能会导致线上正在运行的代码出现 bug，对扩展开放，是健壮的程序为了应对新的需求

2020-03-27

忆水寒

因为只要修改代码就容易引入 bug，甚至引起原来功能的使用。而基于扩展的思路，新功能对原来功能基本没影响。

2020-03-25

陈包佳

开闭原则是代码开发中的最高指导原则，目的是为了提升代码的可扩展性，如何实现？需要有较强的扩展思维，抽象思维和封装思维，针对接口而非实现编程，依赖注入，多态等提升代码的扩展性。修改和扩展也是针对不同粒度上的定义区分，尽量在粗粒度上修改，细粒度扩展，减少改动面，和影响面。

2020-03-23

秋风画扇

1. 对修改关闭：是因为写完的功能，可能被很多地方引用，如果后期贸然修改可能带来灾难性的问题。有一个心法就是「把所有的功能都当作对外 API 来实现」，这样写完就发布出去了，想改就得督促其他同学改动代码。这样就会强迫你把接口写的干净、整洁

2. 对扩展开放：要做到这一点就得保证高内聚，功能职责单一以不变应万变。比较好的代码应该是分层明确，大致可以分为基础层、服务层、业务层。基础层负责基本的数据组织不含业务逻辑；服务层则是对基础层的组合；业务层的处理逻辑依赖服务层来实现。整体上看应该是个「倒三角」结构，于是底层接口越是需要「内聚、单一」，切不可轻易修改代码。

2020-03-22

汝林外史

在私有的构造方法中执行了 initializeBeans () 方法没问题吗？ 那个私有的构造方法会执行到么？

2020-03-20

新的起点，新的开始 ^_^

对扩展开放：是因为需求会有变动，变动的需求，对代码进行扩展来满足需求

对修改关闭：是因为修改已经完成的代码，可能会对之前调用的逻辑产生影响。

2020-03-17

肖臧

发送短信，邮件这种耗时的操作，是不是该搞个线程池呢？

2020-03-17

肖臧

对修改关闭是保证原有功能的稳定性，对扩展开放是为了更方便的新增功能

2020-03-17

猫在屋里晒太阳

在告警的案例中，如果我有 50 个告警规则是否意味着需要 50 个 handler 类来处理？这样就会导致 handler 类爆炸，针对这种情况老师有什么建议？

2020-03-17

wl

本篇学完了，mark 一下。

原来可扩展性的代码是这样写的，下次在项目中尝试下，只有实践过的，才会更有体会。

2020-03-13

未来小娃

【设计模式笔记 17】20200304

今天分享了开闭原则的判断标准以及如何写出符合开闭原则得代码，简单来说就是尽量修改少得代码满足不断迭代的需求，是不断变化的，运用开闭原则可以提高系统得扩展性喝稳定性，随着代码复杂度升高经常会有牵一发动全身的危险，所以再设计之初就考虑不变的和变化的东西，具备抽象思维我觉得是提高代码稳定性的重要工具，很多代码可能都有什么相似得逻辑，需要不断重构将公共能力服务化，其实就是不断抽象得结果

2020-03-04

极极

老师，这段代码更接近于责任链模式 还是 发布订阅模式？

2020-03-04

小田

# 要点小结

1. OCP 的根本目的：实现可扩展、易维护的代码

2. 定位扩展点的方法：具有全局观 —— 对业务模型有清晰的认识和好的设计，以知道代码实现

3. 实现扩展点的方法：【微观】多态、接口、依赖注入 / 控制反转；【宏观】各种设计模式

2020-02-27

色即是空

应该成立一个新的学科，面向未来编程

2020-02-23

小文同学

面对变化的需求，从实现操作方式上可以分为修改、拓展。从这个原则上看，是建议通过拓展来实现新的需求。

大体还是成本问题，用修改去实现需求，必须要倒推修改所影响的模块，重新测试。这边是一个成本很高的操作。

拓展则承诺在实现新功能时，不会影响以往核心的功能，因此成本更低，更安全。

2020-02-22

Heaven

这个问题，我是这么理解的，假设我在一个模块下有一个函数，如果有同事想要复用我这个代码，发现少参数了，是不是需要给我的方法的入参进行修改，来满足其需求，那么这个方法原有的调用者都需要被修改，并且我们经常写的接口类，实现的业务，都是基于 SQL 驱动的，修改者为了满足新的需求，可能连 SQL 语句都修改了，那么这种修改的成本实在太高了，但是如果提前预留了扩展点，方便同事扩展来满足新需求的同时，对原有的上游系统不会进行改变，甚至数据存储层也不会改变，那么这个成本就很低了

2020-02-21

巨龙的力量啊

对于重要业务方法做到入参可控，多分支抽象出类，多用组合，感觉这个就基本能够做到这个条件

2020-02-10

wai

为什么「对扩展开发，对修改封闭」，我认为最重要的一点：降低新功能上线对已有功能的影响，提升产品稳定性，这对于 ToB 的企业尤其重要。

2020-02-04

Nestor.liu 刘明丰

开闭原则就是把易变的和不易变的代码隔离起来，把易变的代码封装起来，隐藏变化的细节，暴露并提供稳定的抽象接口，让接口的使用方更加舒服，将来变化来的时候，我们仅仅需要扩展暴露出来的稳定接口而已，在接口的使用方考虑使用容器技术，实现控制反转，代码就达到了易维护的目的。

2020-02-03

jony

对修改关闭是为了代码的稳定性，对扩展开放是为了功能的扩展，二者是统一看待的。

2020-01-27

磊

对扩展开放：代码在新增功能的时候，可以快速修改代码，同时尽量减少对之前的代码的影响。

对修改关闭：修改现存的代码会带来诸多问题，对于已经引用这个修改类的方法或者类，都需要修改，并且需要充分测试，才能上线，这里面就牵涉到代码的重构，代码重构的基本原则就是在重构后的代码，需要经过充分的测试才能上线。

2020-01-27

Value

对扩展开放是因为需求总有不确定性，留下可扩展点，后期对系统的改造程度最小，最能平稳保持系统的运行。而对修改关闭也是同理，保持现有系统的稳定性，如单元测试模块，上下游系统的接口调用等等。

2020-01-23

www.xnsms.com 小鸟接码

为何我就想不到这样的设计呢

2020-01-20

www

「对扩展开放、对修改关闭」原则目的是为了需求变化时，对已有代码结构和测试用例影响降到最低，提高代码的扩展性和灵活性。但是要注意，在完成已有需求的情况下，不要过度设计预留扩展点，因为这也是有代价的，增加了工作量，并且牺牲了代码的可读性。

2020-01-14

小雨子

private ApplicationContext() { instance.initializeBeans(); }

你好，在构建 ApplicationContext 类是 你再构造方法中调用了 initializeBeans 方法 ，这样不会报空指针异常吗，构造方法的作用是为了完成对象的初始化工作把，但是构造方法还么执行完，此时回报空指针异常吗？

2020-01-14

小虫子

abstract class Component{

protected $_events = [];

public final function on($event,$handler){

if(!isset($this->_events[$event])){

$this->_events[$event] = [];

}

if(is_callable($handler)){

$this->_events[$event][] = $handler;

}

}

public final function trigger($event,$data){

if(isset($this->_events[$event])){

foreach ($this->_events[$event] as $handler){

call_user_func($handler,$data);

}

}

}

public function hasEventHandler($event){

return !empty($this->_events[$event]);

}

}

class Alert extends Component{

public function check(){

if($this->hasEventHandler('check')){

$this->trigger('check',$info);

}

}

}

class Run{

public function run()

{

$alert = new Alert();

$alert->on('check',function($info){

// 检查具体代码 1

});

$alert->on('check',function($info){

// 检查具体代码 2

});

}

}

2020-01-09

✨胡小东

对扩展开放、对修改关闭，可以很好的避免，当我们在加入一个新的需求点时候，去大面积改动之前的代码，这样可能会导致，原本功能正常的程序，因为你的改动，导致出现 bug；使得开发人员不敢随意去改动代码。

2020-01-08

京京 beaver

实践中简单的方法论就是：用抽象类和接口写出来核心调用关系，作为骨架。后续具体实现都是对骨架接口的实现，这样的扩展比较好。

核心调用关系，涵盖了业务最主要的逻辑，基本是很少变化的。

2020-01-07

CHS

对扩展开放，对修改关闭。在写代码的时候要时刻注意这些原则，修改经常比较麻烦，如果多个地方引用了这块，那修改起来就比较痛苦了。

2020-01-06

fly

扩展与修改，根据粒度不同，判定不同。其原则是以最小的代价，实现新功能的添加。方式是预留扩展点。

具体方法：识别代码中的可变部分与不可变部分。把可变部分的代码做封装、隔离，抽象化为不可变接口，提供给上层使用。变动时，通过扩展方式改动，对上层使用，不影响或影响较小。

2020-01-05

ちよくん

扩展是为了将来的变化留有余地，方便快速接入，降低成本，不影响原有的业务功能

2020-01-05

LYy

为什么要有「对扩展开放，对修改关闭」？

本质上讲，因为扩展的成本低于修改。

先看修改，一方面修改前需要对现有逻辑有比较准确而整体的理解 (学习成本)，有引入 bug 的风险 (额外运维成本)，另一方面也需要对配套的测试用例进行修改 (额外开发 / 维护成本)；

对照看扩展，只需要掌握扩展单元写法和理解修改点即可，引入 bug 的风险低 (核心逻辑复杂度被前期封装处理掉了)，同时已有的测试用例大概率不会被破坏。

引申一下，从本质上看，程序解决的是真实世界问题的自动化问题。问题被自动化的解决，代码便实现了 "业务" 上的正确，但仅考虑 "业务" 是不够的，绝大多数情况下我们还有「效率」和「成本」两方面的要求。从代码层面上讲，算法与数据结构能够解决程序运行的「效率」和「成本」问题，而迭代过程中开发和维护的「效率」和「成本」问题，则需要靠设计和持续重构来解决。

不得不吹下王争老师在极客时间上的两门课，高质量的覆盖了代码层面「业务」以外的所有问题。

2020-01-04

Jessica

就像老师在文章中说的，开放闭合原则对最核心，最复杂的逻辑的修改是封闭的，这样可以避免复杂的逻辑不会被修改，减少出错的概率。如果都是简单的逻辑，这个原则获得的收益是比较小的，反倒增加了代码的复杂性。

2020-01-04

迷羊

一、如何理解对扩展开放、对修改关闭？

添加一个新的功能，就是通过在已有代码基础删扩展代码（新增模块、类、方法、属性等），而非修改已有代码（新增模块、类、方法、属性等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，在粗粒度下，可能被认为修改；在细粒度下，可以又被认定为扩展。

二、如何做到对扩展开放、修改关闭？

1. 要时刻具备扩展意识、抽象意识、封装意识。这些潜意识可能比任何开发技巧都重要。

2. 写代码之前要多思考下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，这样在未来需求变更的时候就能以最小的代码改动来更加灵活的扩展。

3. 识别出代码可变部分和不可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，只要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

4. 很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的。23 种设计模式就是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。多态、依赖注入、基于接口而非实现编程、抽象意识说的都是同一种设计思路，也都是为了提高代码的扩展性。

三、如何在项目中灵活应用开闭原则

1. 关键是预留扩展点，如果开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，就要对业务有足够的了解，能够知道当下及未来可能要支持的业务需求；如果开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？」等问题。

2. 对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。

3. 有些情况下，代码的扩展性会跟可读性相冲突，我们需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。还是要看实际的应用场景来决定。

2020-01-04

Yangjing

对修改关闭，后面添加的代码不会影响以前的功能，保证了前面内容的正确性，添加功能变得更容易，更易于测试；对扩展开放，以此应对需求的变化，并是通过扩展的方式。

2020-01-03

Geek_f3a3d1

像是被大道洗礼了，融会贯通的感觉。

2020-01-02

薯片

每个 if 分支都抽成一个 handler 去处理，譬如我有 30 个 if 判断，那不就是 30 个 handler 了？handler 类爆炸了

作者回复：我是按照告警规则去定义 handler 的 不是一个 if 一个 handler 的 如果真有 30 个判断 这代码本身就有问题吧

2019-12-30

James

对扩展开放说的就是如何应对产品同事各种脑洞想法🐶

不过能预先扩展，那肯定能减少自己的工作量以及增加摸鱼时间咯。哈哈

2019-12-28

柳柳木

private ApplicationContext() { instance.initializeBeans(); }

这行有个 bug!

2019-12-26

海罗沃德

我們公司在擴展方面弱爆了，現在擴展都是通過重新寫一個方法，在原方法名字後面加個 V2，V3，最後弄得都不知道應該用 V 幾的方法才是合理的

2019-12-25

程序员人生

这篇应该是我所读过的把开闭原则，程序扩展性讲得最清楚的文章。

2019-12-25

double

老师，这些 Handler 如果都是 spring 管理的，该任何写比较好

作者回复：没大看懂你说的 你说的如何写指如何写什么呀

2019-12-24

花花大脸猫

为什么要对扩展开放，对修改关闭，其实就是为了应对后续接入需求的变化而带来的可扩展性以及灵活性，如果所有的需求变更都是要通过大量修改原先的业务代码功能而达到目标，说明原先的设计是不达标的，不仅影响新功能，对原先老的业务功能也会产生影响，进而会影响整个产品对外的稳定性，加大后续开发，测试，运维等相关流程的周期。

2019-12-23

helloworld

我的总结：

2. 认识『开闭原则』很重要，因为大多数的设计原则、设计方法和设计模式都是围绕这个目的展开的

3. 对于原则的运用一定要结合实际的场景来做分析，不能太教条化

4. 如果做的是业务系统，要对业务有很详细的了解采用运用这个开闭原则；如果做的系统是和业务无关的偏向于通通用的，底层的系统，要明确调用方是谁，今后的功能路线图是什么

2019-12-23

吴小智

争哥出品，必属精品。

2019-12-20

有爱有波哥

不是 java 出生还看不懂代码 😄

2019-12-19

蜗牛

为什么我们要「对扩展开放、对修改关闭」

目的可以归纳为一词：省成本，不管事可维护性好，还是扩张性好，最终都是服务于现实，服务于经济成本。（个人理解）

2019-12-18

shniu

OCP 指导我们在编码的时候多做些思考，完成某个功能是不难的，但要写出扩展性好，条理清晰，满足需求又不失扩展的代码是挺难的；OCP 给了一个写出这样代码的视角或者「标准」，应当在分析完需求后分出可变需求和不变需求，设计好代码结构，设计好单元测试，多做练习

2019-12-18

瓶子霸哥

我突然想到，如果有一天需求说某些通知可以截断别的通知该怎么改动呢？

比如优先检查 errorCount, 如果 errorCount 已经通知这个通知的话，就不检查 tps 是否合理了？

这样不就要改动 AlertHandler 的抽象方法 check (), 就违反开闭原则了吗

2019-12-18

Geek_a85af3

理论的学习还是需要结合实际的项目应用才能融会贯通，平时多有意识的去用上设计模式的思想，用的多了才能把握住这个分寸

2019-12-18

胖子

以最小化的代价实现需求变更。

2019-12-16

Emily

ApplicationContext 中的 initializeBeans 方法应该是 private 吧

2019-12-16

Geek_ecf7bb

一旦修改了原代码就可能带来 bug，更可怕的是需求频繁变化，带来的风险更高，而且每次直接改维护性很差，所以扩展的思路很重要。

2019-12-16

Varus

对扩展开放，对修改关闭，主要还是为了以后如果又新的业务需求能够以最小的代价，或者说最便捷的方式完后对功能的新增或者修改，本质上来说，扩展开放和修改关闭是一件未雨绸缪的事情。

2019-12-15

小小代码

请问老师，例中的 handler 可不可以写成责任链模式，当前 handler 不能处理了，再交给下一个 handler 处理

2019-12-15

小刀

抽象类与接口实现封闭，继承与实现 实现了扩展

开闭原则

2019-12-14

用 0 和 1 改变自己

对拓展开放是为了应对变化（新的需求），方便添加删除，对修改关闭是为了保证已有代码都稳定性（防止修改一个需求引出千万个 bug）, 最终还是为了系统更有弹性，更易维护

2019-12-14

javaadu

课堂作业：

写代码遵循开闭原则的目的是为了新增代码的时候尽量不要影响原来的核心逻辑，同时可以灵活应对需求的变化

2019-12-13

牛顿的烈焰激光剑

重构后变得更抽象并不可怕，但是文档或注释一定要跟上。

2019-12-13

半截木头

定义：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

解决的是什么问题：扩展性。

什么是开放和封闭

实际上，我们也没必要纠结某个代码改动是「修改」还是「扩展」，更没必要太纠结它是否违反「开闭原则」。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。

添加一个新功能，不可能任何模块、类、方法的代码都不「修改」，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。------- 不改主逻辑（流程），将变动封装于易改动处。

怎样做

在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些「潜意识」可能比任何开发技巧都重要。

在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

抽象出来的不变接口就是扩展点。

具体方法

多态

依赖注入

基于接口而非实现编程

设计模式

怎么识别扩展点

对业务熟悉

知道用户怎么用，可能要的功能点

不盲目预留扩展点

只预留目前需要的，代价小的

扩展和可读的平衡

2019-12-13

NYang

对扩展开放是为了更快更好的适应新的需求，对修改关闭是为了在新增需求时降低程序出错的风险

2019-12-13

TSXQG

使用单例模式创建 ApplicationContext 类的时候，instance 为 null。不能在构造器执行初始化语句。我把初始化放在获取实例的方法。

···java

public static ApplicationContext getInstance() {

if (instance.getAlert() == null) {

instance.initializeBeans();

}

return instance;

}

···

2019-12-13

随心而至

我实现过一个推荐接口：

1. 按照关注关系推荐

2. 按照关注的股票推荐

3. 按照用户画像推荐

当然还会有有其他很多，

但是将推荐接口抽取出来，各个实现类自行实现，这样以后添加新的推荐，去掉某个推荐，都不会太麻烦。

这应该是 OCP 的一个例子吧。

2019-12-12

程斌

对扩展开放是为了适应变化，对修改关闭是为了以往代码的稳定性。

2019-12-12

肥而不腻

为了尽量少点 ifelse

2019-12-12

王小念

总结的很精辟！但落实到具体应用还需要自身多多思考，多多实践。就像争哥最后说的「这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。」

2019-12-11

来碗绿豆汤

对扩展开放，对修改关闭。本质上就是我们在改变逻辑或者增加逻辑的时候，尽量不要对已有的功能或者单元测试带来影响。不能因为新的改动破坏了老的系统的使用。

2019-12-11

秋惊蛰

设计良好的计算机软件应该易于扩展，同时抗拒修改。也就是说，一个设计良好的计算机系统应该在不需要修改的前提下可以轻易被扩展.

应该很容易通过新增代码来修改系统行为，而不是只有修改原来的代码.

2019-12-11

相逢是缘

打卡

1、扩展开放、修改关闭 定义：添加一个新功能在原有的基础上扩展代码（新增模块、类、方法、属性），而非通过修改已有代码（修改模块、类、方法、属性）来完成；

2、一个修改在粗粒度下可以认为是「修改」，在细粒度下可以认为是「扩展」

3、多思考一下最近可能会有哪些扩展点，预留好；另外，识别出变换的部分，将变化的部分封装起来，提供一个抽象接口供上层系统调用；

4、提高扩展性常用的方法：多态、依赖注入、基于接口而非实现编程、入参封装成类，可以避免参数过多的修改等

2019-12-11

IOT..Yang

为什么「对扩展开放，对修改关闭」，正向考虑我看大家说的很多，我们也可以反向考虑，如果你增加一个新功能，会大量修改已有代码，那么就不能保证旧功能正确性 (或者说是稳定性)，这样测试同学还得重新测试，费时费力。而且这种牵一发而动全身的修改方式也不优雅，也是前辈通过血和泪经历得出的结论，哈哈！

2019-12-11

云起

感觉核心是要做到修改只增加代码，避免删掉部分代码，而影响原来的执行逻辑

2019-12-11

风行者

打卡，这个例子就是 if else 比较多的重构场景

2019-12-10

啦啦啦

老师，问个问题，我们现在要做个分佣金的功能，获得佣金的角色现在只有一种，就是购买人的上级，但是以后很可能会有其他角色获得分佣金，所以我就抽象了一个分佣金的 interface，这个 interface 就定义了一个方法，就是分佣的动作，但是每个角色的分佣应该都有一个计算佣金的方法，我现在要不要把这个计算分佣的方法也加到前面说的 interface 里面呢，谢谢老师

2019-12-10

DullBird

有一个问题想问一下。随着 handler 的扩展，需要的参数可能越来越多，

ApiStatInfo 类中也会存在各种乱七八糟的属性，实际过程中我就遇到一个权限规则校验的扩展点。权限规则可以随意扩展，但是每个规则需要的参数都不同，只能通过统一的 bean 传递，导致 bean 的参数越来越多，而且互相毫无关系。老师对于这个问题怎么看？

2019-12-10

DullBird

1. 应对需求变化，需求变化的时候可以迅速和方便的修改

(反问：那我改代码也可以应对需求变化啊)

2. 控制影响最小，可以保证不影响比如原来的测试用例，调用代码。如果改代码的话。就有可能影响。

3. 添加新代码的时候可以缩小关注范围，我只需要关注我需要新实现的接口和初始化等，不需要从上到下查看旧的代码逻辑

我对「对扩展开放、对修改关闭」这个原则印象最深的：就是在修改的时候，不影响其他已经有的流程。

我把代码分为对内和对外，

对系统内：比较简单的情况下，不会在一开始太注重「对扩展开放、对修改关闭」，因为对内系统，就算修改，就是通一个应用，一般编译和单元测试修改也比较方便。除非当某一个点涉及到多次修改，那么才考虑抽象扩展点

对系统外：比如暴露的网关，dubbo 接口，就比较慎重，因为这块的调用方并不是由我们控制，修改的成本比较高，所以一般会提前考虑扩展点。

2019-12-10

守拙

课堂讨论：为什么我们要「对扩展开放、对修改关闭」？

Answer:

我认为最重要的一点就是可维护性及维护成本.

若频繁的修改，会需要更多的测试，调试及时间成本.

若以扩展代替修改，则会减少很多不确定性，提高产品稳定性，同时也节约时间.

2019-12-10

Kang

打卡

2019-12-10

Rain

第一个例子中：我们先来分析一下改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。这部分的改动相对来说是最不合理的。我认为更好的做法是，去掉 ApiStatInfo 类，或者说将这个类跟 AlertHandler 解耦，每个 handler 的具体实现不应该是全部的 ApiStatInfo, 而应该是其中的一部分，各自关心自己的属性即可，不必强求把所有的相关属性都归到一个类中，这种做法适得其反，既不内聚又强制耦合。其他改动没问题，增加新的 handler 的实现类之后，当然可以做成配置型的添加或修改，关键在于开发的产品是什么性质的，如果是类似与 SDK 或 spring 这种不希望让调用者看到源代码的，一定要做成可配置的，否则做成代码中的方法完全可以。然后就是每个 handler 各自实现通知发送逻辑即可。

2019-12-10

BerryMew

今天对开闭选择的理解算是豁然开朗了，虽然灵活运用还需大量实践与经验积累，但记住这节课中的 handler 的 demo 并且能够灵活运用，我觉得就已经很好了。

2019-12-10

Middleware

直白点就是保证已有业务不受影响，容易扩展新业务

2019-12-10

L🚲🐱

对扩展开放是为了应对多变的需求，对修改关闭是为了避免被依赖的代码发生大的改动，花最小的代价去改动代码

2019-12-10

筱乐乐哦

1、对拓展开放是为了应对变化，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！

2、个人觉得公司我们组的代码就完全不符合开闭原则，通常是添加一个新的功能，每次测试上线还要回归其他的功能，根本无法做到说是老公能没有影响，leader 也一直说是要重构，但是我个人是没什么好的想法，希望能多在争哥这学习一下，我也很想写出像争前面开头写的那个 alert 的重构，反正我是重构不出来

2019-12-09

teddytyy

我的理解是加入新功能后对现有单元测试和调用处不用修改就算满足开闭原则，不知道对不对

2019-12-09

阿冰 777

如果不对修改关闭，随意的修改，那么修改多了以后很可能会出现 bug, 影响原来的功能，而且代码逻辑会越来越复杂，变得难以维护，所以一开始就设计好可拓展性，以后即使增加功能也很方便，也不会影响到原来的代码.

2019-12-09

Aliliin

总之别看见需求就开始写代码，能多想一步就多想一步，能把代码写活就别写死，让它再活几集。

2019-12-09

MindController

请问争哥「将可变部分封装起来，隔离变化」这句话是什么意思？

作者回复：你可以对比理解一下「基于接口而非实现编程」思想，封装可变的实现，暴露不变的接口。

2019-12-09

ismind

为什么我们要「对扩展开放、对修改关闭」？

1，提高代码的质量，也就是将代码写得更好，当然也会权衡可扩展性和可读性，比如今天这个 ALert 的例子，如果告警规则少，业务逻辑简单，不需要「扩展开放，修改关闭」，也是可以的，因为代码可读性更好；如果规则多，逻辑复制，就需要修改关闭了；

2，文章提到了，「（1）调用函数的地方会修改（2）单元测试也会修改」，所以「扩展开放，修改关闭」可以降低维护成本，减少人力财力。这也是很重要的原因吧。

自己刚刚接触设计模式，希望能逐渐理解并会运用。

2019-12-09

逍遥思

对扩展开放是因为需要应对需求的变化，做好了这一点，才能实现「对修改关闭」的结果，以保护已有代码的运行不受影响。

按照我的理解，「对修改关闭」是结果而不是我们需要去在代码层面做的，也不存在烂代码「对修改开放」

2019-12-09

考休

对旧版本的向上兼容，对未来需求的可扩展，对代码的可阅读性、可维护性

2019-12-09

moqifei

对扩展开放，对修改关闭，其根本是为了高内聚，低耦合。

2019-12-09

whistleman

打卡～，之前对开闭原则一直很困惑，很多对扩展开放的操作实际上还是对代码进行很多修改了呀。今天的课让我有一点感觉了，关于这点的小结：

第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。

第二点是，同样的代码改动，在粗代码粒度下，可能被认定为「修改」；在细代码粒度下，可能又被认定为「扩展」。

2019-12-09

潇潇雨歇

为什么我们要「对扩展开放、对修改关闭」？

修改代码可能会带来问题，尽量将修改代码量做到最小，可控，那么出现问题几率就越小。

一般程序都是要迭代的，要不断变化，应对不用的需求，扩展就是为了应对未来的需求变化。

保持代码的稳定性，能很好的应对未来的需求变化

2019-12-09

Jxin

为了平衡，业务稳定和加入新特性的矛盾。

1. 不可修改语意更明确，减少阅读代码的心智负担。

2. 通过扩展实现新特性，后期出问题好定位，有变更易拔插。

2019-12-09

Eden Ma

灵活应对需求变化，提高可测性稳定性.

2019-12-09

程序员小跃

做扩展开放，对修改关闭：实际上还是需要业务功能的驱动。

拿到一份需求，以及一份月度、季度甚至是年度规划的时候，可以先考虑下需要用到的功能，需要新写还是直接扩展需求点，需要设计多少接口，实现多少细节等等，有个大概的维度。

但是就如课程中说的，「唯一不变的只有变化本身」。所以，这就还涉及到过度设计的问题，才能更好的去做对扩展开放，对修改关闭的事情，我太难了，哈哈。

2019-12-09

划时代

这一篇「对扩展开放，对修改关闭」收获良多，是设计模式的精髓所在。我的实践过程，由最开始的大量运用到最后的敬而远之，疑惑很多。新手和高手之间的差距，原来就在一个运用的度上。「对扩展开放，对修改关闭」在于，最大的复用原有代码，最小的改动原有代码；高内聚，低耦合；更好的单元测试和保证代码质量。

2019-12-09

Geek

我们要时刻具备扩展意识、抽象意识、封装意识。希望通过学习培养自己这种意识，在今后看源码要多从设计入手，多分析，总结，希望早日养成这种感觉，使设计变的敏感。

2019-12-09

JOsuny

打卡

2019-12-09

jaryoung

简单一点就行，不要留下祖传代码，留着谁都不敢修改代码，避免牵一发而动全身。

2019-12-09

SMTCode

昨天在复习设计模式时，在打卡中刚刚提到了自己实际开发中用到的「开闭原则」，今天争哥就在这里系统的讲到了，感觉共鸣点颇多，特此总结一下：

看了争哥的讲述，发现自己那段协议代码能抽象的更好一些：可以通过定义一个更高层的类，通过调用这个类的公共的 check 来封装所有的 handler，这样就不需要我说的多个 else if 的更新了。

刚刚在想争哥文中举的「错误处理」那个例子感觉使用的和「外观模式」类似，但看了一下外观模式的场景，感觉自己套错了模式。

其实，我觉得开闭原则的核心就是：

1、提高代码的扩展性

2、降低扩展功能的成本

3、扩展功能时，不影响旧的功能。

有了开闭原则，在有新需求时，就可以大胆的扩展新功能，最坏的情况就是：新功能的 bug 只导致新功能不好用。所以对原有功能的冲击是「零」。同时，新接触项目的人，一旦掌握了这个设计框架，能很快的上手新功能的开发。间接提高了代码的可维护性。说真的，我之前那段代码的协议具体实现细节早就忘的一干二净了，但如果要做扩展，支持新的协议，开发的难度就是如何构造新的协议了。

正如争哥所言：很多设计模式是为了提高代码的扩展性，那么，如果对业务不熟悉，对需求不明确，如何能发现系统的共性？如何能找到系统中未来需要扩展的热点代码？其实如果一切都弄清楚了，可以说最终写代码就是纯力气活了。代码框架的抽象能力体现了一个程序员的综合实力。

加油吧！

外观模式是将一个「外部」需要调用多个子系统配合才能产生正确结果的问题，进行了封装和隐藏，通过一个更高层的类，隐藏系统内部的细节，避免了外部需要过多的了解系统内部的实现步骤。显然这里不是这种情况。

2019-12-09

阿卡牛

为什么要对「扩展开放，对修改关闭」？

我觉得一是提高新功能的开发效率，二是减少旧代码的维护成本

既开源又节流

2019-12-09

阿卡牛

1. 对于一直在提供服务的代码，改动是必然的，因为世界一直在变化。

2. 添加新功能时，肯定是需要修改已有代码的（新增模块、类、方法等），

3. 针对不同粒度中的代码改动，在粗代码粒度下，可能是」修改「，在细代码粒度下，又可以被认定为」扩展「

5. 划重点：设计初衷：没有破坏原有代码的正常运行，没有破坏原有的单元测试，这一个合格的代码改动

6. 尽量做到修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则

7. 此原则与可读性存在某种程序的冲突，需要针对具体的场景权衡。

2019-12-09

小畅

学习学习，对拓展开发对修改关闭，为了减少以后代码维护的难度，而且扩展写的代码会给自己一种「挖槽，老子这么这么聪明，早就想到了改动了」的快感

2019-12-09

啦啦啦

举个例子，我们的下单接口有很多验证，之前的代码有好多的 if else，像面条是的，这样代码可读性也不好，修改了某处就可能造成错误，如果把这些验证搞成开放关闭原则，在下单那个接口只要写个 foreach 循环各种验证，以后再增加或者删除验证也不需要在下单接口修改了，只需要在增加一个验证的实现类，把该实现类绑定到控制器里面，如果不需要某个验证，只需要在绑定那个地方删除掉就可以了，感觉这个原则比较优雅，改起来也方便快捷，当然如果验证条件不是很多就没必要用这个原则了，毕竟运用原则理解起来比直接写 ifelse 有难度，一定要适度，不要所有代码都套上各种设计模式和原则。

2019-12-09

wenxueliu

首先设计好函数，然后思考这个函数是否有扩展的需求，如果有，那么将这个类变为抽象类，用子类实现该函数。扩展性的理解前提是好的函数设计。

2019-12-09

冰糕不冰

对扩展开放是为了应对软件迭代过程中的变化；对修改关闭则是为了在增加这些变化的过程中防止软件出 bug，减少对源代码的改动！

2019-12-09

deepz

前排打卡～😃

2019-12-09

失火的夏天

对扩展开放，对修改关闭。只要还是为了代码的可维护性和稳定性，在旧代码上修改，所有相关的单元测试都要重写，功能全部要重测，如果调用地方多，兼容性还不一定可以全覆盖到。出现线上问题也排查麻烦，这个问题改了一块，有因为这一块影响到了别的功能。代码质量会越来越差，有一天变成祖传代码就没有人敢去动了。

基于扩展的，几乎不会影响到旧的实现，只是自身的变化，代码可维护性好，质量高。易于测试，各块各司其职。缺点就是可读性变差了。

2019-12-09

progyoung

对扩展开放以应对不断变化的需求，对修改关闭以应对减少未来添加新功能时对现有代码的改动。

2019-12-09

