# 0205 理论 5：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

王争 2019-12-16



2.0x



讲述：冯永吉 大小：9.76M 时长：10:39

关于 SOLID 原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面几节课中，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：

「依赖反转」这个概念指的是「谁跟谁」的「什么依赖」被反转了？「反转」两个字该如何理解？

我们还经常听到另外两个概念：「控制反转」和「依赖注入」。这两个概念跟「依赖反转」有什么区别和联系呢？它们说的是同一个事情吗？

如果你熟悉 Java 语言，那 Spring 框架中的 IOC 跟这些概念又有什么关系呢？

看了刚刚这些问题，你是不是有点懵？别担心，今天我会带你将这些问题彻底搞个清楚。之后再有人问你，你就能轻松应对。话不多说，现在就让我们带着这些问题，正式开始今天的学习吧！

控制反转（IOC）

在讲「依赖反转原则」之前，我们先讲一讲「控制反转」。控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。此处我要强调一下，如果你是 Java 工程师的话，暂时别把这个「IOC」跟 Spring 框架的 IOC 联系在一起。关于 Spring 的 IOC，我们待会儿还会讲到。

我们先通过一个例子来看一下，什么是控制反转。

public class UserServiceTest {

public static boolean doTest() {

// ...

}



public static void main (String [] args) {// 这部分逻辑可以放到框架中

if (doTest()) {

System.out.println("Test succeed.");

} else {

System.out.println("Test failed.");

}

}

}

在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：

public abstract class TestCase {

public void run() {

if (doTest()) {

System.out.println("Test succeed.");

} else {

System.out.println("Test failed.");

}

}



public abstract boolean doTest();

}

public class JunitApplication {

private static final List<TestCase> testCases = new ArrayList<>();



public static void register(TestCase testCase) {

testCases.add(testCase);

}



public static final void main(String[] args) {

for (TestCase case: testCases) {

case.run();

}

}

把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest () 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main () 函数了。具体的代码如下所示：

public class UserServiceTest extends TestCase {

@Override

public boolean doTest() {

// ...

}

}

// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用 register ()

JunitApplication.register(new UserServiceTest();

刚刚举的这个例子，就是典型的通过框架来实现「控制反转」的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。

这里的「控制」指的是对程序执行流程的控制，而「反转」指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员「反转」到了框架。

实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

依赖注入（DI）

接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是 Dependency Injection，缩写为 DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价 25 美元，实际上只值 5 美分的概念。也就是说，这个概念听起来很「高大上」，实际上，理解、应用起来非常简单。

那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new () 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：

// 非依赖注入实现方式

public class Notification {

private MessageSender messageSender;



public Notification() {

this.messageSender = new MessageSender (); // 此处有点像 hardcode

}



public void sendMessage(String cellphone, String message) {

//... 省略校验逻辑等...

this.messageSender.send(cellphone, message);

}

}

public class MessageSender {

public void send(String cellphone, String message) {

//....

}

}

// 使用 Notification

Notification notification = new Notification();

// 依赖注入的实现方式

public class Notification {

private MessageSender messageSender;



// 通过构造函数将 messageSender 传递进来

public Notification(MessageSender messageSender) {

this.messageSender = messageSender;

}



public void sendMessage(String cellphone, String message) {

//... 省略校验逻辑等...

this.messageSender.send(cellphone, message);

}

}

// 使用 Notification

MessageSender messageSender = new MessageSender();

Notification notification = new Notification(messageSender);

通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲「开闭原则」的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：

public class Notification {

private MessageSender messageSender;



public Notification(MessageSender messageSender) {

this.messageSender = messageSender;

}



public void sendMessage(String cellphone, String message) {

this.messageSender.send(cellphone, message);

}

}

public interface MessageSender {

void send(String cellphone, String message);

}

// 短信发送类

public class SmsSender implements MessageSender {

@Override

public void send(String cellphone, String message) {

//....

}

}

// 站内信发送类

public class InboxSender implements MessageSender {

@Override

public void send(String cellphone, String message) {

//....

}

}

// 使用 Notification

MessageSender messageSender = new SmsSender();

Notification notification = new Notification(messageSender);

实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，在后面的章节中，我们会讲到，它是编写可测试性代码最有效的手段。

依赖注入框架（DI Framework）

弄懂了什么是「依赖注入」，我们再来看一下，什么是「依赖注入框架」。我们还是借用刚刚的例子来解释。

在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：

public class Demo {

public static final void main(String args[]) {

MessageSender sender = new SmsSender (); // 创建对象

Notification notification = new Notification (sender);// 依赖注入

notification.sendMessage ("13918942177", "短信验证码：2346");

}

}

在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。

你可能已经猜到，这个框架就是「依赖注入框架」。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。

实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。

依赖反转原则（DIP）

前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。

为了追本溯源，我先给出这条原则最原汁原味的英文描述：

High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。

Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个「抽象」，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。

1. 控制反转

实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的「控制」指的是对程序执行流程的控制，而「反转」指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员「反转」给了框架。

2. 依赖注入

依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

3. 依赖注入框架

我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

4. 依赖反转原则

依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

课堂讨论

从 Notification 这个例子来看，「基于接口而非实现编程」跟「依赖注入」，看起来非常类似，那它俩有什么区别和联系呢？

欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview

© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (165)

小晏子

课后思考：

「基于接口而非实现编程」与「依赖注入」的联系是二者都是从外部传入依赖对象而不是在内部去 new 一个出来。

区别是「基于接口而非实现编程」强调的是「接口」，强调依赖的对象是接口，而不是具体的实现类；而「依赖注入」不强调这个，类或接口都可以，只要是从外部传入不是在内部 new 出来都可以称为依赖注入。

2019-12-16

下雨天

区别:

1. 依赖注入是一种具体编程技巧，关注的是对象创建和类之间关系，目的提高了代码的扩展性，我们可以灵活地替换依赖的类。

2. 基于接口而非实现编程是一种设计原则，关注抽象和实现，上下游调用稳定性，目的是降低耦合性，提高扩展性。

联系:

都是基于开闭原则思路，提高代码扩展性！

2019-12-16

Smallfly

依赖倒置原则概念是高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。

低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。

明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。

这样设计好处有两点：

1. 低层次模块更加通用，适用性更广

2. 高层次模块没有依赖低层次模块的具体实现，方便低层次模块的替换

思考题：

基于接口而非实现编程，是一种指导编码的思想。依赖注入是它的一种具体应用。

个人理解，仅供参考～

2019-12-16

辣么大

1⃣️控制反转是一种编程思想，把控制权交给第三方。依赖注入是实现控制反转最典型的方法。

2⃣️依赖注入（对象）的方式要采用「基于接口而非实现编程」的原则，说白了就是依赖倒转。

3⃣️低层的实现要符合里氏替换原则。子类的可替换性，使得父类模块或依赖于抽象的高层模块无需修改，实现程序的可扩展性。

2019-12-16

业余爱好者

原来的模式是一个 spring 开发的项目放在 Tomcat 中，控制权在 Tomcat 手中。现在微服务兴起，大家都用 springboot 开发。此时是 Tomcat 在 springboot 项目当中。控制权在 springboot 手中，虽然只是表面上。这便是控制反转。

这是一场控制权争夺之战。

2019-12-16

javaadu

课堂讨论：这两个概念没什么关系，讲的不是一个事。依赖注入讲的是一个对象如何获得它运行所依赖的对象，所谓依赖注入就是不需要自己去 new，让框架注入进来；基于接口而不是实现编程讲的是抽象思维的应用，利用编程，可以屏蔽掉底层具体实现改变导致上层改变的问题。

文中的那个例子，只是恰好同时使用了依赖注入这个编程技巧，同时也实践了基于接口而非实现编程这个原则。

2019-12-17

KIM

感觉比 head first 设计模式讲的清晰

2019-12-16

thomas

DIP 原则有点嘎然而止的感觉，缺少了一个具体的例子。

作者回复: tomcat 的例子不算啊

2019-12-16

Maurice

「相对于细节的多变性，抽象的东西要稳定的多」，个人认为吃透这句话就够了。

2020-01-13

Ken 张云忠

区别:

基于接口而非实现编程：是面向对象编程的一种方式。减少对外部的依赖，还可以提升代码的灵活性，扩展及修改时可以控制风险的传播，符合开闭原则.

依赖注入：是一种具体的编码技巧，属于编程规范的范畴。不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

联系:

两者结合在一起可以实现代码的灵活性，减少对外部的依赖，提升代码的可维护性 / 可扩展性.

课外感想:

非常喜欢王争老师这样有深度内涵的课程，概念理解深入透彻，宏观方向把握准确，跟着老师的课程更有信心去挑战阿里这样一流企业的工作。报告老师，我归队了.

2019-12-16

袁慎建

基于接口中的接口不是特指是编程语言中的接口，代表的是抽象。

1. 面向抽象编程，它强调的核心是抽象思维，解决的核心问题是程序的可扩展性。

2. 依赖注入，它强调的核心对象的管理，解决的核心问题释放程序员生产力，程序员不用花太多经历管理琐碎的对象创建和生命周期管理，将精力花在具有价值的业务上。

2020-02-04

帆大肚子

在我看来，「依赖注入」是「基于接口而非实现编程」的一个实践。

「基于接口而非实现编程」是一条设计原则，可以帮助我们诞生更多类似于「依赖注入」的实践

2019-12-16

pines

控制反转：控制指的是程序流程的控制，反转是指程序的流程的控制权由程序员转移到框架

依赖注入：上层类依赖底层类执行业务，以前往往将底层类作为上层类的成员变量，在上层类的内部声明底层类。注入就是底层类在外边声明，通过接口的方式注入到上层类中

依赖反转原则：我的理解是模块的解耦。上层模块依赖于低等模块，通过抽象出一套规则或者接口，使得上层业务依赖于抽象规则，低层业务实现规则。

我觉得基于接口编程与依赖反转原则比较类似，区别的话，依赖反转原则，依赖的不一定非得是接口，也许是一套规则，比如老师举的 tomcat 与 java 服务的例子

2019-12-16

MindController

深夜打卡

2019-12-16

木子 00

还是没有彻底搞懂！

只是懂了文字上.

2020-02-14

冰糕不冰

这个专栏确实讲解的非常细致！争哥确实是用心做专栏！以前对很多类似的概念都没理解透彻，通过这个专栏完全明白了！

2019-12-16

Paul Shan

控制反转的本质是分拆控制代码和具体执行代码，控制代码放在较高的层次上，也可能交给第三方类库，实现代码放在较低的层次上，通常是一个接口的实现。

依赖反转本质是分拆类中的 new 语句，因为 new 语句引入了对实现类构造函数的依赖，属于很强的依赖。分拆之后构造和实现放在另外一个类里（通常交给第三方类库），使用的地方引用接口。依赖反转可以拆分类的依赖关系，可以减少实现类的引用，用接口取代，实现接口和实现的分离。依赖反转和基于接口而非实现的原则类似，两者都倾向于依赖接口而非具体类。不同点在于，前者更关注类层次中的依赖关系以及对构造函数的依赖，尽量避免高层次的类依赖底层的实现，尽量避免对构造函数的依赖。后者，更强调类的使用的地方，尽量使用更抽象更宽泛的接口，而非更具体更细节的实现，使得信息隐藏和抽象。

控制反转和依赖反转都是有成本的，会破坏代码的内聚性和简洁性，需要权衡使用。

2019-12-16

大力水手 Jerry

从 Notification 这个例子来看，「基于接口而非实现编程」跟「依赖注入」，看起来非常类似，那它俩有什么区别和联系呢？

A：依赖注入是一种具体编码技巧，其主要目的有两点：

1. 将依赖关系建立的位置，从类的内部向上移动到类的入口（构造函数，或非构造函数的其他方法的参数），或者放到框架层面来支持（框架支持依赖关系的配置，对象创建，管理对象声明周期 —— 根据对象被引用的记数实现）。

2. 通过改变依赖关系建立的位置，将创建被依赖对象的任务移动到类的外部，从而简化了类的作者的负担：一方面是创建对象的负担，另一方面是管理依赖的负担

「基于接口而非实现编程「是一种编程原则，通过接口引入中间层，实现依赖关系的解耦。这是一个非常宽泛的原则，可以细化为多项原则，比如接口隔离原则（强调接口的功能单一特性，即通过分解支持功能的灵活细粒度扩展），里氏替换原则（强调接口的行为一致性，保证接口上层代码逻辑的简单性），开闭原则（强调接口的抽象特性，即通过多态特性实现功能的扩展）。

用一句话来概括：「基于接口而非实现编程」是让依赖变弱，而「依赖注入」是让依赖转移，两者相互补充，可以方便的结合起来使用。

2020-10-08

张三丰

这句话没理解，这句话强调的是对」流程」控制的反转 (比如使用模板方法设计模式)，但是依赖注入是怎么实现流程控制的反转的？从老师的例子上没有看出来，依赖注入只是把对象创建的权利交给了框架，而不是流程控制权利。

这里的「控制」指的是对程序执行流程的控制，而「反转」指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员「反转」到了框架。

2020-05-20

拉欧

基于接口而非实现编程偏向于类的实现方式，表示某个类要服从特定的契约

依赖注入偏向于类的管理方式，通过配置来管理类的加载

2020-01-27

iLeGeND

有收获

2019-12-16

PCMD

基于接口而非实现编程，和依赖注入，其实都可以算是依赖注入。

可以看文中的定义 "我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。" 其实都是一样，只不过在 基于接口而非实现编程 更多的体现了可扩展性，体现了开放原则。并且，最终注入的也是 该接口的实现，而非单一的接口

自我认为

2020-03-23

Heaven

文中同样提到了依赖注入是一种编程技巧，是指的是对于其他类的依赖不要在类中进行 new 来生成，而是通过构造方法，函数参数注入进来，但没有直接说明构造函数或者参数注入进来的是一个抽象的类或者接口，其也可以注入一个实现类。但是为了保证使用抽象的思想，一般会注入接口或者抽象类，提高代码可维护性，而基于接口而非实现编程，其本质也是为了使用抽象的思想，提高代码的可维护性

2020-02-24

至今未来

依赖注入是种编码技巧 来提高扩展性（巧妙的构建数据流）

基于接口而非实现编程 是利用编程语言提供的多态属性来提高扩展性（利用编程语言自身的结构属性 - 多态）

2019-12-30

|･ω･｀)

关于最后一个依赖反转能再举个简单的代码例子吗？Tomcat 的案例没懂˙Ⱉ˙ฅ

作者回复：你网上搜下 开关的例子 那个更简单

2019-12-18

阿顺

区别：依赖注入是不是使用的是多态的特性，基于接口而非实现编程使用了抽象的性，对吗

2019-12-17

堵车

老师，今天怎么没更新，我已经迫不及待了。隔壁那本 DDD 好多词汇难理解，我受了打击，过来找安慰。

作者回复：周一三五更新的

2019-12-17

阿冰 777

基于接口而非实现编程（依赖倒置原则）: 高层和低层组件都使用了一样的接口，然后让接口去控制整个逻辑，这样高层组件就不会依赖于具体的低层组件实现。简单来讲，就是大家都用接口，彼此不认识。

依赖注入：依赖注入就是一个组件内部依赖一个对象，但是他不自己造，等别人送上来。

他们俩的关系就是，在依赖倒置原则指导下的设计里，组件都没有内部创造依赖的对象，全是通过外部传入的，但是也不一定是注入，有可能只是个过客（传进去用完就扔），而且注入的时候，都是以接口的形式注入的，而依赖注入并不一定是接口。

2019-12-16

再见孙悟空

「基于接口而非实现编程」和「依赖注入」

联系 ：

都能实现注入功能，程序依赖的对象都能在外部事先创建而无需程序内部显示 new 。

区别：

「基于接口而非实现编程」可以看作是「依赖注入」的一种实现方式。除了构造方法注入外，依赖注入还包括 setter 方法注入。

2019-12-16

空知

Ioc 样例代码那里，抽象类 TestCase 的 doTest 方法 应该返回布鲁尔值，而不是 void

2019-12-16

沉淀的梦想

SOLID 的最后一个原则 D，我看好多书上说是 迪米特法则 啊，为什么文章里没有提呢？

作者回复: d 是 dip 不是 lod 的 lod 后面有讲到

2019-12-16

李小四

设计模式_19

# 作业

「基于接口而非实现编程」: 是一种设计原则。

「依赖注入」: 一种对上面原则的应用。

# 感想：

今天的内容，一定程度上是对前面基础原则的组合式实践。

在依赖反转原则里，

「具体实现依赖抽象」，是对「基于接口而非实现编程」的实践。

比如「高层模块不要依赖低层模块」，是「开闭原则」的实践。

像「单一职责」、「开闭原则」等的底层原则，我们都能理解它的「字面含义」，但真正掌握它要更多的实践和更丰富的信息量，这是我理解的，为什么还要继续讲基于基础原则的实践。

2019-12-16

墨雨

感觉依赖反转原则是不是可以叫「依赖抽象原则」？😂，从字面意思来看我觉得可以翻译成：高层模块和低层模块及实现细节都应依赖于抽象。

2019-12-16

progyoung

依赖注入标价 25 美元，实际上只值 5 美分。形象啊，不能被貌似高大上的概念给唬住了，产生畏难心理。

2019-12-16

秋天

区别就是依赖注入属于框架层面，接口编程属于实现层面

2019-12-16

LJK

课后讨论问题正是我的疑惑😦

2019-12-16

江南一笑

为什么都翻译成「依赖」，明明是「取决于」。高层模块不取决于底层模块。所有模块都取决于抽象。抽象不由细节（过程）决定，细节取决于抽象。这就好理解多了，不是吗？

2020-12-23

崔光伟

依赖注入是一种代码风格，关注类之间的关系或者创建对形象的方式；基于接口而非实现编程是一种设计原则，关注抽象和实现。

2020-12-10

•••

依赖注入重于方式，注入的可以是类也可以是接口。

基于接口重于抽象，降低耦合度。

2020-12-08

落尘

控制反转是一种原则，表示将程序执行的流程的控制从程序员反转到了框架。

依赖注入，表示将依赖类对象的创建，由类内部反转到了类外部？

依赖注入框架，表示将创建依赖对象，管理对象的生命周期，依赖注入等由程序员反转到了框架。

关于依赖注入我理解的没错吗？

2020-12-06

落尘

「基于接口而非实现编程」是一种原则，「依赖注入」是该原则的一种实践方式。我感觉「依赖注入」就是策略模式

2020-12-06

Kingram

区别：

从 Notification 这个例子来看，依赖注入和基于接口而非实现编程不是一个东西，Notification 依赖的 MessageSender 是一个接口还是一个类都没关系，只要不是本类中 new 出来的就算是依赖注入，而基于接口而非实现编程强调的是接口，上层模块不依赖下层的不稳定的实现，而是依赖更稳定的接口，在 Notification 这个例子中，MessageSender 就必须是一个接口。

联系：

两者都是为了降低程序的耦合性、提高代码的可读性、可扩展性、可维护性。结合使用效果更佳～

2020-12-01

JRich

控制反转定义里是程序执行流程的控制权反转，而依赖注入讲的是对象的创建由外部创建好通过构造方法或 setter 方法注入进来，感觉两个讲的不是一个意思，虽然依赖注入也有控制反转的意思，但是对象的创建和获取的权利被反转，更确切的理解应该是 2 个场景吧。

作者回复: ������

2020-11-22

JRich

基于接口而非实现编程使用了依赖注入编程技巧。因为基于接口而非实现编程使用了面向对象的多态特性来提高代码扩展性，必然不可能在类内部创建对象，只能从外部注入。区别就是依赖注入不仅可以使用接口，还可以使用类。

作者回复: ������

2020-11-20

万历十五年

IOC，个人理解主要是「控制权由内部转移到了外部」。这个控制权不仅指流程的控制权由内部转向外部，也包含内部对象生命周期管理的反转。

DI，依赖注入是实现 IOC 的一种常见方法，简单易用。

DIP，依赖反转原则是解藕的一种方法。原来是调用者依赖被调用者；现在在二者中间加了一层抽象，这层抽象原则成为了二者的依赖，有点面向接口编程的味道。

2020-11-12

紫日

「基于接口而非实现编程」，是一种基于抽象进行编程，把功能和实现分开，「依赖注入」是依赖的对象外注入，而不是内部创建，这增加代码可扩展性，可以让下层依赖上层让设计者更加灵活。二者都是编程技巧，增加代码扩展性。

2020-10-25

大力

依赖注入强调的是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式注入类来使用；它可以基于接口编程，也可以基于实现编程；当注入至类中的对象是接口对象的时候，那就是基于接口编程。

2020-09-12

Kang

dip 的原则用起来着实简单，理解起来需要一些基础，一定需要理解为什么不能都去 new 对象去做，这样才能感受到他的好处

2020-09-11

火影。海诺

控制反转说的是一种原则，一种理念，而依赖注入算这种原则的一个实现方式…… 为的是减低模块之间的耦合性…… 最终是为了代码的可扩展服务的。

2020-09-11

JerryZhu

基于接口而非实现和依赖注入一样是一种原则，一种规范，都是帮助代码易扩展，易维护的有效手段

不同点在于基于接口而非实现 主要关注的是接口本身，也包含了需要抽象的方法，一种约定和协议

依赖注入更多的是关注流程和具体类的管理，解决 hardcode 对一个类的过度侵入

2020-09-05

宇天飞

1、联系：相似地方，基于接口编程，

2、区别：依赖注入，可以很方便扩展为不同的接口类；

2020-09-03

郑大钱

依赖注入是编写可测试性代码最有效的手段。

最近尝试写单元测试，发现在需要 mock 数据的时候无从下手，现在发现是代码本身的可测试性差。

控制反转，指的是程序的执行流程从程序员反转到框架。

依赖反转，指的是上层模块对下层模块的依赖反转到对抽象接口的依赖。

依赖注入，指的是依赖外部传入对象，而不是内部创建对象。

2020-09-02

好名字

我理解的依赖反转是，高层模块 A 依赖低层模块 B，可以抽象出一个 C，让 B 依赖 C，A 依赖 C。

2020-08-27

辉

需求决定实现挺正常的啊，一直困惑为何要说成依赖反转。

2020-08-26

Magic

依赖注入实际上可以注入任何实例，但是想起到增强扩展性的目的，注入类型就必须是抽象的接口类。简单说依赖注入是基于接口编程的一种具体应用场景

2020-08-13

Geek_31594d

控制反转 - 本因开发自己控制的流程交给框架处理，开发只需要实现具体功能

依赖注入 - 需要某个对象或者资源的时候，本来是自己创建，现在依然于调用时外部传递

依赖注入框架 - 调用对象的创建 生命周期 依赖注入等于框架去处理

依赖反转原则 - 暂时不是很明确 高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象（需要加深印象）

2020-08-12

Java 垒墙工程师

区别：

基于接口编程：实现类获得解耦，方便后续替换和修改，调用方不感知

依赖注入：强调的是依赖对象外部输入，而非硬编码到内部

二者联系：

都对代码扩展非常友好

2020-07-08

大强

基于接口而非实战编程，主要指导我们编程要有抽象思维，用抽象类或者接口实现多态特性。依赖注入主要解决的是对象之间的依赖关系，所有依赖对象通过构造函数或者 set 方法传递依赖对象。二者的联系就是他们都可以实现拓展性，满足 ocp 原则

2020-06-29

大方方

关于课后题 我的理解是都是用到了接口但是侧重理念不一样，基于接口编程是类之间解耦理念，有些依赖反转原则，即调用底层不基于实现。而依赖注入也是是利用接口但是分离代码职责 避免直接内部创建依赖对象 更有单一指责性在里面，更方便测试

2020-06-27

大方方

控制反转 依赖注入 和依赖反转，这三个概念的区别是我目前看到的所有文章教程里说的最清晰明了的，谢谢老师。

2020-06-27

见南山

依赖注入和面象接口而非实现编程，如 A 调用 B 的方法，依赖注入值得是 B，而面象接口指的是 A。针对的对象不同。

依赖倒置原则指的是高层不依赖底层，抽象不依赖具体。其实是面向接口的具体实现了。要求底层足够的抽象扩展，本来是底层给高层提供服务，却要求底层。所以是依赖倒置了

2020-06-24

maybe a miracle

依赖注入是一种具体的编程技巧，通过外部创建好类对象然后通过构造函数或属性等方式传入给调用者，这样可随时进行替换。

2020-06-23

maybe a miracle

基于接口而非实现编程是设计原则，指导类的设计，依赖接口而不直接依赖实现类，具备更高的扩展性。而依赖注入是一种具体的编程技巧，通过外部创建好对象（）

2020-06-23

港岛妹夫

想知道争哥的英文原文都是从哪里读来的。如果是书的话，可以推荐一些嘛～

作者回复：都是实践中来的，自己动脑子思考的比较多，书的话也就是看看而已，你可以看我写的这篇文章：

https://mp.weixin.qq.com/s/uKkQMIWTtAmvsEYZCxvZeg

2020-06-13

奥利奥，晴天。

依赖注入的方式 特别好，结合开闭原则，很容易写出可测试的代码，以前写 go 语言，写个单元测试，引入数据库配置，引入配置文件，非常难测试，后来学了依赖注入这个东西，感觉代码测试，清爽干净简单了。。。

2020-06-04

微末凡尘

区别：

1、依赖注入是一种具体的编程技巧，通过参数传递类而不是在内部 new 创建对象，降低代码的耦合性，提高可扩展性

2、面向接口编程可以说是一种编程思想或者设计原则，关注抽象和实现，上下游调用稳定性

联系：

二者都可以提高代码的可扩展性，基于开闭的原则

2020-06-03

张三丰

模板设计模式，依赖注入都可以实现控制反转。两者有个共同点，就是均为开发者保留扩展点，前者的扩展点是动作，后者的扩展点是整个对象 (每个对象拥有各自个性化的动作)。

2020-05-21

anders

「基于接口而非实现编程」跟「依赖注入」，看起来非常类似，那它俩有什么区别和联系呢？

-----

- 首先基于接口而非实现编程，相同点：因为两者都依赖接口来实现被调用者的抽象，减少类之间的耦合，提供低成本的替换。

- 不同：基于接口而非实现编程，也可以理解为最基础的一种编码实践之一，设计模式有相当一部分是基于这种实践总结的。依赖注入，甚至说是依赖反转，是前者的扩展。

- 可以这么理解，前者是基石之一，后面是对前者的补充和发展

2020-05-18

scmath

依赖倒置、控制反转、依赖注入是三个不同的概念。

依赖倒置：把 service 层的接口挪到 controller 层，controller 层不再依赖 service 的任何代码，service 层实现 controller 中定义的接口，这样就实现了高层代码不知道低层代码，低层实现高层定义的接口，是依赖倒置。跟是否使用注入框架没有关系，重点是层之间的依赖关系。

控制反转：是框架的设计思路，框架是完成一整套业务流程逻辑的，高层调用低层时只需要实现框架预留的扩展点，然后传入框架，改变框架的行为，看起来是框架在调用高层的代码，we call you，you do not call me！

业务组装：扩展点要是预留的接口，可以编写多个实现；扩展点要是基类，可以编写多个泛化；然后业务组装层挑选实现和泛化，然后实例化对象，传入高层代码。

整个程序分高层业务逻辑，高层扩展规范 (基类、接口)，高层扩展规范的实现，业务组装。注入就是业务组装层的工作，实例化泛化或实现，然后在实例化高层代码时传入，是 UML 说的一种依赖构造关系，用了依赖注入框架，也不一定就是依赖倒置，也不一定控制反转，现在常规写法接口和实现在同一层，controller 层依赖了 service 层的接口，依赖没有倒置。这种写法违反了依赖倒置的规范，不知为啥大部分代码都是这种写法。spring 的 IOC 框架声称是依赖注入控制反转容器，IOC 只是把实现代码装配，是否控制反转了？是否依赖倒置了？IOC 没有能力控制。

2020-05-14

scmath

依赖注入没有实现控制反转！！！

依赖注入只是实现了可以替换依赖。控制流程没有由高层挪到低层！service 相对 controller 是低层，xxxController 依赖 xxxService 的抽象接口，控制没有反转，控制还是在高层，只是可以方便的替换依赖类 xxxService。

xxxService 接口看作预留扩展点，xxxController 作为低层，依赖注入框架看作高层可以，但是依赖注入框架作为高层不合适，因为程序员不关心依赖框架具体实现细节。

2020-05-13

scmath

控制反转是编程思想，用于框架设计，本来应该高层调用低层并控制程序流程，反转为低层调用高层的实现，并控制程序流程。

依赖反转也是编程思想，控制反转的构造入参可以是 class、interface、abstract，依赖反转是高层和低层都依赖 interface 或 abstract，不要依赖 class，也是低层调用高层的一种思想。高层写代码依赖的是调用的是低层的 interface 或 abstract，不依赖 class。

实现控制反转的方法有模板模式、依赖注入、里式替换。

2020-05-13

刘同青

1、依赖翻转：

一般来说，先有提供者提供功能，调用者如果想使用，那么就要适配提供者的 api。

上层会调用下层，似乎也是上层需要适配被下层的 api。

但是依赖倒置原则是让下层来主动适配上层，否者这个下层实现就是不合格的！上层并不依赖下层。

那么下层如何来适配上层呢？

上层模块定义一个抽象标准，并直接依赖这个抽象标准，下层主动实现这个标准。

上层并不关心是不是有下层实现，也不关心下层实现的对不对，即上层不依赖下层实现。

下层需要实现上层定义的抽象标准，所以这时下层模块依赖了上层模块。

文中 tomcat 的例子十分形象，tomcat 作为上层的容器，规定下层实现必须实现 servlet 规范，tomcat 版本不依赖任何下层实现，一样跑的转，但是下层实现如果不遵守规范，那上层模块就不鸟你了。

2020-05-07

三木子

基于接口而非实现编程 类似于设计原则，依赖注入类似于具体实现。

基于接口而非实现编程 类似于接口，依赖注入类似于继承了该接口。

2020-05-06

KID

依赖注入是一种代码编写技巧，基于接口编程而非实现编程是一种设计原则，前者关注类和对象的关系，后者关注抽象和实现；目的都是为了提高可扩展性，降低耦合

2020-04-28

林子 er

基于接口而非实现编程是设计原则，依赖注入更多的是说实现方式，一般用后者实现前者

2020-04-17

拉普达

基于接口而非实现的编程，其中的接口就是依赖反转原则中所谓的 "抽象"。接口不依赖具体的实现类和实现类的调用，但实现类和实现类的调用依赖接口。因此基于接口而非实现的编程，就是依赖反转原则的一个具体应用。

2020-04-06

KK

个人感觉依赖反转这个名字起得不好，为什么呢？因为这个通过看这个名字，和具体的描述似乎很难联系起来，或者名字或者描述之间没有联系。

2020-04-05

Geek_49de4e

1. 依赖注入改变了对象初始化的位置，但并未改变对象之间的依赖关系。

2. 面向抽象编程改变对象之间对具体实现的依赖。

结合上面两点，在模版和 IOC 框架中通过面向抽象编程来定义扩展点，并通过依赖注入来生产注对象，是遵循了依赖倒置原则的良好实践。

2020-04-02

墨鱼

控制反转：控制是指对流程的控制，反转是指原本是程序员控制流程，反转成框架控制流程。

依赖反转：高层代码不依赖于低层代码，他们共同依赖于一个抽象。

依赖注入：不通过 new 的方式在类内部创建类的对象。而是在外面创建好类的对象，然后通过函数参数，构造函数方式传入

2020-03-31

面向百度编程

依赖注入只是将需要的对象传递进去就可以了，专注于注入，而基于接口而非实现编程基于多 tai, 基于扩展性，专注于面对未来的变化，所以开发人员不仅要面对功能实现，更应该面对未来的变化

2020-03-31

ryan007

有理论有实践，还是很不错的

2020-03-29

Six

控制反转是 这里的控制是对程序的控制，而反转是由程序员控制的逻辑交给框架来抽象控制，讲的是一种设计思想。

依赖注入是一个类依赖一个类，而将这个类通过外部传入。一般被依赖的设计成接口或者抽象类比较容易扩展，讲的是一种编程技巧

依赖倒置原则 则说的是调用方依赖实现方，通常通过接口来规范。调用方不知道具体的实现，而实现不知道具体的调用方。对于实现方在设计的时候，需要考虑调用方的使用场景，多个调用方的通用性。

2020-03-29

鸳鸯戏水蝶

这个是真的抽象，好像也没讲和 Spring IOC 得差别吧。

2020-03-28

jaryoung

记录今天学习的内容，控制反转，依赖注入，依赖反正。

2020-03-28

忆水寒

基于接口编程强调的是将公共功能抽出来。

而依赖注入更强调不要在内部 new 对象，这样绑定死了调用对象。

2020-03-27

未来小娃

【设计模式笔记 20】20200325

控制反转：将程序的流程放在框架层实现，反转的是程序的流程控制，一句话：流程控制从自己控制变成框架控制。好处是专注实现逻辑即可，流程由框架管理

依赖注入：依赖的对象通过构造函数和 serrer 方法传递进来，而不是通过 new 的方式创建。好处是可以减少对象的创建，从而提高程序运行的性能，虚拟机会对不再使用得对象进行垃圾回收，导致应用频繁 gc。

依赖注入框架：具备创建对象、对象的生命周期管理、依赖注入的功能框架。

为什么要使用控制反转框架：不需要关心对象的依赖关系，对象之间的关系可以交给容器完成，减少代码的耦合度

最后再回答下问题：首先「基于接口而不是实现编程」讲的是程序的交互问题，即如何实现写代码，依赖注入是一种关系程序内部对象的技巧，两个维度的问题

2020-03-25

黑客时间

基于接口编程能够使依赖注入的兼容性更强，在实际操作中，我只需要确定所依赖的类的类型，但是具体是哪个实现类，我不关心，根据实际情况进行注入就可以了

2020-03-25

然

依赖反转：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

2020-03-25

白杨

控制反转这个定义挺反人类的，今天终于听老师讲明白了，不是由编程人员控制逻辑走向，而是由这样一种设计出的框架来控制走向

2020-03-24

秋风画扇

「控制翻转」是心法是指导原则，「依赖注入」是剑谱是手段，「依赖注入框架」则是倚天剑是工具。

2020-03-22

秋风画扇

讲的是俩个层面的事情。「基于接口而非实现编程」讲的是编码原则，如何从逻辑上组织代码；「依赖注入」讲的是实现方式，怎么样把相关代码组合起来。

2020-03-22

张三

tomcat 那个例子很好

2020-03-19

huangzhimim

// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用 register () JunitApplication.register (new UserServiceTest ();

真心求教这里可以用什么配置来实现呢

2020-02-19

杨松

老师你好，请教下开篇的第一个问题「「依赖反转」这个概念指的是「谁跟谁」的「什么依赖」被反转了？「反转」两个字该如何理解？」能给个总结性的答案吗？这个问题总感觉有点晕晕的，还是不能理解的特别透彻。

2020-02-16

嘿泥鳅

区别：

1. 基于接口而非实现编程强调的是隔离变化应对未来需求，并且作为一种面向对象的基本原则

2. 依赖注入则是实现 IOC 的基本手段

联系：两者都以提高代码扩展性作为目标和意义，并且 DI 可以借助基于接口而非实现编程来增强扩展性和灵活性，例如 Spring 中的接口注入。

2020-02-12

涉蓝

依赖注入是为了实现控制反转的一种编程方法，而要实现依赖注入的前提就是可能变化的依赖是根据接口抽象出来的，所以 基于接口而非实现编程 是实现 依赖注入 的 基础

2020-02-11

Nestor.liu 刘明丰

控制反转和依赖注入其实是描述事物的角度不一样，依赖注入是上帝视角来看的，程序本身看成一个黑盒，所有的依赖都通过外部填充进去；控制反转是程序本身作为第一视角的，本来程序需要依赖关系都是靠自己 new 出来的，都是自己控制的，反转之后就不一样了，依赖关系不再靠自己维护了，而是交给了外部或者说是第三方来维护，控制权发生了变化。

2020-02-04

流星

基于接口而非实现是指通过接口的方式而不用考虑内部实现，依赖注入更强调的是依赖

2020-01-30

h1z3y3

可以看一下 Uncle Bob 的 Clean Architecture，

真正的实现，整个架构完全分层，层与层之间使用都是 DI

2020-01-30

移动一下

联系是两者都用了抽象，都是为了扩展，区别是依赖注入强调了对象生成的地方来源于外部

2020-01-25

www

基于接口而非实现编程是一种编程思想，强调的是接口可以应对需求的变更，有更高的扩展性

依赖注入是一种编程技巧，可以实现控制反转的编程思想，解放程序员对复杂的类成员的初始化，让程序员专心于业务代码上

2020-01-16

岁月如歌

首先 」基于接口而非实现编程」便于「依赖注入」中动态替换，灵活的进行拓展。类似在 spring 框架中有接口和实现类，而只需要依赖接口即可，可以动态调整实现。

其次 」基于接口而非实现编程」侧重类的设计，是实现代码灵活性、提升可拓展的方式。而「依赖注入」是一种具体的编码技巧，可将具体的业务逻辑 和 通用重复的代码切分出来，简化代码开发的难度等。

2020-01-13

东流

依赖反转强调类中对象在外部初始化，传给类时最好基于接口而非实现，但不强求；而基于接口而非实现指的是类给类通信时的一种设计原则

2020-01-11

CHS

Notification 基于接口而非实现编程更加灵活，调用方只需要调用接口的相关方法就可以了，不用管实现方式怎么实现的。

2020-01-09

Paul Shan

基于接口而非实现和控制反转挺相似，前者强调依赖的对象，尽量依赖接口，后者强调依赖的方向，高层模块有时候需要另外一个低层模块的功能，直接引用会让稳定的高层模块依赖不稳定的低层模块，这时候有必要在高层模块中衍生出一个接口，这个接口是和高层一样稳定的，然后让低层的模块实现这个接口，运行时期注入低层的模块，来让高层的模块调用低层的功能，这样就通过了两者都依赖接口来避免了高层模块直接依赖低层的模块。

2020-01-08

开心小毛

底层模块依赖上层模块的抽象是否提倡？

作者回复：上层模块的抽象你是指什么呢？

2020-01-05

程晓擘

高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。不太明白，为什么叫依赖倒置呀？倒置啥呢？ 我可能会取名，依赖抽象原则，哈哈。

作者回复：倒置就是反转，我在文章中不是解释了为啥叫反转吗😂

2020-01-05

Yangjing

联系在这两者都是通过多态特性来实现的；区别在于依赖接口编程侧重点在类应该依赖接口（或抽象类），依赖注入侧重于通过注入的方式实例化类依赖的对象。

2020-01-04

青子

JunitApplication.register(new UserServiceTest();

在控制反转中执行这句话会执行该类中的 final 修饰的 main 方法吗

作者回复：代码稍微有点问题，我改下，抱歉！

2020-01-04

七月有风

第一次接触依赖注入是在 Angular.Js 1.X 版本中

2019-12-31

无所从来

高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

2019-12-29

蜗牛

「基于接口而非实现编程」跟「依赖注入」。

强调点不同：「基于接口而非实现编程」强调的是接口（抽象概念的接口）更加着重于在思想层面，「依赖注入」强调的是一种具体的方式方法。

2019-12-27

undefined

课后思考题：

依赖注入拆开来：「依赖」要基于接口约定，而「注入」是指模块间的关联方式，而后者是「基于接口而非实现编程」所没有定义的。

2019-12-26

奔跑的小孩

依赖倒置原则 说的有些不理解，这里讲的感觉好像是一种思路，高层次到低层次，具体到抽象

2019-12-26

Grecss

抽象不依赖具体实现细节： 工厂方法，框架。

具体实现细节依赖抽象（所谓反转的地方）：根据高层次需要的进行设计

感谢 Smallfly 朋友的留言，让我有种顿悟的感觉

2019-12-25

梦倚栏杆

尝试解读一下控制翻转，依赖注入和依赖注入框架之间的关系。

如果控制翻转我们定义为一件事情的结果，比如：我要有知识.

依赖注入：是通向这件事情的一个手段，比如：听老师讲课

依赖注入框架：运用如上手段，系统化，完整化的实现这个结果。比如：学校教育体系的存在，我们学知识，上学即可

2019-12-24

番茄炒西红柿

基于接口编程强调的是一种设计原则，强调抽象化。而依赖注入则是实现，强调类与类（接口）间的依赖关系，用聚合而非组合关系

2019-12-23

aof

代码里好像有两个小问题：

1. 控制反转的代码中，doTest () 的返回值误写成了 void，应该是 Boolean 吧？

2. 还是控制反转的代码中，for 循环中的变量命名 case 是 Java 中的关键字，编译不通过的

2019-12-21

jason

「依赖注入」指依赖时要依赖一个抽象的接口，但注入时要注入一个具体实现。所以实现依赖注入要求我们要基于接口而非实现编程。

2019-12-21

阿卡牛

Spring 的 IoC 容器除了主要通过依赖注入实现控制反转外，应该还有其它功能

2019-12-20

feifei

这一章我怎么就听不太懂了呢😂😂

2019-12-19

皮卡皮卡

控制反转中的第二段改造代码 public abstract void doTest (); 应该是 public abstract boolean doTest ();

同时第三段中的不需要程序员显示调用 register ()，应该是显式调用 doTest () 吧

2019-12-19

苗

这一篇文章确实是我读过的把这四个概念讲的最清楚明白的。

2019-12-19

相逢是缘

打卡

1、控制反转（Inversion Of Control）：「控制」指对程序流程的控制，「反转」指没有使用框架之前，程序员控制整个程序的执行，使用框架之后，整个程序的执行由框架来控制。程序执行的流程的控制权从程序员「反转」到了框架

2、依赖注入（ Dependency Injection）：不通过 new 的方式在类内部创建依赖对象，而是通过构造函数或是函数参数等方式传递对象给类使用。这样提供高了扩展性，可以方便的替换依赖的类，符合「开闭原则」。根据基于接口而非实现编程原则，注入的可以是接口的实现类，更为方便灵活和易扩展

3、依赖注入框架（DI Framework）：通过框架提供的扩展点，简单配置所需创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的声明周期、依赖注入等操作；

4、依赖反转原则（Dependency Inversion Principle）：高层模块不依赖于底层模块，高层模块和底层模块都依赖与抽象，抽象不依赖于具体的实现细节，具体的实现细节依赖与抽象。（在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计）

2019-12-19

曾志伟

基于接口而非实现编程，其中接口指的是协议或者约定，调用者只需根据协议进行编程即可，无需依赖接口的具体实现。依赖注入是指类的成员不通过自己内部生成，而是通过类的调用者在类外部生成，再传入类中。前者是为了接口实现类的变动不影响接口调用类，后者可以解耦成员拥有类和成员实现逻辑。前者是后者的一种实现方式。

2019-12-19

平风造雨

依赖注入描述的是一种编码技巧 而编程框架在抽象的层面让大家可以方便的使用这种技巧 这种技巧的好处是依赖的组织管理更简单 因为都交给框架做了 而大家只要写自己的业务就好 而面向接口编程是设计原则 为了更好的解耦和扩展和插拔 用依赖注入的技巧配合面向接口编程 能协调实现更好的代码架构

2019-12-18

落叶飞逝的恋

区别：依赖注入是一种编程技巧，即使注入的类未采用面向接口编程，也可以。

联系：可以结合面向接口编程的原则，来进行依赖注入，这样的代码的就更加易于扩展。

2019-12-18

不似旧日

控制反转：上层不依赖下层

依赖注入：通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

2019-12-18

小伟

「基于接口而非实现编程」是基础，在此基础上将依赖获取方式抽象，进而演进出各种控制反转和框架。「依赖注入」仅是获取依赖的一种具体方式。这两个一个是战略层面的，一个是战术层面的。落地到代码时，都是依靠 Java 接口 + 里式替换来实现的，故看上去一样。

2019-12-18

知行合一

区别是依赖注入是指生成所依赖对象的方式，是自己生成还是别人注入，基于接口而非实现编程关注的不是对象的生成，而是使用对象的地方，是用接口还是具体的实现来编程，以以后扩展比较方便，复合开闭原则。

2019-12-18

传说中的成大大

JunitApplication.register (new UserServiceTest (); 这段代码少了个括号吧？

2019-12-17

草原上的奔跑

基于接口而非实现编程，那我基于接口了，我的实现怎么办呢，这个时候，依赖注入来了，给你注入一个你需要的实现。依赖注入可以灵活配置，极大的增强了程序的灵活性，可扩展性。只要接口设计好，通过依赖注入，实现随便换！

2019-12-17

нáпの゛

课后题理解「基于接口而非实现编程」是一种指导思想，依赖注入是在这个思想指导下的具体实现，注入相当于基于接口，在类里 new 相当于实现编程。

还需要老师不定期加餐来个同一解答。

2019-12-17

饭

「基于接口而非实现编程」：是一种编程指导思想

「依赖注入」：是具体的编程技巧，它在实现过程中，往往又会结合「基于接口而非实现编程」，实现创建类与具体被依赖类的解藕

2019-12-17

小刀

基于接口而非编程 强调 接口 概念

依赖注入 类接口都可以

2019-12-16

tt

依赖注入可以基于接口而非实现编程，也可以基于实现编程，讲得是类或模块之间的依赖如何实现。

而基于接口编程主要是从类或模块自身的扩展性出发的。

2019-12-16

歌顿

前端 er 表示 Tomcat，Sevlet 规范 是什么鬼。。

作者能不能尽量写代码例子而不是举这些框架，如果是希望我们还去学习框架那肯定是不可能了

2019-12-16

马哲富

控制指的是程序的执行逻辑；反转指的是不由程序员来控制程序执行，而是由框架来控制；依赖注入指的是不在一个类内部直接 new 一个对象，而是在外部创建好了直接传进来使用（有点类似于组合关系）

2019-12-16

ismind

个人的理解：

一，首先，来简单梳理着两个语句的含义：

1）基于接口而非实现编程，可以看到，在一个类 ClazzA 的方法中，

如果需要将某一个类 ClazzB 作为参数，那么建议将类 ClazzB 替换为接口。

2）依赖注入，在一个类 ClazzA 中，需要用到某一个类 ClazzB，

不需要在 ClazzA 里直接 new ClazzB，而是在 ClazzA 外创建好，通过构造函数或者函数参数传递给 ClazzA。

二，比较区别与联系

1，区别

1）基于接口而非实现编程是一种原则，而依赖注入是一种具体的编码技巧。

2）依赖注入可以有依赖注入框架，而基于接口而非实现编程则没有基于接口而非实现编程框架。

2，联系

1）二者都可以通过接口来实现类的传递，二者有些类似。

2）二者都是将某一个类或者接口作为参数传递到另一个类中。

3）可以看到，二者都有效提高了代码的扩展性，无论是基于接口而非实现编程，还是依赖注入

最终的目的都是提高代码的扩展性、灵活性，越能应对未来的需求变化，殊途同归！

以上是个人的见解，还请多指教。

2019-12-16

potato00fa

控制反转不仅可以用在代码设计上，也可以用在架构设计上。比如分布式环境中，要做一个限频功能，如果每个系统每个接口都自己实现限流算法和频次，就会难以管理和控制，但是如果把限频的功能都反转到一个独立的系统，接口每次被调用之前都去问询该系统，情况就会好得多。

2019-12-16

安静的 boy

个人认为：

1. 基于接口编程而非实现编程是一种设计思想，用以提高程序的扩展性。依赖注入是控制反转的一种实现方式，主要用于简化我们项目的开发。

2. 依赖注入在遵守基于接口编程而非实现编程原则的基础上去实现，会提高程序的扩展性。

2019-12-16

DullBird

基于接口而非实现编程：主要是为了应对变化，提升扩展性。

依赖注入：主要是为了减少依赖，把互相之间的依赖关系，通过配置或少量代码描述出来。比如 spring 直接注入一个实现类 A。某一天换成 B 的时候，违反了基于接口编程，但是还符合依赖注入。

共同目的：都是为了增加扩展性

2019-12-16

quietwater

从 Notification 这个例子来看，「基于接口而非实现编程」跟「依赖注入」，看起来非常类似，那它俩有什么区别和联系呢？依赖注入主要解决创建对象的问题，对象的依赖关系具体实现，是对象的生命周期管理。基于接口编程是我们要依赖抽象不要依赖具体实现，是面向抽象编程，是解决依赖关系的策略。

2019-12-16

webmin

接口是一种契约形式的编程约定，给依赖注入落地的提供手段，方便编译器进行检查。

依赖契约优先。

2019-12-16

守拙

课堂讨论 Answer：

基于接口而非实现编程 是 里氏替换原则（Liskov Substitution Principle）理论下的具体实践，「依赖注入」是 依赖倒置原则（Dependency Injection Principle）理论下的具体实践。

关于两者的联系：

「基于接口而非实现编程」和」依赖注入「都是抽象理论指导下的编码实践，而且关注核心问题都是：依赖抽象。

关于两者的区别：

」基于接口而非实现编程「在具体实践上更强调接口与实现类的契约关系，即接口指导并约束实现类的职责，实现类负责在接口的指导下完成符合规范的功能。

而」依赖注入「在编码上更关注类与类之间的依赖关系，应该依赖抽象，而不是依赖具体。

2019-12-16

kyle

依赖注入指的是编程的思想，有很多种方法实现 DI, 对于 c# 文中的例子是构造函数输入，也可以是通过属性输入，等等。

2019-12-16

SMTCode

控制反转 (IOC: Inversion Of Control):

控制反转框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员在利用框架进行开发时，只需要往框架的预留点上，添加跟自己业务相关的代码，就可以利用这个框架来驱动整个程序流程的执行。

即：在框架中实现业务逻辑的控制流程，程序员只需要添加具体的业务逻辑即可，减少业务逻辑与控制逻辑的耦合。

依赖注入 (DI: Dependency)

不通过 new 的方式在类内部创建对象，而是将依赖的对象在外部创建好后，通过构造函数、函数参数等方式，将对象传递给类使用。

这样可以提高代码的扩展性，可以灵活替换依赖的类。

依赖注入框架 (DI Framework):

通过依赖注入框架的扩展点，简单配置一下所有需要的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

依赖翻转原则 (DIP: Dependency Inversion Principle):

High-level modules shouldn't depend on low-level modules.

Both modules should depend on abstractions.

In addition, abstractions shouldn't depend details.

Details should depend abstractions.

高层模块不应当依赖低层模块。

高层模块和低层模块都应依赖于抽象。

此外，抽象不能依赖于细节。

细节应当依赖于抽象。

这条原则主要是针对框架而言的，在日常的业务逻辑中，高层模块还是要依赖低层模块的。

2019-12-16

潜默闻雨

现实工程中的依赖反转：银行网贷项目。银行定义为高层（资金方），各大网贷平台定义为底层（资产方，各种网贷 app）。银行想放贷款赚钱，这个时候就去找各大网贷 app 去商议，你们帮我提供客户，我给你们钱。然后银行便一个一个的对接网贷 app，每联系一个就谈一次需求，网贷 app 千万多，奈何我银行没几个。然后，资金方发现自己依赖于每一个资产方，一旦资产方有什么业务变动，资金方自己必须也做响应调整，实属麻烦。这个时候突然跳出个中间商（可以理解为抽象），说资金方资产方，你们的业务我来帮你解决吧，我提供一个平台，定义一套标准，资金方你只管给钱，资产方你只管提供客户借钱，保证让每个客户都贷到款。这下整个生产线便十分通畅了，资金方也不会因为资产方的业务调整而做调整了，所有的变动都由这个中间商来解决了，资金方就是放放放，资产方就是借借借，其他不再关注。这个是自己在做的项目，我们就是那个中间商。突然联想到，感觉这样比喻应该没问题😁。顺便提醒下，网贷 app 利率都高的很，银行贷款利率要低很多（没事别乱用网贷，跟高利贷没啥区别，就算是大平台，依然高的很）

2019-12-16

your problem？

思考题：

区别：基于接口而非实现编程是一种指导原则，描述的是从细节上的一个函数，到宏观上的系统对接不应该依赖于具体实现而是依赖于抽象的接口对接，而依赖注入则是指不从内部建立具体的类依赖而将依赖通过注入或者传参等方式导入，是一种通过抽象降低依赖的具体编码实现

联系：可以通过基于接口编程思想来实现依赖注入（依赖注入框架就是这么做的）

不知道理解的有问题没有，请老师和大家来指点一下

2019-12-16

划时代

控制反转、依赖注入、依赖反转原则，已经在我设计开发的开发框架中熟练运用了，线上产品运行稳定，但我却不知道它们的名字。先知道框架代码的设计实现方式，后知道设计模式概念。后知后觉。

2019-12-16

Askerlve

打开，讲得好～

2019-12-16

Cy23

以前也学过几次，每次都是了解的一知半解，回头就忘记，这回听完还是这种感觉，可能要多看这些名字，然后对应的代码，反复思考，循环记忆啊，这回一定要加深理解，行程条件反射。

2019-12-16

编程界的小学生

我觉得依赖注入是基于面相接口编程这种思想的吧。

在举个与题解无关的例子，就是 spring 怎么做到不去 new 的，他将抽象指向具体实现这一步放到了配置文件里，然后利用工厂模式完美解耦合。

2019-12-16

liu_liu

依赖注入可以采用「基于接口编程」原则来实现

2019-12-16

逆风星痕

两者都是为了提高代码的可扩展性，依赖注入是一个更全的指导原则，基于接口而非实现编程可以看着是其的一种实现，同时也进行了扩展。

2019-12-16

峰峰

基于接口而非实现编程是对类设计的一种思想原则，依赖注入是具体的编码实现。

其中，依赖注入通过参数化的方式解决了在类中直接 new 对象的过程，也是解决了类与类的耦合。

不过，基于依赖注入在方法定义上使用具体的实现类的话，那么扩展性的问题没有解决。我们往往使用多态这一特性使得父类对象引用子类对象的方式达到好的扩展性。

因此，依赖注入的实现是在基于接口而非实现编程的设计原则之上的一种具体编程实现。

2019-12-16

逍遥思

基于接口而非实现编程是一种编程思想，依赖注入是一种编程技巧，前者依赖后者。如果不用依赖注入，那就必须在调用类内部创建被调用类的对象，这样一来，被调用类就只能是一个具体的类而不能是一个接口，基于接口而非实现编程就无从谈起了

2019-12-16

jaryoung

共同点：它们都需要一起维护和遵守一份规则。

区别点：基于接口非实现，重在说定义一份规则；而后者，侧重说，你要如何遵守依赖注入的规则。

2019-12-16

小畅

依赖注入是一种具体方式，而基于接口而非实现编程是一种思想，两者搭配可以更灵活使用依赖注入，让代码的拓展性变得更好

2019-12-16

FIGNT

一直用 spring，从未如此清晰理解 ioc 和 di。学习了

2019-12-16

Xs.Ten

「基于接口而非实现编程」是一种编程思想，而依赖注入是「基于接口而非实现编程」的具体实现。

2019-12-16

L🚲🐱

依赖注入是被动的，框架提程序员做了管理 bean 的事，基于接口而实现限编程是主动的，是程序员自己控制的

2019-12-16

失火的夏天

一个是设计思想，一个是编码技巧。目的都是为了解耦合，不要直接依赖，而是通过上层抽象关联，这样服务方的改动，并不会影响调用方的使用。最终还是一个开闭原则。

2019-12-16

Rayjun

控制反转和基于接口编程都不依赖具体的实现细节

2019-12-16

