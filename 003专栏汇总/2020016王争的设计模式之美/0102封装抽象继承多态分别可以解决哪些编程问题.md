# 0102. 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

王争 2019-11-13

上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。

这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。

封装（Encapsulation）

首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。

下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用 OOP 的设计思想来详细介绍虚拟钱包的设计实现。

public class Wallet {


  private String id;


  private long createTime;


  private BigDecimal balance;


  private long balanceLastModifiedTime;


//... 省略其他属性...

  public Wallet() {


     this.id = IdGenerator.getInstance().generate();


     this.createTime = System.currentTimeMillis();


     this.balance = BigDecimal.ZERO;


     this.balanceLastModifiedTime = System.currentTimeMillis();


  }


// 注意：下面对 get 方法做了代码折叠，是为了减少代码所占文章的篇幅

  public String getId() { return this.id; }


  public long getCreateTime() { return this.createTime; }


  public BigDecimal getBalance() { return this.balance; }


  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }


  public void increaseBalance(BigDecimal increasedAmount) {


    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {


      throw new InvalidAmountException("...");


    }


    this.balance.add(increasedAmount);


    this.balanceLastModifiedTime = System.currentTimeMillis();


  }


  public void decreaseBalance(BigDecimal decreasedAmount) {


    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {


      throw new InvalidAmountException("...");


    }


    if (decreasedAmount.compareTo(this.balance) > 0) {


      throw new InsufficientAmountException("...");


    }


    this.balance.subtract(decreasedAmount);


    this.balanceLastModifiedTime = System.currentTimeMillis();


  }


}


从代码中，我们可以发现，Wallet 类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。

String getId()


long getCreateTime()


BigDecimal getBalance()


long getBalanceLastModifiedTime()


void increaseBalance(BigDecimal increasedAmount)


void decreaseBalance(BigDecimal decreasedAmount)


之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。

对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance () 和 decreaseBalance () 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance () 和 decreaseBalance () 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。

封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中「偷偷地」重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。

抽象（Abstraction）

讲完了封装特性，我们再来看抽象特性。封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作「接口类」而不是「接口」。之所以这么做，是因为「接口」这个词太泛化，可以指好多概念，比如 API 接口等，所以，我们用「接口类」特指编程语言提供的接口语法。

对于抽象这个特性，我举一个例子来进一步解释一下。

public interface IPictureStorage {


  void savePicture(Picture picture);


  Image getPicture(String pictureId);


  void deletePicture(String pictureId);


  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);


}


public class PictureStorage implements IPictureStorage {


//... 省略其他属性...

  @Override


  public void savePicture(Picture picture) { ... }


  @Override


  public Image getPicture(String pictureId) { ... }


  @Override


  public void deletePicture(String pictureId) { ... }


  @Override


  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }


}


在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。

之所以这么说，那是因为，类的方法是通过编程语言中的「函数」这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc () 函数的时候，并不需要了解它的底层代码是怎么实现的。

除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供「函数」这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的「特异性」，有时候并不被看作面向对象编程的特性之一。

抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？

实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl () 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl ()，那即便内部存储方式修改了，我们也不需要修改命名。

继承（Inheritance）

学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses ()，Ruby 使用 <。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。

继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？

继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看「父类、父类的父类……」的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。

所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到「多用组合少用继承」这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。

多态（Polymorphism）

学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。

public class DynamicArray {


  private static final int DEFAULT_CAPACITY = 10;


  protected int size = 0;


  protected int capacity = DEFAULT_CAPACITY;


  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];


  


  public int size() { return this.size; }


  public Integer get(int index) { return elements[index];}


//... 省略 n 多方法...

  


  public void add(Integer e) {


    ensureCapacity();


    elements[size++] = e;


  }


  


  protected void ensureCapacity() {


//... 如果数组满了就扩容... 代码省略...

  }


}


public class SortedDynamicArray extends DynamicArray {


  @Override


  public void add(Integer e) {


    ensureCapacity();


    int i;


for (i = size-1; i>=0; --i) { // 保证数组中的数据有序

      if (elements[i] > e) {


        elements[i+1] = elements[i];


      } else {


        break;


      }


    }


    elements[i+1] = e;


    ++size;


  }


}


public class Example {


  public static void test(DynamicArray dynamicArray) {


    dynamicArray.add(5);


    dynamicArray.add(1);


    dynamicArray.add(3);


    for (int i = 0; i < dynamicArray.size(); ++i) {


      System.out.println(dynamicArray.get(i));


    }


  }


  


  public static void main(String args[]) {


    DynamicArray dynamicArray = new SortedDynamicArray();


test (dynamicArray); // 打印结果：1、3、5

  }


}


多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。

第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。

第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。

第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add () 方法。

通过这三种语法机制配合在一起，我们就实现了在 test () 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add () 方法，也就是实现了多态特性。

对于多态特性的实现方式，除了利用「继承加方法重写」这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码。

public interface Iterator {


  String hasNext();


  String next();


  String remove();


}


public class Array implements Iterator {


  private String[] data;


  


  public String hasNext() { ... }


  public String next() { ... }


  public String remove() { ... }


//... 省略其他方法...

}


public class LinkedList implements Iterator {


  private LinkedListNode head;


  


  public String hasNext() { ... }


  public String next() { ... }


  public String remove() { ... }


//... 省略其他方法...

}


public class Demo {


  private static void print(Iterator iterator) {


    while (iterator.hasNext()) {


      System.out.println(iterator.next());


    }


  }


  


  public static void main(String[] args) {


    Iterator arrayIterator = new Array();


    print(arrayIterator);


    


    Iterator linkedListIterator = new LinkedList();


    print(linkedListIterator);


  }


}


在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print (Iterator iterator) 函数中，支持动态的调用不同的 next ()、hasNext () 实现。

具体点讲就是，当我们往 print (Iterator iterator) 函数传递 Array 类型的对象的时候，print (Iterator iterator) 函数就会调用 Array 的 next ()、hasNext () 的实现逻辑；当我们往 print (Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print (Iterator iterator) 函数就会调用 LinkedList 的 next ()、hasNext () 的实现逻辑。

刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。我们还是先来看一段代码。这是一段 Python 代码。

class Logger:


    def record(self):


        print(「I write a log into file.」)


        


class DB:


    def record(self):


        print(「I insert data into db. 」)


        


def test(recorder):


    recorder.record()


def demo():


    logger = Logger()


    db = DB()


    test(logger)


    test(db)


从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record () 方法，就可以被传递到 test () 方法中，在实际运行的时候，执行对应的 record () 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。

多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？

多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator 的例子）。

在那个例子中，我们利用多态的特性，仅用一个 print () 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext ()、next () 等方法就可以了，完全不需要改动 print () 函数的代码。所以说，多态提高了代码的可扩展性。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print (Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print () 函数，比如针对 Array，我们要实现 print (Array array) 函数，针对 LinkedList，我们要实现 print (LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print () 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。

重点回顾

今天的内容就讲完了，我们来一起总结回顾一下，你需要重点掌握的几个知识点。

1. 关于封装特性

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

2. 关于抽象特性

封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

3. 关于继承特性

继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。

4. 关于多态特性

多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

课堂讨论

今天我们要讨论的话题有如下两个。

你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？

欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (286)

Smallfly


争哥对面向对象的总结完美符合 What/How/Why 模型，我按照模型作下梳理。

## 封装

What：隐藏信息，保护数据访问。

How：暴露有限接口和属性，需要编程语言提供访问控制的语法。

Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

## 抽象

What: 隐藏具体实现，使用者只需关心功能，无需关心实现。

How: 通过接口类或者抽象类实现，特殊语法机制非必须。

Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

## 继承

What: 表示 is-a 关系，分为单继承和多继承。

How: 需要编程语言提供特殊语法机制。例如 Java 的「extends」，C++ 的「:」。

Why: 解决代码复用问题。

## 多态

What: 子类替换父类，在运行时调用子类的实现。

How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。

Why: 提高代码扩展性和复用性。

3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。

2019-11-14


№修罗★幻影

Java 不支持多重继承的原因

多重继承有副作用：钻石问题 (菱形继承)。

假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。

考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从 JDK1.8 之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。

2019-11-13


拉格朗日的忧桑

这是迄今讲面向对象特性最深刻的，没有之一

作者回复: 😄 多谢认可

2019-11-13


小学一年级

我理解的四大特性

封装：加装备（添加盔甲）

继承：师傅掌对掌传输武功（毫无保留）

抽象：从道到术，柳叶能伤人

多态：奥特曼变身。

2019-11-13


丁丁历险记

好久没复杂这些基础知识了，借今天写笔记的时间过足瘾。我就菜鸟一个，也深知言多必失，肯定有瞎扯的地方，还请指正，我好迭代。

1 封装

常见编程语言通过 public protected privite 来支持

封装的意义 。

关掉直接操作数据的口子，让数据的修改更贴合真实业务。

例如：创建时间，就没有修改数据的场景。

钱包的钱数，只能通过增加，减少接口进行调整，不开放直接设置金额的接口（口子一开，对账就是个麻烦事）

另一个意义，调用类，没有必要知道太多的实施类的具体实现细节。让操作更为简单。

个人思考：

封装就是让代码遵守开闭原则的重要手段。

当调用类，关注过多实施类的继节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了太多了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。

Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处.

再乱想一下，人体，不就是最好的的封装么，给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。

2 抽像。

抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。

通常借 interface 和 abstract class 来实现 抽像这一特性。当 implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。

抽你的意义，能解决啥问题。

1 处理复杂性的有效手段。人脑承受信息有限，抽像做为不关注实现细节的套路，正好管用。

2 抽像指导了很多的 oo 原则 ，凡时对实现进行封装抽离的，都可以叫抽像，例如 malloc ()

3 定义类时，要有抽像思维，不要在方法中，暴露太多细节。（建议一层抽象层，让功能分解得更细，让意图和实现分享）

个人理解

（抽象处理的复杂度是人月神话里描述 的本质复杂度（Essential Complexity），也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节），（推荐阅读 google 整理术）

再瞎想一下，抽像是将很多的知道点给封装起来了 (encoding 成为一个模型) ，归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足 sru）, 然后通过合理的 ood , 去调用或运行时 create 具体的子类对象，去实现。拜抽象所赐，一种各有分工，又能有序协同的场景就出来了

其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。（套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）

笔记下（下）

3 继承

继续用来表示类之间是 is -a 关系。

猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄

有些语言单继续，有些多继承。

意义 和解决问题。

1 符合认知美感 。

2 减少重复 coding .

问题：重要隐患，父子类，大量方便藕合。

个人理解。

继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。

再者 复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。一但重了，就往往产生大量的不必要的负担。我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。

基于职责太重这事，我是很反感用多重继续的。需要啥，再组合一个类多好。多关联一个类，死不了人的。搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的

4 多态。(个人觉得 oo 中最有趣的一块)

多态指子类替代父类。

三种语法机制。（父可以）

实现多态，除继续外，还有利用接口类语法，duck-typing

个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。于是支持这种把事搞活的套路出来。

2019-11-14


小白

go 语言的「隐藏式接口」算是多态中 duck-typing 的实现方式吧

2019-11-13


初心

多态一句话，现在调用将来

2019-11-16


猫切切切切切

封装隐藏属性

抽象隐藏方法

继承支持复用

多态支持扩展

2019-11-14


每天晒白牙

专栏中有个思考题是 java 为何不支持类多继承？却支持接口的多继承？

而有些语言如 python 是支持多继承的？

首先 java 类支持多继承的话，两个父类有同名方法，在子类中调用的时候就不知道调用哪个了，出现决议 (钻石问题或菱形问题) 问题

而接口支持多继承因为接口定义的方法不能有方法体，所以不会出现决议问题。

而从 jdk1.8 开始，接口可以有默认方法 (方法要用 default 标识)，必须要有方法体，这样在接口多继承上不也会有决议问题吗？其实你去试下就知道了，java 发现这种情况，会通过让你强制在子接口中重写这个默认方法，这样就不会有决议问题了

python 支持多继承因为它通过 MRO 解决的，pythoner 应该懂，我是不太懂，感兴趣的可以去研究

2019-11-13


weiguozhihui


c 语言通过结构体来实现封装，只是 c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外 C 中通过 void*+ 结构体 + 函数指针也是可以实现多太的。Linux 内核代码好多都是用了面向对象编程思想。C++ 中引入 public protected private 关键字来进行访问控制权管理。C++ 中没有 Java 中的 interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的 Java 中的接口类的。C++ 是直接支持多继承的，但这个特性也被好多人诟病。

2019-11-13


划时代

话题一：

C++ 语言的多重继承，存在三层继承关系时，采用 virtual 继承方式，形成菱形继承。标准库中的 iostream 类就存在多重继承关系，见图 http://www.cplusplus.com/img/iostream.gif。

话题二：

C++ 语言的多态实现方式比较丰富，除了类中的 virtual 函数实现运行期多态以外。还支持编译期多态（模板元编程），不仅能够动态改变对象执行的函数，还能动态改变对象的定义类型。

2019-11-13


Paul Shan


猫不是爬行动物，:).

2019-11-13


zcdll


1. 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

1. JavaScript 不支持多继承，多继承理论上都存在「菱形问题」，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法 add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时 就会出问题，不知道调用哪个方法了。

2. 理论上是可以通过 Mixin 的方式来实现多继承。

3. 通过一些 合并 算法来「部分」解决「菱形问题」

4. 参考 JavaScript 中的「多继承」[https://juejin.im/entry/5ac46b6c5188255570063b71](https://juejin.im/entry/5ac46b6c5188255570063b71)

2. 你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？

1. JavaScript 支持封装，抽象，继承，多态

2. 封装 ES6 的话，通过 public protected private 等关键字来实现，ES5 的话通过「函数作用域」，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。

3. 抽象 可以通过 this 指针 和 原型链 的形式来实现

4. 继承 通过 原型链 来实现，或者说基于封装的特性来实现

5. 多态 通过原型链 的方式，子类覆写父类的方法来实现

2019-11-15


业余草

是时候抛出这道难住 99% 的程序员的设计模式面试题了！

https://mp.weixin.qq.com/s/9SBV9ZycAQY82BacYICY2w


2019-11-13


Bug? Feature!


我们使用 Java 已经很长时间了，我们有多少次因为缺少多重继承而面临困难呢？

我个人的经验是一次都没有。因为多重继承很少有机会被用到，所以更安全的做法是去掉它而保持简单性。

就算是碰到需要多重继承的情景，我们也可以找到替代方法。

我的观点是，去掉对多重继承的支持不是 Java 的缺陷，对开发者来说是件好事。

2019-11-13


晨风破晓

PHP 不支持多继承，具体为什么还没了解过，四大特性都是有现有语法支持的；看完这堂课，貌似对多态还不是很理解

2019-11-13


秉心说

多继承会带来菱形继承的问题。例如一个类的两个父类，都继承了同一个祖父类，两个父类都 override 了祖父类的方法，这时候孙子类就不知道如何调用了。

Java 8 的 interface 可以有方法默认实现，这应该可以算是曲线救国的多继承吧。

2019-11-13


秋惊蛰

试着说一下 Python 吧

- 抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量，函数，类，模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python 主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。

- 封装：Python 不支持严格意义上的封装，没有 private, protected 等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时 Python 里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是 Python 被吐槽的地方吧，大型项目约束力不够。

- 继承：Python 支持多重继承，主要是因为它没有类似于 Java 的「接口类」的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。

- 多态：Python 的多态就是鸭子类型了，鸭子类型的背后是所谓「协议」，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和 Java 中实现了 Iterator 接口一样。

2019-11-13


李湘河

示例代码自己运行了麽，虽说是将设计思想、设计模式，但是代码很多错误呀，像多态示例代码，父类私有属性在子类继承中能直接用吗？

作者回复：已经修改成 protected 的了。代码自己改改，可以运行的。但代码的作用主要还是辅助解释理论，所以有所删减，也是考虑到文章篇幅的问题。

2019-11-13


昨日火冷啊

老师好，

请问 c++ 的 template 算不算 duck-typing？ 比如定义一个模版，A<T>，用到函数 T.Load ()。然后有类 B 和 C 都有成员函数 Load（）。那么都可以通过使用 A<B> 和 A<C> 来使用模版，而 B，C 之间不需要继承关系。

作者回复：从你的描述来看，有点类似的。

2019-11-17


与雨日肇事的爱

王老师，你这系列课程写的代码有和数据结构和算法类似的 GitHub 仓库么？可以获取源码么？

作者回复：你 github 上搜 wangzheng0822，我打算集中放到那里

2019-11-14


ldd


话题 1：

Objective-C 不支持多继承，OC 的方法调用是基于消息机制，是基于方法名调用的，而且是发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题。

话题 2：

封装：@private、@protected、@public 表作用域的关键字，而且还可以用.h、.m 机制实现。

抽象：protocol 协议来实现。

继承：简单的 Child : Parent 来实现，内部其实用 isa 指针来实现的。

多态：继承、protocol 都可以实现

番外：OC 也可以实现多继承，可以用消息转发机制去实现。但本人觉得多继承好像确实不是很实用，之前看 c++ 文档也不建议多用，很想听听争哥对多继承的态度☺️

2019-11-19


小妖

我觉得文中对多肽的定义有问题，多肽不仅是只子类替换父类（父类对象引用子类对象），也包括父类（代理类）可以在某些时候代替子类作为参数传递（继承的方式实现参数代理），更直观的表现是实现类替换接口（接口引用接口的实现比如 : LIst<String> list=new ArrayList<>();）, 这听起来有点像是抽象，实际上抽象的很多情况下是依赖多肽的，比如，方法接口接口作为参数，而不必接收具体的类这体现了抽象，但更体现了多肽………… 求交流

作者回复：你举的例子不还是子类传递给父类吗

2019-11-21


马建华

DynamicArray 代码中：

        for (int i = 0; i < dynamicArray.size(); ++i) {


            System.out.println(dynamicArray[i]);


        }


这一段代码在 IDE 中显示 dynamicArray [I] 报错：

The type of the expression must be an array type but it resolved to DynamicArrayJava(536871062)


作者回复: get（i）代码有点问题 我改下

2019-11-20


wanghai


我最近在做一个功能，而且我也是有一些迷茫

我用到了继承，在父类定义了很多方法，然后我有很多子类，每个子类自己来实现一些需要重写的方法.

我也想到了组合，但是组合好像无法重写方法，导致变的更麻烦，希望大神帮我解惑～～

作者回复：后面章节会讲到 别急

2019-11-19


王振华 程序员 区块链

请问：封装部分，「而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的」，这句话我不理解。id、createTime 这两个属性的初始化设置，对于 Wallet 类的调用者来说，为什么是透明的？调用者应该不知道 Wallet 类内部的实现细节才对呀？

作者回复：透明的意思不就是不知道细节吗

2019-11-17


码农 Kevin 亮

请问老师，有些教科书上会把重载也理解为多态，老师怎么理解呢

作者回复：是的 有人把它叫做静态多态

2019-11-17


大胖子

这篇文章讲的真他娘的好啊

2019-11-14


叶十七

感觉抽象并不是为了信息隐藏，抽象是为了把共性的东西抽象出来，如麻雀，燕子的行为可以抽象为鸟的行为，这是抽象，这篇描述的抽象个人觉得不那么准确。

2019-11-14


Paul Shan


Java 对于封装，抽象，继承，多态支持够用了。封装和抽象解决的是信息隐藏的问题，也就是说不同位置需要看到的信息不同。封装是以类为边界，两边需要的信息量不对等。抽象是以调用者和实现者的角度来区分，两者需要的信息量差异也很大。继承和多态是抽象思想的延续，当类被分为接口和实现的时候，所有针对接口实现的操作，也同样使用于实现类。当一个接口有多个实现类，而针对接口实现的操作适用于所有满足这个接口的实现类，这样就让针对接口的代码得到复用。

2019-11-13


编程界的小学生

JAVA 前来报到，不支持多继承是因为考虑到钻石问题，比如 A 继承 B 和 C，B 和 C 继承了 D，那么 A 类中覆盖的 D 方法是 B 重写的还是 C 重写的呢？导致混乱。

有个问题就是：某种意义上讲，JAVA 是不是隐式支持多继承的？因为每个类都默认继承了 Object 类，都用有 Object 的 toString 等方法。

2019-11-13


一周思进

搞 C 语言的咋整🤣

作者回复：学一下 java 呗，也不难，周末有加餐文章，你可以跟着学下。

2019-11-13


小先生

王老师，讨论一个代码规范的方面。getPictureUrl () 写成 getPictureURL () 会不会更好一些？

作者回复：可能是我的个人习惯问题，我喜欢把 URL 在代码命名中写成 Url。

2019-11-13


醉比

java 不支持多继承，大致了解两个原因：1. 如果继承打得多个父类有相同的成员变量，子类在引用的时候就无法区分。2. 若果继承的多个父类有相通的方法，而子类又没有重新实现该方法，那么在使用该方法时就无法确定该去使用哪个方法。欢迎指正与补充～

2019-11-13


辣么大

老师，我还有一个问题：

Java 中支持反射机制。利用反射机制，我们可以访问类的私有变量和私有方法。请问这是否有违「封装」的初衷呢？哪些场合我们要必须使用「反射」访问私有变量或者私有方法呢？

作者回复：理论上讲这是一种 hack 的方法 不推荐使用

2019-11-13


allean


打卡

2019-11-13


Bug? Feature!


沙发

2019-11-13


Roc


python 是支持多继承的，对于多继承的二义性问题，有一套 MRO (Method Resolution Order) 机制来解决，简单说就是排序。目前是采用 C3 算法，对继承关系建树后，使用拓扑排序得到序列；在 python2.2 之前也有用 DFS 去获取继承序列，但 DFS 会出现继承不到子类对于父类的重写，而后更新为 C3 算法，解决了本地优先级及单调性的问题。

详见贴：

https://blog.csdn.net/qq_38923792/article/details/94414944


https://www.mscto.com/python/183897.html


https://blog.csdn.net/qwertyupoiuytr/article/details/56439134


2020-04-24


Darren


JDK7 以后，有了 invokedynamic，其实在字节码层面也是可以实现 duck-typing 效果的

2020-04-02


Nick


重新回顾了面向对象的 4 大特性，争哥讲的很透彻，值得反复阅读和理解，对于刚入职场的同学，面试的时候也很有帮助。

2020-03-19


晓杉

java 不支持多继承，但支持多实现，可以一定程度上弥补多继承。

2020-01-11


🛠️🛠️🛠️人和尚

多态是否又分为编译时多态和运行时多态？

作者回复：是的

2019-12-22


格子衫

我学习的是 JAVA

JAVA 是不支持多继承的，

JAVA 实现了封装，继承，多态，抽象等四大特性，是真正意义上的面向对象编程语言

我有一点疑惑，就您说的访问权限控制符那里，您说的「如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的」，这恐怕是不对的吧，我在其他的教程上看到的是 default, 我也试了一下，确实是 default.

因为 default 和 public 的权限是不一样的。

public: 所有的类都可以访问

default: 只有本身的类，子类，还有这个类所在的包中的所有的类可以访问

这两个的权限是不一样的！

这是我的疑惑，还请老师解释一下！

作者回复：是不一样的。我的意思是如果 java 语言中没有访问控制权限的语法，就是没有 private、public、protected、default。。。这是一个假设...

2019-11-15


ning 先森

PHP 独特的语法混合了 C、Java、Perl 以及 PHP 自创的语法，不支持多继承的原因应与 Java 同，实现多继承的方式有：接口 /trait/__call ()

2019-11-15


月坛小雨

python 支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python 使用了 C3 算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用 funcitonname.__mro__可以查看调用顺序。对问题二，python 在子类重写方法时，使用 super ().methodname () 语句，super 本质上是一个类，内部记录着 MRO 信息，也是用 C3 算法保证一个类只会被搜寻一次。

2019-11-15


风流倜傥怪蜀黍

偏门语言 OC 前来报道！

OC 不支持多继承，原因无非就是菱形继承导致的二异性.

OC 中的协议根老师讲的接口类是一个概念，只有方法声明 (swift 可添加默认实现), 可以实现伪多继承.

这里要说一下 OC 的消息转发机制，源自 smallTalk, 赋予了 OC 语言的动态性，是整个 OC 语言的一大亮点，消息转发简单的理解成我虽然无法响应这个函数，但是我可以在运行时的时候指定其它类去响应，利用这个可以实现动态的实现多继承和多态特性

2019-11-15


赵宇浩

最近在探索 DDD 的时候有个问题，当涉及 db 或 api 时该怎么设计。

比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用 api，那这个 api 需要这个账户类持有么？那每次创建对象还要 set 进去？感觉不是很舒服。。

作者回复：感觉还是一种数据驱动或者 db 驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db 中数据的读和存只是很小的一部分。

2019-11-15


何

封装讲 private、protected、public 的重要性，多态就不讲了？那个例子实在没看懂，不是写 java 的，不知道 java 同学看懂了没有？花钱了的！！！！

作者回复：你说的多态就不讲了？啥意思？周末加餐会讲下专栏中用到的 java 语法的

2019-11-14


筱乐乐哦

哈哈，老师写的很好，多态那，我又去复习了下下 jvm 的加过程，感觉又进一步理解了，老师赶紧更新吧，饥渴难耐啊

2019-11-14


逍遥思

Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。

Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: ClassB，对多态的支持是子类重写父类的方法。

2019-11-14


远心

DynamicArray 类的 size 和 elements 属性都是私有的，SortedDynamicArray 类不能直接访问吧？

作者回复：已经修改，多谢指出！

2019-11-14


学好习，做好人

钱包那个例子，个人感觉应该把钱包余额的加减操作独立出来，比如 WalletAction，并且 WalletAction 作为 wallet 的成员变量会不会更好一些，因为 id,createTime,modifyTime 可以算作钱包的一些固有属性，但是余额增加更偏重一些动态的计算行为，用组合的方式会不会更好些呢？

作者回复：也可以，不过看起来就有点过度设计的意思了，多了一个类，维护成本也提高了。

2019-11-14


弹头哥

争哥，多态的第一段代码第 25 行：

for (int i = size-1; i>=0; --i) {


应该是 size ()-1 吧，size 是 private 变量。

作者回复：改成 protected 的了😂

2019-11-14


sunnywhy


多态的第一个例子中，43 行 System.out.println (dynamicArray [i]);，应该是 dynamicArray.get (i)

作者回复：嗯嗯 我改下

2019-11-14


村长

cpp 的虚基类都不加实现不就是接口么

作者回复: 😄 马上会讲到 如何用抽象类模拟接口

2019-11-13


Monday


1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的？

java 不支持多重继承。

原因：多重继承中若不同父类存在相同方法签名时，子类调用此方法时会不知道调用哪个父类的方法的问题。

如何避免：个人觉得可以根据所继承父类的先后顺序来确定优先级

2019-11-13


helloworld


这节课程虽然对于有编程经验的人来说很容易理解，但是读完后能感受到老师清晰的解读思路，赞！

2019-11-13


小辉辉

go 语言中也有 duck-typing

2019-11-13


小喵喵

我们常常听到这样一句话：面向接口编程，而不是实现编码。我举例一下，原谅我拿阿猫阿狗举例

 interface Animal


    {


        void Eat();


    }


    public class Dog : Animal


    {


        public void Eat()


        {


            //print dog eat bone.


        }


    }


    public class Cat : Animal


    {


        public void Eat()


        {


            //cat eat fish


        }


    }


    public class DemoTest


    {


        public void Test()


        {


// 接口来调用

            Animal dog = new Dog();


            dog.Eat();


            Animal cat = new Cat();


            cat.Eat();


//class 来调用

            Dog dog = new Dog();


            dog.Eat();


            Cat cat = new Cat();


            cat.Eat();


        }


    }


我还是没有完全理解，觉得面向接口编程反而增加了更多的代码（比如单独定义 interface Animal）。上端程序使用的时候也需要知道具体的 Animal (比如 Animal dog = new Dog ())。也是实例化一个 Dog 然后赋值给 Animal 的。为什么不觉得直接来使用 Dog dog = new Dog ()。这样还可以去掉 Interface Animal 了。

2019-11-13


xavier


封装这里的解释，让我联想到 less is more 这句话。

less 是对使用者而言。像封装一样，仅提供关键的方法给使用者。

more 是对设计者而言。为了实现封装特性，封装内部会做大量处理。

2019-11-13


安静

duck-typing 实现多态的方式确实灵活，这个维护成功也会比较高吗？

作者回复：我个人觉得 duck typing 过于灵活了

2019-11-13


李小四

设计模式 05：

- Java 不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照 ** 接口 -> 抽象类 -> 实现类 -> 拓展实现类 ** 这样的模式，这样设计出来的一组类是与某一个「业务」强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。

2019-11-13


LJK


一些自己查的内容：

对于 Python 的封装特性，用双下滑线标注的 private 变量其实内部只是重命名了一下而已，即

class A():


    def __init__(self):


        self.__private = "Private"


其中的__private 在 A 的实例上可以通过 "_A__private" 来访问，这么看来的话 Python 的封装其实还是相对比较宽松的，不知道为什么这么设计。

对于多态，Python 接口类是通过 abc 抽象类来实现的。

如有不对还请指正，多谢大家

2019-11-13


西电

多继承方法重名时候的二意性问题

2020-07-16


歪歪

java 不支持多继承的原因是因为菱形问题。get

2020-07-15


第三人称

迭代器的那个类 hasNext 方法返回值应该是 boolean 吧 文章中是 String

作者回复：嗯嗯 我修改下 多谢指出

2020-07-09


sorationalist


总结：1. 继承关系，公共功能可以实现代码的复用，然后重写父类方法来实现特殊业务的处理，场景，类之间必须是 is-a 关系，继承特性代码层次嵌套过深，难以维护。

2. 多态，继承或者接口以来实现，只要保证拥有相同的方法，不需要强制具有 is-a 关系。

2020-07-04


见南山

封装：保护数据，提供少量的属性和方法，易用，易维护。java 中采用 public，pritected default private 四个关键词来控制类方法字段得访问权限。

抽象：隐藏方法的细节，使用者只需要关注方法的去参和结果即可。java 中有接口和抽象类。

继承：方法复用。extends

多态：代码的扩展性。继承 + 接口或抽象类

2020-06-22


qiuyuan


封装:

我钱包里的钱我可以拿出来给你，你也可以拿给我我装进去，但你不能直接动我的钱包

抽象:

存在又不存在的就是抽象的

继承:

继承的本质是能力的复用

多态:

不用说那么多，你就说你是不是 xxx，是就行

2020-06-19


Chris Zou


一：

C++ 语言支持多重继承，避免二义性副作用

1. 加类名限定符，指定具体类；

2. 子类同名覆盖，内部实现指定一个具体的类；

3. 虚基类，多重继承自有共同虚基类的类；

[参考博客](https://blog.csdn.net/yang2011079080010/article/details/51407144)

二：

封装：private、protected、public 关键字

抽象：纯虚函数表示一个抽象接口，子类实现；

继承：":" 符号

多态：

静态多态：函数重载和泛型编程，发生在编译时期

动态多态：一种接口，多个虚函数实现，发生在运行期间。指针或者引用的父类对象，通过调用父类对象（指针类型或者引用类型）的虚函数来动态调用实际对象的虚函数方法。底层实现是每个类维系一个虚函数地址表，实际的类对象分配一个虚表指针来指向是父类还是子类的虚表，从而实现多态。

2020-06-14


朝小树

多态：父类声明，子类实现，调用同名方法时，调用的是子类重写的方法。

2020-05-22


Geek_East


核心目的：无限拓展

- 最小化重复代码 (继承：子类、抽象类、泛型) -> 拓展效率

- 最小化副作用 (封装) -> 拓展前提

- 最大化传参类型 （多态：子类、接口类) -> 水平拓展

- 向上构建 (抽象) -> 垂直拓展

2020-05-21


黄学尧

我的关注点比较奇特。。

猫是哺乳动物，不是爬行动物，哺乳动物和爬行动物是互斥的。

2020-05-21


超乎所以

java 语言不支持多重继承。多重继承有菱形继承问题。类 A 有方法 add (*), 类 B, 类 C 都继承自类 A, 重写方法 add (), 类 D 继承自 B,C，此时 D 调用 add () 方法时，调用的是哪个 add () 方法呢？

2020-05-20


刘同青

课后题：

你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

java 不支持多继承。为了防止菱形继承的副作用，假设支持多继承，B 类和 C 类继承了 A 类，并重写方法 fun1 ()，那么如果 D 类同时继承了 B 类和 C 类，那么调用 D 类对象的方法 fun1 () 时，是执行 B 类中的方法还是 C 类的方法呢？

C++ 支持多继承，可以在调用方法时指定父类以避免二义性，但是这种方式会降低方法的易用性。

学习笔记：抽象封装继承多态可以解决什么问题

1、封装

解释：信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部通过这些合理的接口对类进行访问。需要编程语言提供访问权限控制的语法，比如 java 提供 private protected public

作用：相比可以对类的属性随意进行 set 来说，对类进行封装的优点是：

（1）易读。外部仅能通过有限的接口访问，而且一般还有明确的含义。

（2）易用。使用者不需要对所有属性都关注，而且要小心的 set,，封装后可以大胆的调用。

（3）安全。如果随意修改，可能造成数据不一致。

2、抽象

解释：隐藏方法实现细节，调用者只需要关注方法有什么功能，不需要了解方法的实现。常常通过编程语言的接口类和抽象类来实现抽象，比如 java 中的 interface 接口类和 abstract 抽象类。实际上单纯的一个函数也是抽象，因为调用函数时不需要关注函数体，而只需要根据函数的注释了解其功能，然后就可以使用了。

作用：通过抽象可以屏蔽实现细节，使问题聚焦，是处理复杂问题的有效手段

注意：在定义类、接口或者命令函数的时候也要有抽象思维，名字不要暴露太多的实现细节，以提高名称的稳定性，以保证在未来改变方法实现逻辑的时候，名字不用变。

3、继承

解释：表示类之间 is a 的关系，java 为了避免菱形问题所以仅仅支持单继承。

作用：代码复用。

注意点：继承层次过深，会导致代码的可读性可维护性变差，为了 了解一个子类的功能，不仅需要查看这个类，还需要按照继承关系一层一层的向上查看；子类和父类高度耦合，修改父类的代码会直接影响到子类。

4、多态

解释：父类变量可以指向子类对象，后者说接口变量可以指向实现类对象，通过继承 + 方法重写和接口 + 方法实现来实现多态。

作用：提高代码的扩展性和复用性。

（1）因为父类或者接口类一般都是比较抽象的，越抽象越远离具体实现的类或接口越稳定，所以客户端使用父类或者接口变量进行开发，而不去关注易变的具体子类或者接口实现类，这样在需要替换子类或者实现类的时候，不需要大动干戈的修改原有代码，这就是扩展性。

（2）如果一个方法的参数是抽象的父类或接口，那可以传入任意的子类对象或者接口实现类，让这个方法的复用性更好。

课后题

2020-05-13


方舟勇士

Grady Booch：抽象和封装是互补的概念：抽象关注的是对象可以观察到的行为，而封装关注这种行为的实现。封装通常是通过信息隐藏来实现的（不只是数据隐藏）。信息隐藏是将那些不涉及对象本质特征的秘密都隐藏起来的过程。通常，对象的结构是隐藏的，其方法的实现也是隐藏的。

2020-05-13


scmath


golang 中的数据访问保护

package main


import "fmt"


type Foo struct {


  name string


}


// Set 方法

func (f *Foo) SetName(name string) {


  // do ....


  f.name = name


}


// Get 方法，只要把首字母大写。

func (f Foo) Name() string {


   // do


    return f.name


}


func main() {


   p := Foo{}


   p.SetName("Abc")


   name := p.Name()


   fmt.Println(name)


}


HTTP Read 时 RequestJOSN 反序列化为实体 RequestXxx，HTTP Write 时序列化 ResponseXxx —> ResponseJSON。这 2 个对象的属性必须包外可见。BO 可以用数据访问保护

2020-05-12


scmath


封装：数据访问保护。

需要保护的属性声明为 private xxx，通过 getXxx (),setXxx () 方法对属性进行中取值和赋值，方法内部可以对私有属性进行逻辑封装，保证数据不被恶意修改。好多通过工具生成空的 get set 方法，或者直接通过 @Data 注解完成 get set 方法，是对封装特性的破坏。

2020-05-12


