# 0108 | 实战一（上）：业务开发常用的基于贫血模型的 MVC 架构违背 OOP 吗？

王争 2019-11-27




2.0x





讲述：冯永吉 大小：14.54M 时长：15:52

在前面几节课中，我们学习了面向对象的一些理论知识，比如，面向对象四大特性、接口和抽象类、面向对象和面向过程编程风格、基于接口而非实现编程和多用组合少用继承设计思想等等。接下来，我们再用四节课的时间，通过两个更加贴近实战的项目来进一步学习，如何将这些理论应用到实际的软件开发中。

据我了解，大部分工程师都是做业务开发的，所以，今天我们讲的这个实战项目也是一个典型的业务系统开发案例。我们都知道，很多业务系统都是基于 MVC 三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的 MVC 三层架构开发模式。

虽然这种开发模式已经成为标准的 Web 项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为反模式（anti-pattern）。特别是领域驱动设计（Domain Driven Design，简称 DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的 DDD 开发模式越来越被人提倡。所以，我打算用两节课的时间，结合一个虚拟钱包系统的开发案例，带你彻底弄清楚这两种开发模式。

考虑到你有可能不太了解我刚刚提到的这几个概念，所以，在正式进入实战项目的讲解之前，我先带你搞清楚下面几个问题：

什么是贫血模型？什么是充血模型？

为什么说基于贫血模型的传统开发模式违反 OOP?

基于贫血模型的传统开发模式既然违反 OOP，那又为什么如此流行？

什么情况下我们应该考虑使用基于充血模型的 DDD 开发模式？

好了，让我们带着这些问题，正式开始今天的学习吧！

什么是基于贫血模型的传统开发模式？

我相信，对于大部分的后端开发工程师来说，MVC 三层架构都不会陌生。不过，为了统一我们之间对 MVC 的认识，我还是带你一块来回顾一下，什么是 MVC 三层架构。

MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整。

比如，现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 Web 项目，基本的分层思路都大差不差。

刚刚我们回顾了 MVC 三层开发架构。现在，我们再来看一下，什么是贫血模型？

实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。

////////// Controller+VO(View Object) //////////


public class UserController {


private UserService userService; // 通过构造函数或者 IOC 框架注入

  


  public UserVo getUserById(Long userId) {


    UserBo userBo = userService.getUserById(userId);


    UserVo userVo = [...convert userBo to userVo...];


    return userVo;


  }


}


public class UserVo {// 省略其他属性、get/set/construct 方法

  private Long id;


  private String name;


  private String cellphone;


}


////////// Service+BO(Business Object) //////////


public class UserService {


private UserRepository userRepository; // 通过构造函数或者 IOC 框架注入

  


  public UserBo getUserById(Long userId) {


    UserEntity userEntity = userRepository.getUserById(userId);


    UserBo userBo = [...convert userEntity to userBo...];


    return userBo;


  }


}


public class UserBo {// 省略其他属性、get/set/construct 方法

  private Long id;


  private String name;


  private String cellphone;


}


////////// Repository+Entity //////////


public class UserRepository {


  public UserEntity getUserById(Long userId) { //... }


}


public class UserEntity {// 省略其他属性、get/set/construct 方法

  private Long id;


  private String name;


  private String cellphone;


}


我们平时开发 Web 后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。

从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

什么是基于充血模型的 DDD 开发模式？

刚刚我们讲了基于贫血模型的传统的开发模式。现在我们再讲一下，另外一种最近更加被推崇的开发模式：基于充血模型的 DDD 开发模式。

首先，我们先来看一下，什么是充血模型？

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

接下来，我们再来看一下，什么是领域驱动设计？

领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在 2004 年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。

我们知道，除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。

不过，我个人觉得，领域驱动设计有点儿类似敏捷开发、SOA、PAAS 等概念，听起来很高大上，但实际上只值「五分钱」。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。

实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。

在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。

基于充血模型的 DDD 设计模式的概念，今天我们只是简单地介绍了一下。在下一节课中，我会结合具体的项目，通过代码来给你展示，如何基于这种开发模式来开发一个系统。

为什么基于贫血模型的传统开发模式如此受欢迎？

前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。

我们前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，我总结了下面三点原因。

第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。

第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。

第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。

什么项目应该考虑使用基于充血模型的 DDD 开发模式？

既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的 DDD 开发模式呢？

刚刚我们讲到，基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。

你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的 DDD 开发模式就可以呢？

实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。

不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。

业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞。

所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。

如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。

重点回顾

今天的内容到此就讲完了，我们来一起回顾一下，你应该掌握的重点内容。

我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中我把它称为传统的开发模式。之所以称之为「传统」，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。

不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。

课堂讨论

今天课堂讨论的话题有两个。

你做经历的项目中，有哪些是基于贫血模型的传统的开发模式？有哪些是基于充血模型的 DDD 开发模式呢？请简单对比一下两者的优劣。

对于我们举的例子中，UserEntity、UserBo、UserVo 包含的字段都差不多，是否可以合并为一个类呢？

欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (206)

乐

## 为什么贫血模型盛行

下面几项自己都中过招（环境问题和个人问题）：

### 环境问题 ##

* 近朱者赤，近墨者黑

* 大多数人都是模仿别人的代码，而别人的代码基本上都是 demo，没有复杂的业务逻辑，基本是贫血模型

* 找不到好的指导与学习对象

* 接触不到复杂业务项目

* 做 web 项目的，很大一部分就是简单的 CURD，贫血模型就能解决

* 公司以任务数来衡量个人价值

### 个人问题 ###

* 不考虑项目质量属性

* 只关心当前业务，没有意识去思考后期该如何维护和响应业务变更

* 求快不求质

* 个人以任务数来自我满足

* 没有 60 分和 100 分的概念

* 需求分析、设计、编码合为一体

## 如何理解充血模型

先推荐一本书：整洁架构设计

先说一下充血模型中各组件的角色：

* controller 主要服务于非业务功能，比如说数据验证

* service 服务于 use case，负责的是业务流程与对应规则

* Domain 服务于核心业务逻辑和核心业务数据

* rep 用于与外部交互数据

----


额外说一点，业务开发个人倾向于六边形架构，而非传统的三层架构。六边形架构更能体现当下 web 应用的场景

六边形项目结构（根据实际情况自行组织与定义）：

* InboundHandler 代替 controller

* *WebController：处理 web 接口

* *WeChatController：处理微信公众号接口

* *AppController：处理 app 接口

* *MqListener：处理 消息

* *RpcController：处理子系统间的调用

* service 服务于 use case，负责的是业务流程与对应规则

* CQPS + SRP：读写分离和单一原则将 use case 分散到不同的 service 中，避免一个巨大的 service 类（碰到过 8000 行的 service）

* Domain 服务于核心业务逻辑和核心业务数据

* 最高层组件，不会依赖底层组件

* 易测试

* outBoundhandle 代替 rep

* MqProducer：发布消息

* Cache：从缓存获取数据

* sql：从数据库获取数据

* Rpc：从子系统获取数据

----


各层之间的数据模型不要共用，主要是因为稳定性不同，各层数据模型的变更原因和变更速率是不同的，离 IO 设备越近的的稳定性越差，比如说 controller 层的 VO，rep 层的 entity。Domain 层是核心业务逻辑和核心业务数据，稳定性是最高的

----


几个不太容易理解的点（我刚开始碰到的时候很费解）：

* use case 和 核心业务逻辑该如何定义与区分

* 哪些该放到 service 里面，哪些该放到 Domain 中

* rep 是依赖于 service 的，而不是 service 依赖 rep 层

* 业务逻辑是最高层组件（最稳定的），rep 层是底层组件

* 接口能反转依赖关系

----


一剂良药：所有的中间层都是为了解耦

2019-11-27


业余爱好者

一直贫血而不自知

2019-11-27


有铭

我个人认为，充血模型在 web 开发领域不流行的一个根本原因，在于互联网兴起后各种层出不穷的需求变动，以及短命的项目生存周期，充血模型应对复杂业务确实很有优势，但是这是建立在复杂业务本身其实相对稳定上，比如银行的业务，虽然复杂，但是其实很稳定。但是要是换在互联网，今天改需求明天改需求，甚至很多时候根本就是推倒了重来的需求，充血模型面对这种状态，根本是力不从心的

2019-11-27


李小四

设计模式_10

# 问题:

- 1. 做的 Android 项目更多，Android 开发也是经历了 MVC==>MVP (依然是一种 MVC 架构)==>MVVM 的模式演进。类 MVC 模式比较多，在 UI 相关的开发中，只用过贫血模式 (之前也尝试过使用充血模式，但考虑到不一致带来的成本就放弃了)；在 UI 无关的复杂服务类开发中，也用过充血模型 (虽然我不知道它叫充血模型)。我认为贫血模型的优点是更容易看懂，充血模型的优点是更能应对复杂业务。

- 2. 我认为还是不要放在同一个类中，原因是：成本大于收益。成本：一个复杂的类，在被不同的模块调用时充当着不同的角色，甚至，不同的模块调用不同的字段，需要大篇幅的文档来描述这些差异。稍有修改，复杂度的增加非线性。优点：代码重用。

# 感想:

软件开发处理的是工程学问题，解决方案依赖场景，一个新技术的火爆一定是解决了当前主流场景的痛点问题，随着规模和复杂度的变化，场景也随之变化；争论贫血模式更好还是充血模式更好，争论哪个开发语言更好，这样的问题都是伪命题，我们更应该投入精力的是为当前场景选择最合适的解决方案。

2019-11-27


墨雨

老师，我平常做 web 开发都是，entity,dao,service,controller. 对 vo,bo 不是很理解，也没有用到。有没有 demo 呢？

作者回复：我抽空写个 demo，放到我的 github 上吧

https://github.com/wangzheng0822


2019-11-27


╭(╯ε╰)╮


个人感觉业务被贫血模型绑架的另一个原因是以前缓存 nosql 这些技术不不成熟 刚毕业那会哪有什么 redis，机器的内存也不多。都是公司堆在角落的旧机器。一些业务如果在 domain 里实现可能会 hold 住数据库中的大部分数据。所以业务上都需要翻译成 sql 的 where 和 join 来减少网络和内存的开销。功能都被 sql 抢了去，想充血也充不起来。现在随便开个项目不带个 redis 老板都会质疑一下。mysql 的访问也都是能少就少，不行再多加几台云服务器。老板也显得更有面儿。

2019-11-27


丶 Zero 灬

我们公司的 ERP 系统使用的是贫血模型，支付系统由一个 OOP 的忠实践行者设计的，使用的是充血模型。两个系统我都有在维护，先说 ERP。遇到新需求的时候，就像老师说的 SQL 驱动。从后往前返回数据。简单的需求还好，像一些复杂的模块。看着 service 一个方法动辄几百，甚至出现过上千行的。真心感觉改不动。在业务还比较简单的时候贫血模型还够用，但随着业务发展，service 层越来越重。这时还不做封装抽象，系统真心不好维护。很多时候都要依靠老员工的讲解。而，支付系统，在开发新功能的时候，因为封装抽象已经做的很好，改动起来还是蛮愉快的。没有那么多的重复性代码。不过，因为封装的太多太深，在刚接手的时候确实不好读。业务逻辑逻辑分散在各处。当然，也可能是本人水平有限。

2019-11-28


lizi


沙发，不睡觉，听课。哈哈，加班好累，

2019-11-27


Geek_Zjy


看到「领域驱动设计有点儿类似敏捷开发、SOA、PAAS 等概念，听起来很高大上，但实际上只值「五分钱」。」时，不知道引起了多少人的共鸣，O (∩_∩) O~。做技术的本身就经常会遇到沟通问题，一些人还总喜欢「造概念」，唯恐别人听懂了，争哥这句话无疑说中了我们的心坎儿。

当然我这里也不是说 DDD 不好（看后面的争哥也没这个意思），但是每个理论都有自己的局限性和适用性，看很多文章在讲一些理论时，总是恨不得把自己的理论（其实也算不得自己的）吹成银弹，态度上就让人很难接受。

我还是喜欢争哥的风格，逻辑很清晰，也很严谨，很务实。

关于老师的问题。

说句实话，我们就没有写过充血模型的代码。

我们会把 UserEntity、UserBo 混着用，UserBo 和 UserVo 之间转换时有时还会用 BeanUtils 之类的工具 copy 。

对于复杂的逻辑，我们就用复杂 SQL 或者 Service 中的代码解决。

不过我在翻一些框架时，比如 Java 的并发包时不可避免的需要梳理 Lock、Condition、Synchronizer 之间的关系。比如看 Spring IOC 时，也会需要梳理围绕着 Context 、 Factory 展开的很多类之间的关系。

就好像你要「混某个圈子」时，就不可避免的「拜码头」，认识一堆「七大姑八大姨」，然后你才能理解整个「圈子」里的关系和运转逻辑。

我也经常会有疑问，DDD 和面向对象究竟是什么关系，也会猜想：是不是面向对象主要关注「圈子」内的问题，而 DDD 主要关注「圈子」之间的问题？有没有高手可以回答一下。

（其实我最近一直都想订隔壁 DDD 的课，但是考虑到精力的问题，以及担心学不会，主要不是争哥讲 O (∩_∩) O~，所以没下手）

作者回复：哈哈，多谢认可，我写这篇文字的时候，还害怕搞 DDD 的人会来骂我，看来是我多虑了。隔壁的 DDD 课程可以去学下，管它是不是我写的，看看他咋「吹」的也好。

2019-11-27


Lrwin


我觉得代码架构和业务架构一样，只要将关注点分离就可以。

简单的系统，困难的不在于领域的拆分，而在于时间成本的控制。从软件工程角度考虑，时间，成本，范围三角理论可以进行分析、。

我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。

复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。

DDD 模型其实无异，都是将 Model 层做重。因为业务核心是技术无关的。传统 MVC 用于 C/S 模型，也依然是重 Model 层的。我觉得软件设计的方法没有变化，只是大家看到的视角不同罢了。

软件架构有两个含义：1. 参与的元素有哪些 2. 元素间的关系是什么。从抽象角度来看，非常简单。

2019-11-27


小晏子

基本上经历过的 web 项目都是基于贫血模型开发模式的，entity，bo，vo 不能放在一个类里，每个对象的应用场景不同，entity 是映射数据库字段的，bo，vo 适合业务和展示相关的，而且 entity 相对来讲变化不多，bo，vo 可能会频繁变化，所以不适合放在同一个类里

2019-11-27


梦倚栏杆

第一个还没有太多的感受，还需要时间来练习感受

第二个是否合成一个各有优劣，可能还是和写代码人的功底有关：

拆分开的优势：各层的防腐隔离，当前层的变化不影响其他层。

拆分开的劣势：来一个迭代需求，比如需要加一下邮箱等，rd 很有可能在三个类里各加一个字段，从上改到下，完全看不出隔离的优势，就看不到了一层层的类转换

反过来就是不拆分的优劣

2019-11-27


深度·仁

一拍大腿，靠，说到心坎里去了，各种细碎的 sql，就为了解决某个小功能！ 业务熟悉，领域驱动设计就是屠龙刀，业务不熟悉，DDD 也就值个半毛钱！茶不思，饭不想，期待后面的文章更新

2019-11-28


grey927


能否用代码表达一下充血模型，其实还是不太理解

作者回复：下一节课有的

2019-11-27


花儿少年

有本书叫 ddd 原则，模式与实践可以翻阅一下

首先要明白一点 ddd 适用范围，多数业务就是 CRUD 就可以搞定，理解起来也没有困难，为啥不继续用贫血模型。

充血模型就像老师说的需要精心设计，以应对变化，如果没有一个复杂的业务场景就根本用不到，或者说用起来很难受是一个似是而非的东西。

况且充血模型只建议用在核心域，还有通用域和支撑域呢，不要一上来就 ddd

2019-11-27


Lonely 绿豆蛙

最近边看边重构自己的项目，感觉真的是从码农视角转到了架构师层次～

2019-11-28


Ant


有哪些同学像我一样，是个移动端开发，也在学设计模式

2019-12-03


编程界的小学生

1. 一直贫血模型，却没有发现。

2. 充血模型我有点没看懂，我粗糙的理解成把贫血模型的 service 里面的复杂业务逻辑都搬到了 domain，然后 service 简单调用 domain 即可。那 domain 里不也是业务逻辑 + bo. 吗？还有复杂的 sql 无法复用问题，我一般写业务都是单表。然后放到 service 层调用多个 dao 去组装最终的数据出来。这样可以解决乱七八糟的 sqlz 吗？希望争哥解答下。

3. 第二道问题，我觉得不能合并，因为首先 entity 是对应的数据表字段，其次 bo 可能被多个业务方法所使用，返回的字段可能不同，这就需要 vo 来限制具体每个接口需要哪些字段来响应给客户端。

2019-11-28


杨树敏

回想起来经历的互联网项目一直都是贫血模型，究其原因:

1. 互联网项目多采用敏捷开发，需求多变，设计充血模型的性价比低；

2. 互联网小产品业务场景相对简单，业务难点更多的出现在并发，性能上，在存储，内存成本急剧下降的当下，粗暴的横向扩展成为见效更快的选择.

2019-11-28


追风少年

1. 以前做的项目都是基于贫血模型的，这次的话涉及风控业务，也是基于贫血模型，但是各种问题不断，正在考虑优化，这里刚好看到老师的文章，希望能有所借鉴。

2. Entity 是 ORM 中数据库映射的实体类，BO 是业务操作相关实体类，VO 是视图层对应实体类。在简单情况下，这三个类可能是一样的，比方说你填写一个登陆注册的表单，此时前端传给后端接口的数据，一般就是 VO，而通过业务层 Service 操作，加入创建时间，IP 地址等，就转换成了 BO，最后对应到数据层就转换为了 Entity，也许一次注册可能需要写多个库，就会生成多个 Entity。

有些复杂业务，还有 DO,DTO，PO 之类的概念，但是个人感觉很模糊，也不是很了解。这里希望老师能指点一下。

作者回复: DTO：data transfer object，是一种更抽象的概念，这种数据类型可以是贫血模型的，主要是用在接口之间传递数据。

其他的两个没听说过：《

2019-11-27


饭太司替可

项目中用到了 google 的 ProtocolBuffer，根据数据结构体生成的类模型只能包含数据，不能包含方法。这种情况也是贫血模型吧。

作者回复：是的

2019-12-19


Geek_53aa5c


Ruby on Rails 的 model 层，ActiveRecord 是很好的充血模型实现，借助 Ruby 语言动态的特性，CRUD 以及属性映射不需要写一行代码一行配置文件就可以开箱即用，所以没有必要有 repository 这一层。

2019-12-04


(´ 田 ω 田 `)

第二题，不合并有好处。UserEntity 是具体到数据库的，假如有不同版本的 UserEntity，相互之间有少部分不同，抽象出一个 BO 层在 Service 层做 UserEntity 到 BO 的转化，可以方便 Bo 在 Service 层传播，方便不同项目之间复用、统一处理；再往上抽象出的 VO，一般通过接口返回给前端展示，也可以是多种有差异的 BO 转化为同一种 VO 方便前端统一处理

2019-11-27


_呱太_

小争哥，对设计模式这些概念都有了解，一直想找一些源码来看看顺便练下手，请问下有没有推荐的 C++ 比较经典的开源代码呢

2019-11-28


条

争哥，对 MVC 的认识，感觉不是太统一呀，表示层、逻辑层、数据层应该是三层架构的分层概念吧，MVC 的 M-Model 可以近似的看做逻辑层和数据层的加和，V-View 近似看做表示层，C-controller 是个桥梁。

2019-11-28


tang


是否可以采用组合的方式，来减少重复字段？

作者回复：可以的

2019-11-27


DullBird


1. 目前基本都在接触贫血开发模型，充血的可能局部模块设计的时候，会把数据和方法组织到一个类里面去。但是 DB 的操作完全隔离。

这里有一个问题：充血模型的话，OOP 的想法，应该是每个人 (假设人是类，具体的人就是人这个类的实例化) 管理自己的属性，比如我的主管。

这个时候有一个需求。批量修改人员的主管。那么充血模型是要遍历委托给每个具体的人自己去修改呢？还是提供一个 service，直接批量操作 DB。

2. entity,bo,vo 我的做法是不合并，但是真的有贯穿三层的模型。那么就直接用一个。但是要单独分包。并且组内规范好这个包里面的东西都是有修改风险的。我个人倾向用麻烦换容错。毕竟软件的变化性比较大

作者回复: 1. 充血模型并不是哪都适用

2. 赞成你的看法

2019-11-27


阿卡牛

最近在看消息队列的专栏，里面有提到 Pulsar 这个产品采用了存储与计算分离的设计。本质上和文中提到的数据与操作分离应该是一个意思吧？难道也是一种面向过程的设计

作者回复：存储本身有自己的逻辑在那里面，不能单独的看做是数据。

2019-11-27


成葛格

这么说来我所有的项目都是基于贫血模式的；现实的开发中就是把三个 VO 都合成一个的。不知道会有什么问题？

作者回复：如果三个 object 需要的字段不是完全一样的，该咋办呢

2019-11-27


十二差一点

MVC 是面向过程编程，是因为它违反了封装的特性，数据和逻辑操作分离开了，在 controller 进行相关数据逻辑操作，而 model 仅仅只是个数据层，没有任何操作。而 MVVM 是面向对象编程，因为它把数据和其相关逻辑操作封装在了 viewModel，只暴露给外部相关方法，controller 想要获取数据直接通过这些方法就行了，不用像 MVC 在 controller 层进行一堆逻辑操作，同时减轻了 controller 的代码，在 viewModel 也方便维护数据逻辑操作。不知道这样的理解对不对？

作者回复：恩恩 可以这么理解

2019-11-27


安静

要是有代码例子就好了。实操性会强很多。

作者回复：一看就是没认真看文章，文章说了例子在下一节课中有的

2019-11-27


默

我经历的所有的项目都是贫血模型，对于充血模型没尝试过，如果说业务数据与业务操作分离，那么在设计接口时如何将繁多的业务属性当成参数传入给接口方法呢？是说将所有属性的 getter 和 setter 直接生成在接口中吗？那么对于接口中使用这些零散的属性是怎样使用的呢？觉得二者确实还得从实际情况出发，看业务复杂度及对代码设计是否有要求，但往往都是为了习惯、速度而忽略了设计初心。

对于三类对象是否合并成一个，我上次的留言就正好说了这个问题，确实很难判别，起初是分开三个对象，但是为了所谓的分层、隔离干净避免耦合，都没有体现，在业务调整方面分开 3 个对象并没体现优势，可能是我参与的项目都比较简单，基本上不涉及到需要解耦来进行代码的扩展性调整，反而是增减改属性比较频繁，这样就涉及到一位同学说的，一下修改 3 个对象而且最好属性值的复制，如果是用委托就不说了，如果不是委托，那么属性值复制多数依赖 BeanUtils 类通过类反射完成，还要保证属性类型的一致性；如果用委托，那么意味着 3 个对象的组合难免又是对分层上的一个污点。所以我觉得两者适用在不同的设计要求、团队人员的一往习惯以及项目的目标，如果公司涉及的项目没有那么复杂、设计要求不高，我更倾向于合并为一个。

2019-11-27


sundy


老师 我有一个困惑很久的问题，

1 dao 层的设计到底是对应一个业务的所有数据库操作还是对应一个数据库表的 curd？

2 如果按照业务创建 dao，除了一定的解藕外，dao 层存在的意义更多是抽离 service 层的代码，如果按照数据库表设计 dao，那联表查询的逻辑应该写在哪？

2020-03-31


刘嘉璐

在我开发的项目中几乎很少有用到 BO，只有 VO+Entity (DTO)，他俩是继承关系，VO 继承 Entity (DTO)。

前端有新增字段的需求，那就在 VO 新增字段，如果要屏蔽某些字段，就用 @JsonIgnore。

不知道有多少兄台跟我类似，这样的话开发比较快，便捷，但是确实违背了 OOP 的原则😂

2020-01-19


Pioneer4


目前所接触的项目都是以 MVC 框架为基础开发的，的确都是贫血模型的传统开发模式，没有去意识到还有 DDD 开发模式，今后留心。

2020-01-03


查理

Domain 是否只处理与自己有关的业务逻辑？如果是的话，有些业务需要多个 Domain 才能完成，还是要把大量业务代码放到 Service 中去；如果不是的话，那 Domain 处理很多与自己无关的业务逻辑，是否不符合 DDD 的思想？

2019-12-17


爱喝酸奶的程序员

一直贫血…… 我们的代码一直都是一点点修改就写 SQL, 但是感觉只是提了充血模式的长处…… 没有一个例子有点空洞

作者回复：下一节课有例子的

2019-12-06


Bolin


我们项目像是充血和贫血的结合体。涉及不是很烦复杂的业务基本上 Repository 这一层只跟单表操作。也就是只针对一张表的 CRUD，业务逻辑在 service 这一层。这样也可以实现代码的重用。但是 entity，domain 实体大多时候只是做一个数据的传递功能。老师这种算充血模式的 DDD 吗？

作者回复：感觉更像贫血模型😂

2019-12-02


Michael


说一说我的经历吧，现在就在银行工作。之前做一个新系统，组长说我们用 DDD 模式来开发吧，大家都不熟，摸索着搞了一周，最后项目要在在几号几号上线，根本没有多余的时间让你慢慢设计，一句话，几号能不能正常上线，DDD 花了一周时间难产了，只能老办法贫血模型快速搞定，先上线。若不能正常上线，业务才不管你贫血还是充血呢。所以，有些时候用什么模型真的是跟指标跟任务挂钩的，精心设计需要更多的时间，没有时间，只能粗暴的尽快搞定，后面就是还各种还技术债。

2019-11-30


🐾mc🐾


文档 review：基本的分层思路都大差不差。—》基本的分层思路都差不多。

2019-11-29


阿卡牛

个人觉得想搞 DDD 也要看项目的发展和团队成员的能力。

先贫血，有钱了再充血：)

2019-11-29


程序员人生

感觉一点点在为引入设计模式做准备

2019-11-27


Monday


1、收获：简简单单就解释了贫血（数据与业务分开），充血（数据与业务一起）

2、真实项目做了十来个，一直是贫血模式，包括曾经做过的复杂的金融系统也都是贫血模式

3、思考题 2：不能合并，理由：BO 很多时间都是多个 Entity 的复杂组合起来的。

2019-11-27


燕行

个人感觉，本节课中贫血与充血模型的讲解，如果配图进行比较，可能会更加直观

2019-11-27


路伴友行

MVC 其实是表现层的架构模式，是对同一个数据的不同表现，不知道为啥来到了服务器端 又流行了起来

2019-11-27


拂尘

老师，我还是学生，然后学的 web 架构里面我只知道实体类，那个 vo，bo，和 entity 为什么需要定义三个啊，不是用一个实体类就可以了嘛？

作者回复：因为是用到不同层的。每一层中的 object 包含的字段可能都不大一样，所以要区分定义。如果一个 object 贯穿所有层，本身有违反封装。

2019-11-27


迁橘

看完了，感觉热血沸腾，特别期待下一节课.

课堂讨论:

1, 自己所参与做的项目中都是典型的基于贫血模型开发模式.

2, 我是基本都用一个类的，因为所做的系统业务想比较简单，也就没必要，还有些共用的属性字段会拿出来，用继承的方式。基本项目都是这么过来的。也没遇到啥问题，(大家勿笑哈)

从第一节课听到现在，受益匪浅，每节课都会听个 3-5 遍。到现在，基本能意识到自己在工作种存在的一些问题，以及需要提升进步的地方，期待后面的课程....

作者回复: （づ￣3￣）づ╭❤～

2019-11-27


carol


问个小白问题。请问下，什么是业务？怎么来评判业务复杂不复杂呢？

作者回复：业务是否复杂不好定义，只能考经验来判断。

2019-11-27


Eden Ma


移动端的 MVVM 和 MVP 算是充血吗？

作者回复：看完下一节课你再看看是否有答案了

2019-11-27


Dimple


1. 针对第一个问题，我就和楼上的很多同学一样，是一直在贫血的世界里不亦乐乎，丝毫没有体会过充血的愉快感。但是，现在自己有一个小打小闹的项目开启，虽然已经做了点，但是现在开始修正还来得及，准备尝试下用充血的模型，跟上老师的实战节奏。

2. 针对第二个问题，我还是倾向于不合并。虽然目前看来大部分字段是差不多的，但是万一后面内容扩展了，功能扩展了，有特殊处理相关的呢？

设计模式的课程真的是值得品味好几次，每次学习的时候，生怕上次的内容没有仔细看完，而跟不上当节课的内容，有点忐忑。老师的内容循序渐进，对于我这个职场比菜鸟稍微好点的鸟来说，都是一句句精辟的话语，打开了我很多平时看到的心结，也指出了我平时开发中的很多不足，原来我一直在落后的时代写代码。

所以，如何摆脱我的上古时代的开发模式，就是紧跟着老师的步伐走。虽然一开始说 8 个月的时间，但我觉得，8 个月一晃就过去了，保持这个节奏，很赞。

作者回复：多读几遍，收获会不一样的。加油！

2019-11-27


被水淹没

我觉得，简单的贫血模型可以不区分 BOVO，直接把 DO 直接 set 到 ResultData 然后就丢给前端，区分各个 pojo

如果分领域的话，区分各类 pojo 是有必要的

老师您觉得呢

作者回复：要区分一下的，可以看下其他小伙伴的留言，有的讲的很好

2019-11-27


清风自来

老师，我有个问题，一直在疑问中，重 domain 轻 service，那哪些业务应该写在 service 哪些应该写在 domain 呢？如果是有两个服务，一个订单服务，一个商品服务。我订单服务中需要商品信息支撑。调用商品服务的这个过程应该在 domain 还是在 Service。如果在 Service 层，我是不是可以这样理解 Service 层应该处理的业务。1. 构建 domain (包括调用服务获取构建信息)。2. 调用 domain.do ()，做业务处理。3. BO 转化 DO。4. 调用 Repository 存 DO？

作者回复：下一节课中有讲到你提到的问题的

2019-11-27


噶哈捏

差别不大 sql 满天飞在最近的系统开发中就遇到了😂

2019-11-27


Geek


打卡✔

看完本节，感触颇深，在平常开发中越发的感觉到代码的复用性不够，往往自己意识不到自身的问题，听完本讲，大概知道问题的关键出在哪里，更加期待后续内容。

问题 1，我经历的项目都是贫血模型，开发起来快速，复用性太差，越来越有这种感触。

问题 2，理论上基于贫血模型合并用一个问题不大，要是 (DDD) 要分开。

2019-11-27


cw


但是很多系统被设计之初都没有思考太多服务领域问题。。都随着业务走，然后业务耦合 贫血

2020-07-15


御风

现在的项目分为 controller、facade、service、dao 四层，facade 和 service 两层的具体分工是什么？需要共用 BO 还是有各自的 BO？

作者回复：一般没有 facade 吧，如果有的话，应该是在 controller 层之上的吧，而不是在 service 层之上吧

2020-07-04


BruceMaNo1


1. 目前经历的项目中，没有基于充血模型来开发的，都是贫血模型，快速开发迭代上线，设计简单，出现重复代码这种事，倒也不是全部贫血模型的锅，有些业务逻辑开发时就是复制粘贴再修改一点东西，所以，代码复用这种事，与哪个模型无关，与开发人员自身有关

2. 几个类不能合并为一，每个类都有对应交互使用的地方，虽然看着一样，但在业务中可能会存在些微的差异，而且概念不同，这样分开写逻辑层次更清晰些

2020-06-28


我很皮信不信

每次开始搭建一个 web 项目的时候，总是想 entity、bo、vo 如何处理的问题。比如最近刚开始做的一个电商项目，我就一个 vo 行天下了（考虑到基本上就是 crud，这几个都长得差不多，如果三层直接都转一次，会非常麻烦与浪费资源）。但是总是觉得带来了很大的耦合，就像 constants、utils 之类的东西到处引用。还有关于 service 同层之间是否可以相互调用、repository 到处引用等等问题，不懂如何做分离封装，深深困扰，有没有朋友给点建议

2020-06-12


