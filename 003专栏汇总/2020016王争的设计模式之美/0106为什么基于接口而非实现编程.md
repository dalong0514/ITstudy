# 0106. 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

王争 2019-11-22

在上一节课中，我们讲了接口和抽象类，以及各种编程语言是如何支持、实现这两个语法概念的。今天，我们继续讲一个跟「接口」相关的知识点：基于接口而非实现编程。这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。

为了让你理解透彻，并真正掌握这条原则如何应用，今天，我会结合一个有关图片存储的实战案例来讲解。除此之外，这条原则还很容易被过度应用，比如为每一个实现类都定义对应的接口。针对这类问题，在今天的讲解中，我也会告诉你如何来做权衡，怎样恰到好处地应用这条原则。

话不多说，让我们正式开始今天的学习吧！

如何解读原则中的「接口」二字？

「基于接口而非实现编程」这条原则的英文描述是：「Program to an interface, not an implementation」。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的「接口」语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。

实际上，理解这条原则的关键，就是理解其中的「接口」两个字。还记得我们上一节课讲的「接口」的定义吗？从本质上来看，「接口」就是一组「协议」或者「约定」，是功能提供者提供给使用者的一个「功能列表」。「接口」在不同的应用场景下会有不同的解读，比如服务端与客户端之间的「接口」，类库提供的「接口」，甚至是一组通信的协议都可以叫作「接口」。刚刚对「接口」的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，「基于接口而非实现编程」这条原则中的「接口」，可以理解为编程语言中的接口或者抽象类。

前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

实际上，「基于接口而非实现编程」这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

如何将这条原则应用到实战中？

对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。

假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：

public class AliyunImageStore {


//... 省略属性、构造函数等...

  


  public void createBucketIfNotExisting(String bucketName) {


//... 创建 bucket 代码逻辑...

//... 失败会抛出异常..

  }


  


  public String generateAccessToken() {


//... 根据 accesskey/secrectkey 等生成 access token

  }


  


  public String uploadToAliyun(Image image, String bucketName, String accessToken) {


//... 上传图片到阿里云...

//... 返回图片存储在阿里云上的地址 (url）...

  }


  


  public Image downloadFromAliyun(String url, String accessToken) {


//... 从阿里云下载图片...

  }


}


// AliyunImageStore 类的使用举例

public class ImageProcessingJob {


  private static final String BUCKET_NAME = "ai_images_bucket";


//... 省略其他无关代码...

  


  public void process() {


Image image = ...; // 处理图片，并封装为 Image 对象

AliyunImageStore imageStore = new AliyunImageStore (/* 省略参数 */);

    imageStore.createBucketIfNotExisting(BUCKET_NAME);


    String accessToken = imageStore.generateAccessToken();


    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);


  }


  


}


整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。

不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？

我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，「细节是魔鬼」。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的「魔鬼细节」，我们一块来看看都有哪些。

新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。

首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun () 和 downloadFromAliyun ()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含「aliyun」字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun ()、downloadFromAliyun () 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。

其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken () 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken () 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。

那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从「基于接口而非实现编程」的原则，具体来讲，我们需要做到下面这 3 点。

函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun () 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload ()。

封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。

为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。

我们按照这个思路，把代码重构一下。重构后的代码如下所示：

public interface ImageStore {


  String upload(Image image, String bucketName);


  Image download(String url);


}


public class AliyunImageStore implements ImageStore {


//... 省略属性、构造函数等...

  public String upload(Image image, String bucketName) {


    createBucketIfNotExisting(bucketName);


    String accessToken = generateAccessToken();


//... 上传图片到阿里云...

//... 返回图片在阿里云上的地址 (url)...

  }


  public Image download(String url) {


    String accessToken = generateAccessToken();


//... 从阿里云下载图片...

  }


  private void createBucketIfNotExisting(String bucketName) {


//... 创建 bucket...

//... 失败会抛出异常..

  }


  private String generateAccessToken() {


//... 根据 accesskey/secrectkey 等生成 access token

  }


}


// 上传下载流程改变：私有云不需要支持 access token

public class PrivateImageStore implements ImageStore  {


  public String upload(Image image, String bucketName) {


    createBucketIfNotExisting(bucketName);


//... 上传图片到私有云...

//... 返回图片的 url...

  }


  public Image download(String url) {


//... 从私有云下载图片...

  }


  private void createBucketIfNotExisting(String bucketName) {


//... 创建 bucket...

//... 失败会抛出异常..

  }


}


// ImageStore 的使用举例

public class ImageProcessingJob {


  private static final String BUCKET_NAME = "ai_images_bucket";


//... 省略其他无关代码...

  


  public void process() {


Image image = ...;// 处理图片，并封装为 Image 对象

    ImageStore imageStore = new PrivateImageStore(...);


    imagestore.upload(image, BUCKET_NAME);


  }


}


除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken () 方法。

总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

是否需要为每个类定义接口？

看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？

做任何事情都要讲求一个「度」，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。

前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。

从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。

重点回顾

今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。

1.「基于接口而非实现编程」，这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

2. 我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

3.「基于接口而非实现编程」这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的「接口」设计、类库的「接口」设计。

课堂讨论

在今天举的代码例子中，尽管我们通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第 8 行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美，对此，你有更好的实现思路吗？

// ImageStore 的使用举例

public class ImageProcessingJob {


  private static final String BUCKET_NAME = "ai_images_bucket";


//... 省略其他无关代码...

  


  public void process() {


Image image = ...;// 处理图片，并封装为 Image 对象

ImageStore imageStore = new PrivateImageStore (/* 省略构造函数 */);

    imagestore.upload(image, BUCKET_NAME);


  }


欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (216)

zeta


其实这篇和上一篇可以讲的更好的。首先，我反对接口是 has-a 的说法，我坚持接口的语义是 behaves like (这个其实我也是在某一本书上看的). 咱们看下哪个更通顺和达意，A AliyunImageStorage has a DataStorage. or A AliyunImageStorage behaves like a DataStorage? 除非你在第一句加上 A AliyunImageStorage has some behaviors of DataStorage. 但这基本也就是 behaves like 的意思了。

第二，我觉得咬文嚼字的确没有什么意义，但为什么说上述话题，难道讲接口的例子不用出现接口多重继承么，引用我之前留言：拿一个 C++ 中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼 is a 蝙蝠么？吸血鬼 is a 人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了 is a 的另一个概念，behaves like，也就是多重继承的真义实际上是 behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。

所以其实也就是说，只有当前模块涉及到抽象行为的时候，才有必要设计接口，才有可能利用接口多重继承的特性来更好的将各种行为分组。

2019-11-22


helloworld


到目前为止老师所讲理的的理论都懂～至于思考题用简单工厂，反射等方式感觉都不行。给老师提个小小的建议：能不能和隔壁的『MySQL 实现 45 讲』的专栏一样在下一节课程的末尾集中回答一下上一节课程的课后习题？感谢

2019-11-23


业余爱好者

关于抽象和函数命名的问题，不知道哪个大佬说过这么一句话:

每个优秀的程序员都知道，不应该定义一个 attackBaghdad () ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack (city)。

2019-11-22


香蕉派 2 号

思考题

解决方案 = 配置文件 + 反射 + 工厂模式

2019-11-22


辣么大

关于思考题我想出两种方法改进：简单工厂方法和使用反射。

1、简单工厂方法

ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);


config 文件可以写类似 properties 的文件，使用 key-value 存储。

缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放 - 封闭原则。

那有没有更好一点的方法呢？

2、使用反射。

在配置文件中定义需要的 image store 类型。

在 ProcessJob 中

ImageStore store = (ImageStore) Class.forName(STORE_CLASS)


    .newInstance();


缺点：使用反射，在大量创建对象时会有性能损失。

关于减少 ProcessJob 中的修改，还有没有更好的方法呢？我只是抛砖引玉，希望和大家一起讨论。具体实现：https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u009

补充：

关于 access token：Aliyun 的 AccessToken 时有 expireTime 时限的。不需要每次重新获取，过期时重新获取即可。

2019-11-22


秋惊蛰

依赖注入，从外部构建具体类的对象，传入使用的地方

2019-11-22


编程界的小学生

首先这篇文章受益匪浅，尤其是第二点，与特定实现有关的方法不要暴露到接口中，深有体会。

其次问题解答

我个人的解决方案是这种情况不要去直接 new，而是用工厂类去管理这个对象，然后名字可以起成 getInstance 这类不包含某个具体实现的含义的抽象名称。将来修改直接修改工厂类的 getInstance 方法即可，这种方式可取吗？还有其他更好的方式吗？求老师点评。

2019-11-22


失火的夏天

思考题估计就是要引出工厂模式了吧

2019-11-22


雷霹雳的爸爸

要不是有一开始的课程大纲，我以为课堂讨论是要启发大家，在下节就要讲创建型模式，工厂模式，工厂方法什么的了

但转念一想，这想法或许太肤浅了，毕竟大多数创建型方法都有一个明显的对具体类型的依赖（这里先预先排除抽象工厂，觉得有点小题大做这样搞），都不是一个最终能让人感到内心宁静的做法

这节既然讲的是依赖于抽象而不是依赖于具体，那比较得瑟的玩儿法恐怕应该是直接在 ImageProcessingJob 类和 ImageStore 接口这两个类型关系上充分体现出依赖倒置的思路，把最后一点执行创建 ImageStore 类型实例的痕迹彻底关在 ImageProcessingJob 的门外，虽然必然得有人去考虑实际至少调一下 ImageStore 具体类型实例的这个创建过程，但 ImageProcessingJob 这爷是不打算操心这事了，它只需要留个口子，让别人把 ImageProcessingJob 放到自己锅里，自己就可以开始炒菜了

也就是从形式上，ImageProcessingJob 这个类只需要保留对 ImageStore 接口的依赖就可以了，具体留口子的手段则要考虑依赖注入，形式上有两种：

+ 一种是可能更 OO 样子的一点，即声明一个 ImageStore 的 field 在 ImageProcessingJob 类里面

- 如果说有什么好处，恩，可以理解为能对客户程序隐藏了 ImageStore 类型的信息，是的，连类型信息都隐藏掉；好吧，还是得关心别人，毕竟这世界上不是仅有自己一个

- 具体操作起来，由于不能声明 field 时候直接 new，要不又变回去了，但又不能 NPE 吧，所以不考虑创建，我还是得考虑怎么把实例请进来，就是上面说的至少留个口子

- 这时候可能不得不借助依赖注入的帮助了（否则就是依赖查找，还是工厂），即

- 通过 ImageProcessingJob 的构造函数注入或者利用 field 注入来获取 ImageStore 接口的实例，或者 ImageProcessingJob 如果依赖项多，Builder 一下也很好

- 毕竟 ImageProcessingJob 这个类型在我们讨论的上下文里面是如此具体的一个类，就不过分追溯它的创建责任及执行在哪里了

+ 另一种，表面粗暴直接看似问题多多，但是细品也有点意思的，那就是 process 方法直接增加一个 ImageStore 的参数就完了，OMG 我在干什么

- 没有 B 方案的设计自身无法证明自己更好

- 相对于上面的，直接的问题是会对 process 方法直接依赖的客户程序会和 ImageStore 这个类型产生耦合

* 如果客户程序是一个类（还能是什么？），要么有一个 field 等着 inject 进来，要么是通过调用 process 的 method 传进来，要么就是无中生有（直接 new 了或用创建型模式）

* 这都可能造成没有充分的设计隔离，至少让客户程序造成信息冗余，承担了不必要的职责等问题

- 但事实上也不是完全没好处，这种灵活性体现在它没有把 ImageStore 的逻辑固化在任一个 ImageProcessingJob 实例里面

* 考虑上面第三类无中生有的方式，假设是创建型的工厂方法或类似手段，则可以提供对 method 参数（业务层面的动态输入，例如最终操作用户的提供的值）的响应能力

* 这和，执行排序算法骨架确定，但是需要给定两个元素（复杂对象）比较规则这种思路有相似之处，毕竟我需要的是对方的能力而不是对方的数据或者数据视图，这时候这么做还是很有诱惑力的

- 如果脱离开场景，实际上这种动态性还更强，但问题就在于这种动态性会不会对于具体场景有价值

- 从这个实例上看，也许没这么明显，因为不同的对象存储后端更有可能是环境（测试、生产？但 12 factor 让我们... 好歹测试环境还是也上云吧）不同造成的，而非基于动态的用户信息输入

- 但，事无绝对吧，假设，用户有选择我要针对具体这一张，我特么上传那一刻选择一个存储后端的需求

- 然后为了方便用户，用户竟然可以勾选，以后使用同样地选择...

- 我觉得除了脑子进水的犬类应该没人会干这种没问题制造问题也要上的方案吧

 


所以综上所属，还是 field 一个 ImageStore 接口来搞吧

这极客时间也让人想吐槽，能敲 2000 字，结果就只留这么大点儿一个输入框... 你要不就限制 200 字我还能少敲一点... 我这写的兴起还得外面写完了贴过来...

2019-11-22


守拙

课堂讨论 answer:

考虑使用工厂模式生成 ImageStore 实例。这样就可以将调用者和具体 ImageStore 解耦.

例:

public class ImgStoreFactory {


    private ImgStoreFactory(){


    }


    public static ImageStore create(Class<?> clz){


        if (clz == AliyunStore.class){


            return new AliyunStore();


        }else if (clz == PrivateYunStore.class){


            return new PrivateYunStore();


        }else {


            throw new IllegalStateException("..");


        }


    }


    public static void main(String[] args) {


        ImageStore store = ImgStoreFactory.create(AliyunStore.class);


        store.dosth();


    }


}


另外有一点不太同意作者的说法:

上节课作者将 Contract 翻译为 "协议",

我认为是不恰当的.

在计算机领域，通常使用 Protocol 代表协议.

个人认为 Contract 更恰当的翻译是 "契约".

2019-11-22


William


所以思考题，想到的是，将接口作为构造函数中的参数，传递进来，再调用.

2019-11-22


二星球

使用策略模式，在建一个 Context 类，使用聚合持有这个接口实例引用，其它所有地方都用这个 context 类，变动的时候，只变这个 context 类就行了，其它不动

2019-11-23


姓程名序员

存储图片的方式写入到配置文件，第 8 行改用传入类型参数来实例化不同的对象，明天补上代码。

2019-11-22


Milittle


再说一句 面向接口编程的精髓 我的理解是我们在使用接口的时候 关心我们要做什么 而不是怎么做 怎么做都封装在具体实现类中。而且最主要的是 接口抽象

2019-11-22


Monday


依赖注入可以解决思考题，基于接口的实现有多种时，注入处也需要指明是哪咤实现

2019-11-22


YouCompleteMe


抽象工厂，把创建具体类型放到工厂类里

2019-11-22


bearlu


老师，希望能把示例代码和问题代码也放到 Github 上。

作者回复: 👌 我抽空整理一下放上去

https://github.com/wangzheng0822


2019-11-22


BitInit


对于思考题，想到了两种方法：

1. 简单工厂 + 反射 + 配置

2. 通过使用控制反转 / 依赖注入方式，类似于 Spring

2020-02-03


👽


那现在的 MVC 代码，要求 service 先写接口，然后再写实现，有必要嘛？

说实话，我一直没看懂这种行为的意义何在。

作者回复：确实意义不大

2019-11-25


NoAsk


关于什么时候定义接口的一些拙见：

当方法会有其他实现，或者不稳定的时候需要定义接口；

1. 不稳定的方法一般能事先确定，用接口能提高可维护性

2. 但在开发时往往不确定是否需要其他实现，我的原则是等到需要使用接口的时候再去实现。所以根据 kiss 原则一般我会先用方法实现，如果有一天真的需要有新的实现的时候再重新抽象出接口对代码进行小重构。

就老师的例子进行一下说明：

刚开始只需要阿里云进行图片上传下载功能，我就先只实现阿里云的图片上传下载方法。

后期发现需要有私有云的上传下载方法的话，那就对这个功能通过接口进行抽象。但是你永远不知道到底是新的图片上传下载功能先来到还是其他阿里接口先来到，如果是新的阿里接口，也是用的这一套 token 方法，那就用抽象方法或接口对 token 部分实现抽象。

课后问题：

简单工厂，工厂模式可以提高可扩展性，维护性。

java spring 项目可以使用注入的方式。

2019-11-22


zeta


其实这篇和上一篇可以讲的更好的。首先，我反对接口是 has-a 的说法，我坚持接口的语义是 behaves like (这个其实我也是在某一本书上看的). 咱们看下哪个更通顺和达意，A AliyunImageStorage has a DataStorage. or A AliyunImageStorage behaves like a DataStorage? 除非你在第一句加上 A AliyunImageStorage has some behaviors of DataStorage. 但这基本也就是 behaves like 的意思了。

第二，我觉得咬文嚼字的确没有什么意义，但为什么说上述话题，难道讲接口的例子不用出现接口多重继承么，引用我之前留言：拿一个 C++ 中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼 is a 蝙蝠么？吸血鬼 is a 人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了 is a 的另一个概念，behaves like，也就是多重继承的真义实际上是 behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。

所以其实也就是说，只有当前模块涉及到抽象行为的时候，才有必要设计接口，才有可能利用接口多重继承的特性来更好的将各种行为分组。

2019-11-22


helloworld


到目前为止老师所讲理的的理论都懂～至于思考题用简单工厂，反射等方式感觉都不行。给老师提个小小的建议：能不能和隔壁的『MySQL 实现 45 讲』的专栏一样在下一节课程的末尾集中回答一下上一节课程的课后习题？感谢

2019-11-23


业余爱好者

关于抽象和函数命名的问题，不知道哪个大佬说过这么一句话:

每个优秀的程序员都知道，不应该定义一个 attackBaghdad () ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack (city)。

2019-11-22


香蕉派 2 号

思考题

解决方案 = 配置文件 + 反射 + 工厂模式

2019-11-22


辣么大

关于思考题我想出两种方法改进：简单工厂方法和使用反射。

1、简单工厂方法

ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);


config 文件可以写类似 properties 的文件，使用 key-value 存储。

缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放 - 封闭原则。

那有没有更好一点的方法呢？

2、使用反射。

在配置文件中定义需要的 image store 类型。

在 ProcessJob 中

ImageStore store = (ImageStore) Class.forName(STORE_CLASS)


    .newInstance();


缺点：使用反射，在大量创建对象时会有性能损失。

关于减少 ProcessJob 中的修改，还有没有更好的方法呢？我只是抛砖引玉，希望和大家一起讨论。具体实现：https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u009

补充：

关于 access token：Aliyun 的 AccessToken 时有 expireTime 时限的。不需要每次重新获取，过期时重新获取即可。

2019-11-22


秋惊蛰

依赖注入，从外部构建具体类的对象，传入使用的地方

2019-11-22


编程界的小学生

首先这篇文章受益匪浅，尤其是第二点，与特定实现有关的方法不要暴露到接口中，深有体会。

其次问题解答

我个人的解决方案是这种情况不要去直接 new，而是用工厂类去管理这个对象，然后名字可以起成 getInstance 这类不包含某个具体实现的含义的抽象名称。将来修改直接修改工厂类的 getInstance 方法即可，这种方式可取吗？还有其他更好的方式吗？求老师点评。

2019-11-22


失火的夏天

思考题估计就是要引出工厂模式了吧

2019-11-22


雷霹雳的爸爸

要不是有一开始的课程大纲，我以为课堂讨论是要启发大家，在下节就要讲创建型模式，工厂模式，工厂方法什么的了

但转念一想，这想法或许太肤浅了，毕竟大多数创建型方法都有一个明显的对具体类型的依赖（这里先预先排除抽象工厂，觉得有点小题大做这样搞），都不是一个最终能让人感到内心宁静的做法

这节既然讲的是依赖于抽象而不是依赖于具体，那比较得瑟的玩儿法恐怕应该是直接在 ImageProcessingJob 类和 ImageStore 接口这两个类型关系上充分体现出依赖倒置的思路，把最后一点执行创建 ImageStore 类型实例的痕迹彻底关在 ImageProcessingJob 的门外，虽然必然得有人去考虑实际至少调一下 ImageStore 具体类型实例的这个创建过程，但 ImageProcessingJob 这爷是不打算操心这事了，它只需要留个口子，让别人把 ImageProcessingJob 放到自己锅里，自己就可以开始炒菜了

也就是从形式上，ImageProcessingJob 这个类只需要保留对 ImageStore 接口的依赖就可以了，具体留口子的手段则要考虑依赖注入，形式上有两种：

+ 一种是可能更 OO 样子的一点，即声明一个 ImageStore 的 field 在 ImageProcessingJob 类里面

- 如果说有什么好处，恩，可以理解为能对客户程序隐藏了 ImageStore 类型的信息，是的，连类型信息都隐藏掉；好吧，还是得关心别人，毕竟这世界上不是仅有自己一个

- 具体操作起来，由于不能声明 field 时候直接 new，要不又变回去了，但又不能 NPE 吧，所以不考虑创建，我还是得考虑怎么把实例请进来，就是上面说的至少留个口子

- 这时候可能不得不借助依赖注入的帮助了（否则就是依赖查找，还是工厂），即

- 通过 ImageProcessingJob 的构造函数注入或者利用 field 注入来获取 ImageStore 接口的实例，或者 ImageProcessingJob 如果依赖项多，Builder 一下也很好

- 毕竟 ImageProcessingJob 这个类型在我们讨论的上下文里面是如此具体的一个类，就不过分追溯它的创建责任及执行在哪里了

+ 另一种，表面粗暴直接看似问题多多，但是细品也有点意思的，那就是 process 方法直接增加一个 ImageStore 的参数就完了，OMG 我在干什么

- 没有 B 方案的设计自身无法证明自己更好

- 相对于上面的，直接的问题是会对 process 方法直接依赖的客户程序会和 ImageStore 这个类型产生耦合

* 如果客户程序是一个类（还能是什么？），要么有一个 field 等着 inject 进来，要么是通过调用 process 的 method 传进来，要么就是无中生有（直接 new 了或用创建型模式）

* 这都可能造成没有充分的设计隔离，至少让客户程序造成信息冗余，承担了不必要的职责等问题

- 但事实上也不是完全没好处，这种灵活性体现在它没有把 ImageStore 的逻辑固化在任一个 ImageProcessingJob 实例里面

* 考虑上面第三类无中生有的方式，假设是创建型的工厂方法或类似手段，则可以提供对 method 参数（业务层面的动态输入，例如最终操作用户的提供的值）的响应能力

* 这和，执行排序算法骨架确定，但是需要给定两个元素（复杂对象）比较规则这种思路有相似之处，毕竟我需要的是对方的能力而不是对方的数据或者数据视图，这时候这么做还是很有诱惑力的

- 如果脱离开场景，实际上这种动态性还更强，但问题就在于这种动态性会不会对于具体场景有价值

- 从这个实例上看，也许没这么明显，因为不同的对象存储后端更有可能是环境（测试、生产？但 12 factor 让我们... 好歹测试环境还是也上云吧）不同造成的，而非基于动态的用户信息输入

- 但，事无绝对吧，假设，用户有选择我要针对具体这一张，我特么上传那一刻选择一个存储后端的需求

- 然后为了方便用户，用户竟然可以勾选，以后使用同样地选择...

- 我觉得除了脑子进水的犬类应该没人会干这种没问题制造问题也要上的方案吧

 


所以综上所属，还是 field 一个 ImageStore 接口来搞吧

这极客时间也让人想吐槽，能敲 2000 字，结果就只留这么大点儿一个输入框... 你要不就限制 200 字我还能少敲一点... 我这写的兴起还得外面写完了贴过来...

2019-11-22


守拙

课堂讨论 answer:

考虑使用工厂模式生成 ImageStore 实例。这样就可以将调用者和具体 ImageStore 解耦.

例:

public class ImgStoreFactory {


    private ImgStoreFactory(){


    }


    public static ImageStore create(Class<?> clz){


        if (clz == AliyunStore.class){


            return new AliyunStore();


        }else if (clz == PrivateYunStore.class){


            return new PrivateYunStore();


        }else {


            throw new IllegalStateException("..");


        }


    }


    public static void main(String[] args) {


        ImageStore store = ImgStoreFactory.create(AliyunStore.class);


        store.dosth();


    }


}


另外有一点不太同意作者的说法:

上节课作者将 Contract 翻译为 "协议",

我认为是不恰当的.

在计算机领域，通常使用 Protocol 代表协议.

个人认为 Contract 更恰当的翻译是 "契约".

2019-11-22


William


所以思考题，想到的是，将接口作为构造函数中的参数，传递进来，再调用.

2019-11-22


二星球

使用策略模式，在建一个 Context 类，使用聚合持有这个接口实例引用，其它所有地方都用这个 context 类，变动的时候，只变这个 context 类就行了，其它不动

2019-11-23


姓程名序员

存储图片的方式写入到配置文件，第 8 行改用传入类型参数来实例化不同的对象，明天补上代码。

2019-11-22


Milittle


再说一句 面向接口编程的精髓 我的理解是我们在使用接口的时候 关心我们要做什么 而不是怎么做 怎么做都封装在具体实现类中。而且最主要的是 接口抽象

2019-11-22


Monday


依赖注入可以解决思考题，基于接口的实现有多种时，注入处也需要指明是哪咤实现

2019-11-22


YouCompleteMe


抽象工厂，把创建具体类型放到工厂类里

2019-11-22


bearlu


老师，希望能把示例代码和问题代码也放到 Github 上。

作者回复: 👌 我抽空整理一下放上去

https://github.com/wangzheng0822


2019-11-22


BitInit


对于思考题，想到了两种方法：

1. 简单工厂 + 反射 + 配置

2. 通过使用控制反转 / 依赖注入方式，类似于 Spring

2020-02-03


👽


那现在的 MVC 代码，要求 service 先写接口，然后再写实现，有必要嘛？

说实话，我一直没看懂这种行为的意义何在。

作者回复：确实意义不大

2019-11-25


NoAsk


关于什么时候定义接口的一些拙见：

当方法会有其他实现，或者不稳定的时候需要定义接口；

1. 不稳定的方法一般能事先确定，用接口能提高可维护性

2. 但在开发时往往不确定是否需要其他实现，我的原则是等到需要使用接口的时候再去实现。所以根据 kiss 原则一般我会先用方法实现，如果有一天真的需要有新的实现的时候再重新抽象出接口对代码进行小重构。

就老师的例子进行一下说明：

刚开始只需要阿里云进行图片上传下载功能，我就先只实现阿里云的图片上传下载方法。

后期发现需要有私有云的上传下载方法的话，那就对这个功能通过接口进行抽象。但是你永远不知道到底是新的图片上传下载功能先来到还是其他阿里接口先来到，如果是新的阿里接口，也是用的这一套 token 方法，那就用抽象方法或接口对 token 部分实现抽象。

课后问题：

简单工厂，工厂模式可以提高可扩展性，维护性。

java spring 项目可以使用注入的方式。

2019-11-22


ちよくん

老师，我在看的过程就发现了你在课堂讨论的问题，本来想在评论中提出，老师在结尾自己提出来了，关于这个问题我的建议是再抽出来一层 manager 接口或者类均可，manager 实现类调用上传下载接口，外部统一调用 manager 接口，外部不会因为 manager 实现类的具体调用那个接口而改变任何代码，即可解决上面的问题。

2019-12-29


plasmatium


如果用 golang 实现的话，可以非常优雅简洁。实现 io.Writer 和 io.Reader 接口即可。以下举例 Writer 接口

比如把各种字符串定义并取名为一种 bucket 类型（本质还是字符串，不增加任何动态汇编代码）：

type AliyunBucket string


type PrivateBucket string 等等。。。

然后实现各自的 Write 方法，其中包括 token 的获取等等各自关心的事情，然后可以这样用：

var bucket AliyunBucket = "/path/to/save/on/bucket.png"


var bucket2 PrivateBucket = "C:\ 我的图片 \x.jpg"

var bucket3 MyAwesomeBucket = "http://192.168.1.234/picture/y.jpg"


bucket.Write(imageBytes)


bucket2.Write(imageBytes)


bucket3.Write(imageBytes)


-------------------


实际上我们可以更灵活一些，某天你突然有了另一个 bucket，并且需要支持转 base64 或者压缩支持，那都不是事儿，我可能会这么写：

type DataSaver interface {


      Save(io.Writer)


}


type imgData []byte


然后可以在 imgData 上实现这个 DataSaver 接口，然后这样调用：

var AliyunBucket = "/path/to/save/on/aliyun/bucket.png"


var filePath LocalFilePathBucket = "C:\Path\to\img.jpg"


combinedWriter := base64.NewEncoder(base64.StdEncoding, AliyunBucket)


combinedWriter2 := someOtherEncoder.New(someParams, filePath)


combinedWriter3 := imgFilpEncoder.New (someParams, MyAwesomeBucket) // 翻转图像后上传

img imgData := someImg


img.save (combineWriter) // 以 base64 存阿里云

img.save (combineWriter2) // 存本地

img.save (combineWriter3) // 翻转后存私有云

同理，任何实现了 DataSaver 接口的东西（可能是一个结构体，一个 byte 数组，一个 int，一个 string 等），都可以上传下载到任何地方（各种 bucket，磁盘，网络，内存，只要实现了 io.Writer 和 io.Reader）

-----------


另外考虑到只要实现 io.Writer 方法的都可以从这个接口得到好处，比如 http.ResponseWriter，

那么就是用在服务器响应别人的请求的需求上了。

考虑到上传下载的本质，我们最终是要实现如何将一坨字节以某种方式搬运到另一处：将 imgBytes 从内存 A，通过 base64 的 encode 方式搬运到内存 B，然后应用某些参数来搬运到网卡 C 或者磁盘 D，在 golang 里用装饰器模式实现起来比较好弄，上述例子中 base64 就是这样做的。

另外可以看到 duck-type 非常灵活，而且作为静态语言，编译器已经帮你把关了，你不可能遇到 python 或者 js 里的运行时错误

2019-12-02


超威丶

个人觉得维护 map 是最好的选择，实现类型和具体实现对应。

2019-11-22


默

我是搞 Java 的，关于思考题，个人感觉主要依靠控制反转，即把对象的构造权交给容器，而非代码中直接写死。像 Spring 那种依赖注入的方式就可以，或者不使用 Spring，可以把具体的实现类全路径名配置到配置文件中，代码中以 Class.forName 的方式得到 Class，然后再用 Class 的 newInstance 方法得到实例并缓存起来以便后面使用避免重复构造实例。以后替换实现的时候只需要替换配置文件中的类全路径名即可。当然前提是这个 Class 需要实现统一抽象出来的接口，使用逻辑中也是

2019-11-22


Paul Shan


基于抽象而非具体体现了信息隐藏和分离代码中稳定性不同的部分。在一个上传图片的部分不需要知道图片是如何上传的，阿里云以及 token 就属于过多的信息，有必要隐藏这些信息。另外一方面上传图片这件事比阿里云实现要稳定的多，不上传图片的概率低于不用阿里云上传图片的概率。这里有必要分离图片上传这个接口和用阿里云上传这个实现。

不过原来的实现也没什么问题，毕竟谁也不能未卜先知，将来一定会替换阿里云。如果我拿到这个变更需求，我会先用同名接口替换原来的实现（原来的阿里类实现清晰，功能单一，只是不适合直接调用），然后用 adapter 来转接口，然后一步一步实现接口和实现的分离，目标是接口能够隐藏信息，实现能够清晰明了，每一步都能用 IDE 工具重构，每一步都能编译和测试。

2019-11-22


秋惊蛰

这一节解决了一些疑惑，但是还有三个问题想问一下：

1. 看到有些 Spring Boot 的代码，会给每个业务逻辑分别定义一个 service 接口，并用一个类来实现这个接口，然后在 controller 里像第 8 行那样调用。

这种是不是就过度使用接口了，还是说有必要考虑每个业务逻辑可能的实现方式。

2. 能不能具体的说一下哪些典型场景适合用接口抽象，比如输入输出，这两个地方肯定不止一种方式，用接口很有必要，还有其他场景吗？

3. Python 这种动态语言怎么做到面向抽象编程？

2019-11-22


Kaybee


思考题：ImageProcessingJob 构造函数声明 ImageStore 接口为参数，实际运行时传入实现类实例

2019-12-26


Milittle


读完这节课以后，有如下敢想，也可以用在以后编写程序的过程中：

1. 基于接口编程，我们首先需要明确我们要做什么，然后去定义接口，具体怎么做，我们封装在具体实现类中进行实现，这就是上层代码基于接口实现功能，底层基于具体类实现编程，做到不暴露任何实现细节给上层代码。

2. 基于抽象编程，我的理解是，我们再不断明确具体实现类要做的事情中，抽象出公共的代码，放在抽象类中进行共用，然后具体不同的实现我们还是可以确保在实现类中进行实现。

3. 这两者都可以在编程过程中实现基于接口而非实现编程。这样上层代码就不太需要在修改功能的时候，做大量的代码修改。

课堂讨论：

在 C++ 中，我们让这种调用使用方式通过工厂模式来进行封装，到后来如果具体实现发生了改变，我们只需要扩展一个具体实现类，然后就可以做到开闭原则，对扩展开放，对封装关闭的原则。这样我们只需要在调用的时候，传入不同的参数，来构建不同的工厂实现类对象，最后调用该工厂实现类的具体实现来达到功能的迁移。（我的回到可能有点乱，不知道有人看得懂不，没看懂的 我们可以交流），最后感谢王争师兄给我这么好的学习机会 让自己的零散知识重新做一个总结，很实惠～谢谢

2019-11-22


anders


为什么基于接口实现？

觉得作者这章直接命中核心的点是:

- 封装不确定性内容，暴露稳定的接口

- 与其说基于接口，不如更加通俗的基于协议，约定

编程效率本质上，是要应对需求的不确定性，应对变化中，更小成本的开发演进。

如何更小成本的开发？那当然是牵扯代码越少，效率越高。

如本章例子，只需要基于接口再实现一个类，并替换掉就好，这样做的好处除了改动少，QA 测试的范围少之外，还有就是测试好写（只需要测试新类即可），开发者心智负担也少（头发终于能保住了😂）

另外提到基于协议实现，让我想到了 vscode 的 Language Service Protocal 的流行，纷纷被 vim，emacs 支持，也是这个原因。语言插件基于 LSP 实现的话，就非常容易在各个编辑器中适配迁移，极大的降低了成本。

2020-05-15


Nick


建议老师可以增加定期回答问题的文章，这一点可以学习得到专栏的老师

2020-03-22


batman


简单点可以通过工厂模式；

复杂点可以通过 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制；

2020-02-04


帆大肚子

直接工厂模式，做什么事情都要有个度，我很期待工厂模式的度是什么

2019-11-25


Jxin


1. 如果需求是，要么使用阿里云存储要么使用七牛云存储，这样非此即彼的方式。那么写死，然后基于功能开关发布。顺利发布后，在下个版本，将功能开关和老的阿里云存储代码干掉便是。

2. 如果需求是，同时存在使用阿里云和七牛云的存储诉求，这种两者兼备的方式。那么通过工厂模式，依赖入参选择对应的实现模板，分别获得实现类即可。这里需要在入参上，为实现类型打上标记，以便运行时动态选择。

2019-11-24


微光

第八行可以使用工厂类来创建接口实现类，把实例化接口实现的代码收拢到一个位置。避免项目代码中这一类的实例化满天飞

2019-11-24


木木

看的我热血沸腾，马上重构以前的代码

2019-11-22


彦祖

SPI


2019-11-22


Jeff.Smile


设计模式解决

2019-11-22


黄林晴

打卡✔

2019-11-22


西电

笔记：多继承和接口更恰当的说法是 behaves like (表现的像)。吸血鬼继承蝙蝠和人，不能说吸血鬼是人，也不能说吸血鬼是蝙蝠。最恰当的说法是吸血鬼表现的像人和蝙蝠

2020-07-16


任忠良

golang 中的接口更多的是像一种面向未来编程的思维，好多人提到了 io.Writer 和 io.Reader，但是我觉得最能代表 golang 接口的是 sort.Interface，它定义了实现排序的接口，只有 Len () int, Less (i, j int) bool 和 Swap (i, j int) 三个方法，整个 sort 包的大部分方法都是对这个接口的操作。所以在使用时候，任何数据结构实现这三个方法就可以使用 sort 包中的排序操作。

2020-06-29


陈衎

配置项 + ioc 容器 + DI 注入

2020-06-23


潇洒哥

第 8 行使用依赖倒置原则，改成 DI 容器注入

2020-06-16


X_L～


使用策略模式，在策略接口之前创建一个上下文类，然后根据不同的场景去进行路由切换

2020-06-15


banana


如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美.

个人思考：process 函数加上一个参数：public void process (ImageStore imageStore)

调用者根据自己的需求带上不同的参数，通过多态，实现不同的存储类型调用自己的方法。

2020-06-15


石头

将 ImageStore 作为构造参数注入，具体实现类由外部传入。

2020-06-11


Cheney


思考题目：可以基于 spi 机制来实现不同的实现，或者策略模式，工厂模式等来实现

2020-05-30


余松

提供 setImageStore 方法，注入依赖

2020-05-24


Geek_East


想问个问题，泛型的主要目的是代码复用还是抽象呀？

作者回复：代码复用

2020-05-21


郭俊杰

对于一直不写接口的我来说，今天算是明白了，在有可能业务变化的时候，为了不影响上游系统，最小的改动，一定要多思考一下抽象，哈哈。

2020-05-21


师哥

基于接口编程 可以提高程序的可扩展性和灵活性。接口就是一种约定，要在需求可能发生变化的情况下使用，否则没有必要使用

2020-05-13


注定非凡

基于接口编程或者说基于抽象编程，而不是实现。这样做的原因是为了提高代码的可扩展性，可变动性。

因为在实际开发中唯一不变的就是变化，我们需要在设计编码时，提高自己的抽象意识，封装意识，接口意识，写出易扩展，修改的代码

2020-05-12


darkleo


如果把 imagestore 封装成工具呢？

2020-05-10


tuyu


老师，我今天碰到一个问题，如果我创建阿里云 k8s, 那么参数是很多很多，根据接口原则，我不太清楚未来不同云平台创建 k8s 需要哪些参数，那我应该怎么做

作者回复：这个就没法抽象成接口了，只能每个不同的云平台不同处理了。我们也没法追求在替换云平台时，一点代码都不改。尽量少改动代码就可以了。

2020-05-09


大圣代

基于接口编程体现的还是开闭原则：

1. 使用接口屏蔽了上层对于下次不稳定的感知，体现了对老代码修改关闭的原则提高了稳定性。

2. 使用接口完成多态降低了对单一实现的依赖，体现了对拓展开放的原则，降低了耦合，提升了拓展性。

3. 1 + 2 -> 接口可以随意拓展，老代码根本感知不到这个变化，不会造成破坏，还拓展了功能，提高了项目的弹性。

什么时候使用面向接口编程：

1. 对于简单、短期内不可能有多重实现方式的场景，没必要做面向接口编程。

2. 对于越是不稳定，逻辑越复杂，越应该为期提高拓展性，使用面向接口编程。

这个问题完全是对个人经验和逻辑判断的考验

2020-05-06


Tobias


关于思考题：

首先要明白 "不够完美" 指的到底是么，究竟哪点不够完美？我理解是，（1）下游使用 ImageStore 可能会 new 出多个实例，不好。（2） 如果上游提供的 PrivateImageStore 如果不存在了，会对下游产生影响，上游接口提供方是否有兜底方案？

2020-04-28


youngitachi


思考题，个人觉得，在实际编写代码运行的时候，无论如何都无法避免将一个具体的实例绑定到 imageStore 上去，也就是说，新增一个 ImageStore 的实现类后，除了新增的这部分代码，不可能在修改原来的代码的基础上就使用这个新的实现类。肯定有地方将这个新的实现类和 imageStore 绑定。不过考虑到对扩展开放，对修改关闭的原则。我觉得有一下办法修改设计。

1. 将具体的 imageStore 当作参数传进来：

```java


// ImageStore 的使用举例

public class ImageProcessingJob {


  private static final String BUCKET_NAME = "ai_images_bucket";


//... 省略其他无关代码...

  


  public void process(ImageStore imageStore) {


Image image = ...;// 处理图片，并封装为 Image 对象

    imagestore.upload(image, BUCKET_NAME);


  }


```


2. 将 imageStore 设置为成员

```java


// ImageStore 的使用举例

public class ImageProcessingJob {


  private static final String BUCKET_NAME = "ai_images_bucket";


  private ImageStore imageStore;


//... 省略构造器和其他无关代码...

  


  public void process() {


Image image = ...;// 处理图片，并封装为 Image 对象

    imagestore.upload(image, BUCKET_NAME);


  }


```


这个方法其实就是策略模式。

3、使用工厂方法模式。暂提一下，后面学到的时候自然就明白了。

2020-04-19


酸辣土豆丝

定义一个配置参数来配置存储方式，程序加载的时候，根据配置的值，来动态的加载，对应的存储路径对象

2020-04-06


海林

看完之后感觉可以用策略模式试试，

将图片的存储方式抽象成一个策略类，

然后创建两个实现策略类，比如 aliyun 存储，私有云存储，腾讯云存储

再创建一个使用策略的类 Context (Strategy strategu) ，executeStrategy (img,arg....)

当使用哪种存储方式的时候，就直接调用 Context 的 executeStrategy

2020-04-05


海林

接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

2020-04-05


Geek_bb8d16


模版模式，上传流程相对稳定，先处理，再加载要上传的服务器，再上传，父类定义流程，让子类来实现具体细节，而子类又可以通过接口来实现

2020-04-04


小北

思考题：我觉得可以采用依赖倒置的原则。简单的版本可以基于工厂模式实现。但是在一般的项目中可以直接使用成熟的 ioc 框架实现依赖倒置。如 java spring 中自带的依赖注入，或者 c# 中的 autofac，这些都是「器」级别的。

2020-04-02


elasting


使用 spring 的条件注入，而条件的判断可以通过配置文件的配置项设置，要替换实例，只需要更改配置项的值就行，这与一个系统要兼容多个数据库是类似的

2020-03-30


面向百度编程

您这里说函数的命名不能包含更为详细的细节，您说了把 uploadtoaliyun 照抄到 privatetoaliyun 不合适，这肯定不合适啊，我觉得并没有把为什么不合适讲明白。不暴露更为具体的实现细节，是不是一种好事呢，值得深思，但作为接口，确实是给上游暴露，只不过，再给某个具体实现子类实现的时候，比如 aliyun ,privateyun 可以尽可能的简化在其类中的方法命名，看到类名就能知道具体的对应目标，但是如果没有接口用具体详细细节命名也没错，只是增加一点修改时间而已，同样能够给上游带来方便

2020-03-29


鸳鸯戏水蝶

隐藏内部细节这个确实挺对的，最近也在做微信公众号的开发，accessToken 获取的逻辑到底应该放在哪里，我也思考了很久。

2020-03-28


Six


对于作者的思考题。个人觉得需要考虑实际场景。有两种场景

1. 如需改变就全部改变。那么在设计的时候提供一个静态方法比如

 public static ImageStore createImageStoreStore(){


         return PrivateImageStore()


         //return AliYunImageStore()


    }


这样只改这一处地方全局生效。对调用者来说，创建细节隐藏。

2. 那如果是部分使用私有云部分使用阿里云，可以使用简单工厂。

 public static ImageStore createImageStoreStore(String storeType){


// 根据 storeType 来判断创建哪一个实现类

}


2020-03-26


墨鱼

想起来我以前写的代码，把所有的实现都放到一个函数里面，都时候需要改动的话，非常麻烦。后来把他们都分离了一下，抽象出来，变成几个函数。需要改动的时候，只需要改动具体的实现部分，逻辑没变。

这应该也是一种基于接口而非实现编程的案例

2020-03-25


忆水寒

可以使用代理模式，写一个代理类。就算后面要修改也是修改代理类而已，不会对上一层调用产生修改。

2020-03-24


秋风画扇

接口只需要定义在有变化的地方既可以。图片处理的方式有很多，可以上传、删除、编辑，而上传又可以分很多存储介质。我们这里可以采用策略模式，process () 方法只需要调用接口方法 ImageStore#upload () 就可以了，ImageStore 作为 ImageProcessingJob 的成员变量，我们可以通过注入不同个实现类来调用不同处理逻辑，这里用到了「多态」

2020-03-21


秋风画扇

联系题是抽象程度的问题，处理 ImageProcessingJob 的作用是处理图片，处理的方式有很多：上传、删除、编辑…… 每种处理方式又有不同的实现，上传可以传到私有云、阿里云……，我们在上面地方定义抽象取决变化在上面地方。如果仅仅是处理方式仅仅是上传，而上传可能到多个媒介，这时候我们就可以再上传这地方做文章。process () 方法里只需要调用存储的接口既可，具体实现也可以灵活替换

2020-03-21


治慧

工厂模式去实话对象或者通过策略模式提供统一的 Context 如果通过定义枚举的方式获取对应的实现类 bean 名称在从依赖注入的 map 中取出实例对象来执行方法这样无论添加阿里云 百度云 还是华为云只需要写对应的实现类和在枚举中增加对应的 bean 名称即可

2020-03-18


jaryoung


课后习题：配置文件配置的方式，能很好解决这个问题。

2020-03-17


ladili


接口是对相同功能的抽象，是协议，是对功能的描述，约定

2020-03-11


ladili


设计模式是思想上的东西，是前人总结出来的经验。没有什么具体的语法实现。

类，接口，继承是实在的语法。

基于接口而非实现编程就是基于抽象而非实现。关键点就是抽象。

一个新功能，可以思考这个功能点可能会有哪些变种。通过抽象出多个变种里共有的逻辑，抽象出来。其他的具体实现都基于这个抽象去实现。具体也就是抽象出一个个接口，面向这些接口实现。

2020-03-10


大王叫我来巡山

面向配置文件编程

2020-03-09


悠游

可以基于策略模式，由用户传入的参数指定需要选用哪种图片存储方式，由此来创建响应的具体的类对象。

2020-02-25


未来小娃

编程依赖抽象而不是实现得前提条件是行为的变化，比如将毫秒时间戳换算为年月日就不存在行为的变化，那么直接用一个「实现类」，或者说普通类就可以了，反之如果文中提到的上传图片和下载图片的行为未来就是有可能变化的，比如图片存储从阿里云换成私有云就是变化，这就要求编程设计的时候多思考变化点，具备抽象思维。前面也提到接口是行为的抽象，是一组协议或者说契约，那么就决定了接口的行为必然是比较稳定的，比如就不能在图片存储的接口上加上获取日期这样的行为因为这是不相关的，也不能加上获取图片链接的行为，因为有些图片存储可能压根就没有获取图片链接的功能，因为这是关联性没那么大的行为。关于思考题我想的是实现上可以通过一个 map 初始化不同实现的图片存储，key 是类型，value 是具体的实现，需要哪个就从 map 的 type 拿就好了，本质上这就是 Spring 控制反转的原理，这也是各种 @Autowired 直接用起来贼爽的原因

2020-02-22


色即是空

面向类、面向切面、面向抽象、面向接口、面向模式、面向对象、面向结构；面向正确的方向

最后是不是应该用建造模式中的一种，如工厂模式啊什么的

2020-02-22


Heaven


Spring 框架提供了很好的依赖注入特性，可以让实际的实现类并不在编写的时候和调用方挂钩，而是由容器来决定注入，于是我给出的解决方案是，利用工厂类和依赖注入来进行解决，在一个工厂类中保证生产出的实现类是具有单例式的，然后调用者注入这个工厂类获取到生产出的实现类，在需要修改的时候，只需要修改这个工厂类产生的实现类就可以了，调用者不需要任何改变，即可获取到工厂类生产出的新实现类

2020-02-19


Rona


思考题可以将 ImageStore 作为 process 方法的形参，使用 ImageStore 的子类作为实参传入

2020-02-13


月马穿关

思考题懵逼中 我知道我平日里直接使用 Ioc 直接注入进来接口

2020-02-11


Pluto


看了很多答案，很多都是换汤不换药。如果第八行的代码大量存在，用配置一类的方式应该可以解决，做到最小修改；如果第八行的代码少量存在，直接修改第八行代码就是了。既然需求已经变了，那么修改代码是必然的事情，修改代码在可以承受范围之内就没有必要过度设计。

2020-02-05


KK


课后思考题

因为存在多种实现的方案，具体哪一种，可以根据标识来选择，对应的设计想到的是策略设计模式。

2020-02-03


Nestor.liu 刘明丰

控制反转，依赖注入 是优雅的实现方案。

2020-02-02


不记年

1. 依赖注入 + 配置文件 ，也就是 spring

2. 工厂方法

2020-01-29


放个屁臭到了自己

脑海里第一个想法就是：工厂模式；

2020-01-28


李轩

设策略模式比较适合。

2020-01-27


帝都牛人

我觉得用策略

2020-01-21


LF


配置文件加工厂模式 和 反射的方式实现，学到了

2020-01-19


lecy_L


课后问题解决方案：加一个接口实现类，ImageStoreServiceImpl 实现接口，在接口实现类 ImageStoreServiceImpl 里面不做具体上传的实现，只调用具体的实现类；具体的实现类也不用实现接口了。老师你觉得这样可以吗

2020-01-14


古之岳

关于思考题，使用工厂模式。明白需求来源，为什么在使用了阿里云后还要使用私有云，肯定是阿里云不再满足新的业务要求，比如公司要求私密文件存储于私有云，公用图片存储于阿里云。所以可以将这个不同的使用策略抽象出来，业务层只需要将使用策略传入即可，工厂类根据传入的策略值创建具体的图片存储类。

2020-01-14


eason2017


可以通过 SPI 的方式来实现动态加载对应的实现类

2020-01-06


varotene


Programming against interface 是不是也是抽象 (abstraction) 的一种手段？把原来具体的问题或者实现（aliyun 或者私有云）抽象成任意的云，然后通过 interface 来予以描述。

至于什么时候用 interface，什么时候不用，感觉也跟什么时候用抽象什么时候不用抽象是一个道理？因为进行抽象是需要成本的，但不需要的时候，我们就可以略过，节省工程成本（YAGNI 原则）。这么理解对吗？

作者回复：理解的没问题～基于接口而非实现是一种抽象的思维

2020-01-06


我叫郭小黑

基于配置文件的简单工厂模式，或者基于配置文件的反射，类似于 jdbc 切换数据库方言一样，更换驱动类就可以实现对具体实现的转换

2020-01-02


乾坤瞬间

最近在看 Livy 源码，其实在课后思考题的过程中，有一种方法可以更加优雅，其中可以使用当前线程的动态类加载机制，根据具体的类的权限定名进行实例的加载。在。Livy 中，在启动后端 RSCbootstrap 类中，加载的类 RSCClient 有多种方式，其中 ReplClient 继承了 RSCClient. 返回的都是。RSCClient 对象，不过 RSCClient 并不是接口

2020-01-01


fly


接口：理解为「协议」或者「约定」，能帮助跳出具体语言的条条框框。

基于接口而非实现的编程：主要降低代码间耦合度，屏蔽实现的细节。我们在做设计时，加强接口意识、封装意识、抽象意识，脱离具体的实现，可以做的通用性更好。

过度使用：接口是一个常被用到，也容易被过度使用。是否每个类都需要接口，根据实现后是否比较稳定，一旦完成后，几乎不改动来考虑。

2019-12-29


zmysang


没有学过设计模式，目前的想法是可以使用配置文件的方式来选择使用的存储后端类……

2019-12-28


Geek_e70156


思考题：

「这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。」

我的思路是设计一个 ImageService 来管理这些 Image 对象的创建细节，调用方只需要调用 ImageService.upload 就可以了，具体的创建细节不要暴露给调用方。

2019-12-28


Yangjing


通过配置 + 抽象工厂模式。不同的配置对应不同的 Storage.

2019-12-27


喵喵喵

打卡～

2019-12-27


古德

第 8 行的问题，可以用几种方式解决

1. 如果使用的是 SpringBoot 这种框架，可以通过配置文件参数，控制 bean 注入进行切换。

2. 通过 SPI 的方式指定。

3. 把获取实现类的方式收拢到一个方法中，通过动态参数控制。

2019-12-25


