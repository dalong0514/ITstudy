# 0104. 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

王争 2019-11-18

上一节课，我们提到，常见的编程范式或者说编程风格有三种，面向过程编程、面向对象编程、函数式编程，而面向对象编程又是这其中最主流的编程范式。现如今，大部分编程语言都是面向对象编程语言，大部分软件都是基于面向对象编程这种编程范式来开发的。

不过，在实际的开发工作中，很多同学对面向对象编程都有误解，总以为把所有代码都塞到类里，自然就是在进行面向对象编程了。实际上，这样的认识是不正确的。有时候，从表面上看似是面向对象编程风格的代码，从本质上看却是面向过程编程风格的。

所以，今天，我结合具体的代码实例来讲一讲，有哪些看似是面向对象，实际上是面向过程编程风格的代码，并且分析一下，为什么我们很容易写出这样的代码。最后，我们再一起辩证思考一下，面向过程编程是否就真的无用武之地了呢？是否有必要杜绝在面向对象编程中写面向过程风格的代码呢？

## 4.1 哪些代码设计看似是面向对象，实际是面向过程的？

在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。我也希望你通过对这三个典型例子的学习，能够做到举一反三，在平时的开发中，多留心一下自己编写的代码是否满足面向对象风格。

1. 滥用 getter、setter 方法

在之前参与的项目开发中，我经常看到，有同事定义完类的属性之后，就顺手把这些属性的 getter、setter 方法都定义上。有些同事更加省事，直接用 IDE 或者 Lombok 插件（如果是 Java 项目的话）自动生成所有属性的 getter、setter 方法。

当我问起，为什么要给每个属性都定义 getter、setter 方法的时候，他们的理由一般是，为了以后可能会用到，现在事先定义好，类用起来就更加方便，而且即便用不到这些 getter、setter 方法，定义上它们也无伤大雅。

实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话。

public class ShoppingCart {


在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它们的 getter、setter 方法。对于 items 属性，我们定义了它的 getter 方法和 addItem () 方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？

我们先来看前两个属性，itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。

而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。

看完了前两个属性，我们再来看 items 这个属性。对于 items 这个属性，我们定义了它的 getter 方法和 addItem () 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上并不是。

对于 itemsCount 和 totalPrice 这两个属性来说，定义一个 public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：

ShoppingCart cart = new ShoppCart();


...


cart.getItems ().clear (); // 清空购物车

你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 ShoppingCart 类中定义一个 clear () 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear () 方法的具体代码实现如下：

public class ShoppingCart {


你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart 类不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？

如果你熟悉 Java 语言，那解决这个问题的方法还是挺简单的。我们可以通过 Java 提供的 Collections.unmodifiableList () 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add ()、clear () 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。

public class ShoppingCart {


不过，这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems () 获取到 items 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。听起来有点绕，看看下面这几行代码你就明白了。

ShoppingCart cart = new ShoppingCart();

这个问题该如何解决呢？我今天就不展开来讲了。在后面讲到设计模式的时候，我还会详细地讲到。当然，你也可以在留言区留言或者把问题分享给你的朋友，和他一起讨论解决方案。

getter、setter 问题我们就讲完了，我稍微总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

2. 滥用全局变量和全局方法

我们再来看，另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？

如果你是用类似 C 语言这样的面向过程的编程语言来做开发，那对全局变量、全局方法肯定不陌生，甚至可以说，在代码中到处可见。但如果你是用类似 Java 这样的面向对象的编程语言来做开发，全局变量和全局方法就不是很多见了。

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

在刚刚介绍的这些全局变量和全局方法中，Constants 类和 Utils 类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。

我们先来看一下，在我过去参与的项目中，一种常见的 Constants 类的定义方法。

public class Constants {


在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。

首先，这样的设计会影响代码的可维护性。

如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。

其次，这样的设计还会增加代码的编译时间。

当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。

最后，这样的设计还会影响代码的复用性。

如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。

那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴。

第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。

讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我想问你这样一个问题，我们为什么需要 Utils 类？Utils 类存在的意义是什么？希望你先思考一下，然后再来看我下面的讲解。

实际上，Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？

我们在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。

既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。

在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个 Utils 类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。

除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。

3. 定义数据和方法分离的类

我们再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁会这么写呢？实际上，如果你是基于 MVC 三层结构做 Web 方面的后端开发，这样的代码你可能天天都在写。

传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。

实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢？

关于这个问题，我今天不打算展开讲解。因为它跟我们平时的项目开发结合得非常紧密，所以，更加细致、全面的讲解，我把它安排在面向对象实战环节里了，希望用两节课的时间，把这个问题给你讲透彻。

在面向对象编程中，为什么容易写出面向过程风格的代码？

我们在进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？

你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。

除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。

所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。

面向过程编程及面向过程编程语言就真的无用武之地了吗？

前面我们讲了面向对象编程相比面向过程编程的各种优势，又讲了哪些代码看起来像面向对象风格，而实际上是面向过程编程风格的。那是不是面向过程编程风格就过时了被淘汰了呢？是不是在面向对象编程开发中，我们就要杜绝写面向过程风格的代码呢？

前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？

除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。

不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。

## 重点回顾

你要掌握的重点内容是三种违反面向对象编程风格的典型代码设计。

1、滥用 getter、setter 方法。在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

2、Constants 类、Utils 类的设计问题。对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

3、基于贫血模型的开发模式。关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。

## 黑板墙

今天课堂讨论的话题有两个，你可以选择一个熟悉的来发表观点。

1、今天我们讲到，用面向对象编程语言写出来的代码，不一定是面向对象编程风格的，有可能是面向过程编程风格的。相反，用面向过程编程语言照样也可以写出面向对象编程风格的代码。尽管面向过程编程语言可能没有现成的语法来支持面向对象的四大特性，但可以通过其他方式来模拟，比如在 C 语言中，我们可以利用函数指针来模拟多态。如果你熟悉一门面向过程的编程语言，你能聊一聊如何用它来模拟面向对象的四大特性吗？

2、看似是面向对象实际上是面向过程编程风格的代码有很多，除了今天我讲到的这三个，在你工作中，你还遇到过哪些其他情况吗？

### 01

不想往下看的请看第一句就好：贫血模型流行的原因是，实现简单和上手快。

具体解释慢慢看，贫血模型的开发模式为什么会流行？1）实现简单。Object 仅仅作为传递数据的媒介，不用考虑过多的设计方面，将核心业务逻辑放到 service 层，用 Hibernate 之类的框架一套，完美解决任务。2）上手快。使用贫血模式开发的 web 项目，新来的程序员看看代码就能「照猫画虎」干活了，不需要多高的技术水平。所以很多程序员干了几年，仅仅就会写 CURD。3）一些技术鼓励使用贫血模型。例如 J2EE Entity Beans，Hibernate 等。总结：各种模型的好坏讨论一直不断，企业需要的是使用合适的技术把任务完成，从这个角度来说当下管用模型就是好模型。当然我们也要持开放的心态接受新的技术和思想，并结合业务的实际需要选择合适的技术。

概念解释：贫血模型（Anemic Domain Model 由 Matin Fowler 提出）又称为失血模型，是指 domain object 仅有属性的 getter/setter 方法的纯数据类，将所有类的行为放到 service 层。原文他是这么说的「By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring.」他的原文我放上来了，英文好的同学可以看看：[AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)。我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don't know why this anti-pattern is so common）。

2019-11-18

### 02

1、用 shell 实现自动化脚本做的服务编排，一般都是面向过程，一步一步的。而 k8s 的编排却是面向对象的，因为它为这个顺序流抽象出了很多角色，将原本一步一步的顺序操作转变成了多个角色间的轮转和交互。

2、从接触 ddd 才走出 javaer 举面向对象旗，干面向过程勾当的局面。所谓为什么「充血模型」不流行，我认为不外呼两个。一，规范的领域模型对于底层基础架构来说并不友好（缺少 setget），所以会导致规范的领域模型与现有基础架构不贴合，切很难开发出完全贴合的基础架构，进而引深出，合理的业务封装却阻碍关于复用通用抽象的矛盾。二，合理的业务封装，需要在战略上对业务先做合理的归类分割和抽象。而这个前置条件很少也不好达成。进而缺少前置设计封装出来的「充血模型」会有种四不像的味道，反而加剧了业务的复杂性，还不如「贫血模型」来得实用。事实上快节奏下，前置战略设计往往都是不足的，所以想构建优秀的「充血模型」架构，除了要对业务领域和领域设计有足够的认知，在重构手法和重构意愿上还要有一定讲究和追求，这样才能让项目以「充血模型」持续且良性的迭代。

3、「充血模型」相对于「贫血模型」有什么好处？从我的经验来看，可读性其实可能「贫血模型」还好一点，这也可能有思维惯性的原因在里面。但从灵活和扩展性来说「充血模型」会优秀很多，因为好的「充血模型」往往意味着边界清晰（耦合低），功能内敛（高内聚）。这一块老师怎么看？

2019-11-18


猫切切切切切

总的来说，使用面向对象风格编写的面向过程代码有如下特点：

1. 使用了类，但是

2. 要么完全没有封装（比如数据和操作分离的贫血模式）

3. 要么破坏了封装（比如滥用 getter 或 setter）

4. 要么完全没有抽象（大而全的 Constants 或 Utils 类）

5. 要么封装或抽象不完全（比如类实例化后，或者子类继承后，需要自己管理其内部某些属性或状态）

平时应该多留心代码是否存在上述特征。

文中没有举封装或抽象不完全的例子，这里举一个。

比如一个实现某种业务需求（如与某种类型设备通讯的应用协议）的 tcp 或 udp 服务器；

实例化后还需要自己管理其协议相关的就绪状态（ready 属性）；使你不得不对其再封装一层，并抽象其连接、断开等方法使其自动进行就绪状态的管理；

每个继承都这么封装一遍，就会有大量重复的代码，而且其实类的实例化者或继承者并不需要也不应该关心就绪状态的管理，所以没有达到就绪状态管理的封装。

这就是一种不完全的封装。

2019-11-18


嘉一

个人觉得，MVC 这种框架模式本质上与面向对象并不冲突。当我们在讨论面向对象的时候，我们究竟应该怎样去定义一个对象，究竟什么才能被我们看成是对象，是不是只有像某种物体，比如说一只鸟或者一只狗我们才能去把他定义为对象？我认为，MVC 里面的三个部分 Model 、Controller 、View 我们都能把他们单独的看成一个对象，比如说 Model，本来它是数据单元，但是如果我们把他看做一个对象的话，里面存储的数据不就是我们对象里的属性么，而对于数据的二次加工处理等等操作不就是对象里的方法么？同理，对于 View 而言，里面小的 view 组件或者是其他的 view 不就是我们对象里面的属性，而对于不同的 view 组件或其他 view 的组合或者其他的处理操作不就是对象里面的方法么？所以说，不必死抠定义，数据就一定要和业务逻辑组成一个类云云。。。我们最后写出来的代码的目的就是，1. 要解决问题；2. 代码有可扩展性，可读性；3，代码解耦；

作者回复：说的没错，MVC 跟贫血模型没直接关系。我后面在实战篇会讲到的。你的观点我基本都赞同。

2019-11-18


黄林晴

打卡

看了今天的内容，发现自己三点都占了，😲

遇到 json 数据使用 Gsonformat 转一下，默认生成所有 get set 方法，遇到统一使用的就会毫不犹豫定义工具类……，我有点怀疑自己是不是从未写过面相对象风格的代码

2019-11-18


Jackey


确实是个问题啊，现在流行的贫血模式每个项目都会用。用了贫血模式就会涉及 BO 和 VO 的转换，很多工具都需要全部字段的 setter 方法… 感觉是个连环套啊。

ps：用了这么久 Java 原来一直是面向过程编程，怪不得找不到对象

2019-11-19


中年男子

先说问题 2：看似面向对象实际面向过程的例子真是数不胜数了，工作语言 C/C++，90% 是 C++, 大体上老师在文中已经提到了，其他的我暂时也没想起来，但是滥用面向对象继承特性的代码我真是看到了太多

问题 1：C 中可以用 struct 来实现 class，只是访问控制权限都是 public。类中的成员函数可以通过指向操作结构体的函数指针来实现，实现封装，需要绑定数据、函数、函数指针。可以创建函数指针表，构造函数设置函数指针指向正确的操作函数，函数指针表作为对象访问函数的接口。操作结构体的这些函数（成员函数）不像 C++ 中能直接访问数据成员，需要显示的传递操作对象给成员函数。

继承：在派生类中维护一个基类对象的指针。这样派生类可以访问基类对象的数据。

多态：在基类中维护一个派生类对象的指针。这样基类可以访问派生类对象的数据。

C++ 中的多态，有一个对象销毁的问题。基类的析构函数必须是虚函数

在 C 中，这可以通过使基类的删除函数指针指向派生类的删除函数，因为派生类的删除函数清楚派生类的数据和基类的数据

2019-11-18


Daiver


啊，写了这么久的 MVC，竟然是面向过程编程。

2019-11-18


熊斌

我们的项目三点都占，造成这个局面的原因我认为有以下几点：

1、习惯用 IDE 的代码生成插件

2、团队整体设计水平有限

3、基于 mvc 模式开发的

2019-11-18


青青子衿

有时候写 get,set 也是无奈之举，比如集成 spring 的时候，框架要求属性提供 get,set

2019-11-18


Monday


我去去去，自从知道 lombok 后，@Data 注解每个实体类必用。。。

2019-11-18


中年男子

接上条评论，代码实现如下，欢迎讨论

typedef struct _Base Base;


typedef void (*fptrDisplay)(Base*);


typedef void (*fptrDelete)(Base*);


void DisplayBase(Base* );


void DeleteBase(Base*);


typedef struct _Base


{


void* pDeriveObj;


int a;


int b;


fptrDisplay Display;


fptrDelete Delete;


}Base;


Base* new_base(int a, int b)


{


Base* pObj = NULL;


pObj = (Base*)malloc(sizeof(Base));


if (pObj == NULL)


{


return NULL;


}


// 当创建基类对象时指向自己

pObj->pDeriveObj = pObj;


pObj->a = a;


pObj->b = b;


pObj->Display = DisplayBase;


pObj->Delete = DeleteBase;


return pObj;


}


void DisplayBase(Base* base)


{


printf("member: a:%d\t b:%d\n", base->a, base->b);


}


void DeleteBase(Base* base)


{


printf("base destructor!\n");


free(base);


}


typedef struct _Derive


{


Base* pBaseObj;


int c;


int d;


}Derive;


void DeriveDisplay(Base* base);


void DeriveDelete(Base* base);


Base* new_Derive(int a, int b, int c, int d)


{


Derive* pObj = NULL;


Base* pBaseObj = new_base(a, b);


pObj = malloc(sizeof(Derive));


if (!pObj)


{


pBaseObj->Delete(pBaseObj);


return NULL;


}


pBaseObj->pDeriveObj = pObj;


pObj->pBaseObj = pBaseObj;


pObj->c = c;


pObj->d = d;


pBaseObj->Display = DeriveDisplay;


pBaseObj->Delete = DeriveDelete;


return pBaseObj;


}


void DeriveDisplay(Base* base)


{


Derive* pDeriveObj = (Derive*)(base->pDeriveObj);


printf("member:base:a:%d\t base:b:%d\nderive:c:%d\t derive:d:%d\n", base->a, base->b, pDeriveObj->c, pDeriveObj->d);


}


void DeriveDelete(Base* base)


{


printf("derive destructor!\n");


free(base->pDeriveObj);


free(base);


}


int main()


{


Base* pBase = new_base(1, 2);


Base* pDerive = new_Derive(3, 4, 5, 6);


pBase->Display(pBase);


pDerive->Display(pDerive);


pBase->Delete(pBase);


pDerive->Delete(pDerive);


}


2019-11-18


Jeff.Smile


有种上帝视角看自己的感觉！

2019-11-18


梦倚栏杆

1. 现在因为使用封装好的框架，没有提供 set 方法，类的序列化会成为一个问题

2. 从理论上来说，数据和逻辑应该放在一起，但是数据的赋值往往可能依赖其他的 service 提供的数据，如果这样的话数据属性和纯粹依赖的 service 就会导致一个类的成员属性特别的多。

3. 对于一个具体现实对象而言，不同场景下可能关心的字段稍微有些不一样，对于此又该怎么处理呢？多个小对象，他们之间有无相关关系，有的话如何阐述，还是全部赋值完毕，都完整返回。当然可能具体场景具体分析，那是否有一个稍微通用的指导纲领

期待老师关于面向对象的实战流程

作者回复: 😄你说的后面都基本上有讲到

2019-11-18


青阳魂

看完这篇，真的太有感触了，提出的这些问题，都是目前大部分程序员所存在的编码问题。

实际上面向对象、充血模型，面向过程，都是各有各的使用场景，这点上面的同学都说的很明白了，老师也说的非常明白。

很想加老师的微信交流沟通，总有那种一见如故的感觉。

我一直觉得我推崇的编码方式好像在他们眼里是异类，又说不清楚自己推崇的是什么。

说一个非面向对象语言实现面向对象的方式 lua 可以使用 setmetatable 方式实现 封装 继承

作者回复：欢迎加啊 wangzheng0822

2019-11-21


守拙

今日的课堂讨论不会回答，尝试总结一下重点回顾的 3 个问题:

1.getter, setter 问题的本质类的可变性问题.<Effective Java> 中明确提到，除非有必要，否则类应该设计为不可变 (Immutable) 的.

2. Constants 和 Util 类的问题本质是静态成员和静态方法问题.

静态成员和静态方法违背面向对象设计 (OOP) 原则，但从整体项目角度讲，静态成员和静态方法的好处大于其坏处，所以它们确实有存在的意义.

3. 我对贫血模型的看法：我是一名 Android 开发，日常使用的是 MVC 的变种 MVP && MVVM 模型.

MVP 和 MVVM 相比 MVC 要更靠近 OOP 思想，但面向过程思想的设计仍包含于其中。

无论面向对象或面向过程，写出层次清晰，易扩展，易维护的代码才是目的。

2019-11-18


DebugDog


我全占了，今天才知道自己学的 Java，天天在写面向过程😰

2019-11-18


hong


习惯了从前端的参数直接使用 BeanUtils.copyProperties 映射到具体实体类，如果不直接提供 set 方法，有啥好的方法去组装数据呢

作者回复：给类本身提供一个 copy 方法呢

2019-11-21


编程界的小学生

1.get set 这个很好理解，但是我有很多疑问，比如有的属性理论上来讲不该添加 set 方法，那我怎么对他进行属性拷贝？比如两个 vo 进行拷贝属性值，还有作为接口参数，spring 又怎么给他赋值？

2. 看完贫血模式那个知识点后，我懵了，我甚至不知道怎么才能写出面向对象的代码了，如果数据和业务不分离的话，那比如我多个业务接口需要同一份数据，难道要定义多份吗？我有点懵了😥😥😥

作者回复: 1. 并没有说一定不能定义 set 方法，文章中说不要滥定义用不上的 set 方法

2. 多个业务接口需要同一份数据？这个怎么理解呢？

2019-11-18


观弈道人

1.Get 到了 Collections.unmodifiableList，这个很好。

2.Constants 分类很好，常量定义要根据复用级别，而放在不同的位置比较好。比如：有的放在当前类、父类、同一个模块中定义的 Constants，公共模块中定义的 Constants.

3.dto/po 中的 getter/setter 只是为了方便框架解析。带有业务方法的对象，需要慎重考虑 getter/setter.

2019-11-19


grey927


Constants 用接口是不是比用类更好？

作者回复：接口不能包含属性的 用接口不合适

2019-11-20


肖大妞

是不是对不同的业务场景，应该采用不同的编程范式

业务驱动比较强的场景，是不是用采用面向过程编程更容易让人理解，

作者回复：后面实战篇会详细的讲解的。

2019-11-18


Paul Shan


添加对象公有方法方法要注意两点：

1. 避免过多的访问内部数据的方法，只有在确定需要的时候再增加。

2. 避免返回内部引用（数组，对象，方法等），这些引用会无意间暴露修改内部状态的方法，导致数据不一致，也违反封装原则。这种情况如果数据量不大，返回一个拷贝对象即可。如果有效率考量，就要具体问题具体分析。

2019-11-18


Nick


学习总结后，直接发到我们团队讨论群，让大家反思反省下。😄

2020-03-21


BitInit


对于用 C 来模拟面向对象，曾经看到过一篇非常好的文章：https://mp.weixin.qq.com/s/2ivQ9hcRvZnhk89jzAppSg

2020-02-02


码农 Kevin 亮

老师这一讲，解我多年困惑。

仍有一事困惑：前端传数据到后端，我要是不定义一个开放了所有属性的 POJO，那么数据如何反序列化成类呢？

作者回复：前端跟后端交互的那个叫 dto 可以定义为之包含数据的类 后面会讲到

2019-12-02


张德

感觉自己就是一个面向过程 BOY！！！！！

2019-11-25


James


我想的是，老师说的基本上在中小公司都是这样子的，

公司水平不高，上手快，对新手要求不高，可能导致很多人仅仅只会增删改查...

2019-11-20


吖蒲

已确认过眼神，自己是面向过程编程风格的人。

1. 如果 Entry 不提供 get 和 set 方法，如何快捷绑定数据库的值？

2.service 不提供具体的实现过程，我们如何一 一实现业务功能？

3. 团队水平有限，感受到很多功能点相似，可抽象一部分功能出来，但碍于公司说，生产上稳定性高于维护性，不给予重构的权限，重构了也不会上线。

期待老师后面章节的内容能够解决我的疑惑。

2019-11-18


傲慢与偏执，

期待实战讲解

2019-11-18


花儿少年

封装就是基本的函数

继承是一种 is-a 的关系，属性的继承是父类的属性在子类之前按照顺序排列，接口的话是使用虚函数表，通过查表来确定父类有哪些接口

多态的实现是通过函数指针，根据具体的子类找到子类继承的接口的入口地址，然后去执行就好了

大致是 c/c++ 的实现

工作现在就是在用面对对象语言写着面向过程业务，😂😂

2019-11-18


fly


lombok 一直在用；数据与操作分开的贫血开发模式，Java 开发中挺主流的。这一节听完有点乱，对习惯冲级很大。

2019-12-28


cv0cv0


不是没有定义 setPrice 方法吗？

2019-12-06


被讨厌的勇气

C 语言可以通过结构体加函数，函数第一个参数为该结构体指针的方式来实现方法和数据结构结合，但无法实现访问权限控制。

通过在结构体中包含结构体的方式可以实现继承。

通过函数指针实现多态。每个类有一个共同的虚函数表，每个对象都有一个指向虚函数表的指针，通过指向不同的虚函数表来实现多态。

## 坚持打卡 ##

滥用 getter、setter，破坏了对象的封装性，使得对象不像「对象」，还有就是返回容器对象的情况。

定义 Contants、Utils 类，影响可维护性、增加编译时间、影响易用性。解决方法：将其拆解为多个功能单一的类，或定义到相应的业务类中。定义 Utils 的一个背景是两个独立类共用相同代码，在定义之前确认有必要定义一个单独的类吗。

数据与方法相分离。

面向对象的目标是为了写出高质量的代码，当使用面向过程更能实现这个目标时（微小程序、数据处理相关的代码），不要拘泥。

2019-11-27


秋雨飘落

constants 类分类是为了减少单个文件大小 但项目中喜欢用 spring 自动注入 感觉有点多余 还想请老师给予解惑

作者回复：没有太看懂 constants 类跟 spring 自动注入的关系😂

2019-11-25


zhan


这门课太棒了，我就喜欢从理论开始，娓娓道来，然后联系实践，知其然，知其所以然。

2019-11-23


zaab


以上提到的购物车的 item，我感觉将 set 方法屏蔽部分，通过构造器构造，就可以防止以上提到修改 --- 我是菜鸟，不知道行不行。

作者回复：购物车里的 item 会被修改还是因为暴露了 getitems 方法 跟 set 关系不大

2019-11-21


青阳魂

local _class = {}


function class(super)


  local class_type = {}


  class_type.ctor = false


  class_type.super = super


  class_type.new = function(...)


    local obj = {}


    do


      local create


      create = function(c, ...)


        if c.super then


          create(c.super, ...)


        end


        if c.ctor then


          c.ctor(obj, ...)


        end


      end


      create(class_type, ...)


    end


    setmetatable(obj,{ __index=_class[class_type] })


    return obj


  end


  local vtbl = {}


  _class[class_type] = vtbl


  setmetatable(class_type, { __newindex = function(t, k, v)


      vtbl[k] = v


    end


  })


  if super then


    setmetatable(vtbl, { __index = function(t, k)


      local ret = _class[super][k]


      vtbl[k] = ret


      return ret


    end})


  end


return class_type


end


local a = class()


function a:ctor()


  self.hello = 1;


return self


end


function a:test()


    print(self.hello)


end


-- class


A = setmetatable({}, { __call = function(me, ...) return a:new( ... ) end, __metatable = true, __newindex = function() end })


local b = class(a)


function b:ctor()


  self.hello2 = 2;


return self


end


function b:print2()


    print(self.hello2)


end


B = setmetatable({}, { __call = function(me, ...) return b:new( ... ) end, __metatable = true, __newindex = function() end })


local instance = B()


for k, v in pairs(instance) do


  print(k)


end


2019-11-21


佳民

贫血模型有益于依赖注入，是不是啊？

作者回复：两者没关系的

2019-11-19


blacknhole


提个小问题，课程中以下两者在表述上其实是互相矛盾的：

06 课中说，二进制指令、汇编语言、面向过程编程语言是一种计算机思维方式，面向对象编程语言的编程套路、思考问题的方式是一种人类的思维方式。

到了本课 07 课却说，面向过程编程风格恰恰符合人的这种流程化思维方式，而面向对象编程风格正好相反，它是一种自底向上的思考方式，我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。

我觉得如下表述似乎更恰当：

计算机只有一种处理方式，就是流程化的方式。人脑在处理简单问题时，也是流程化的方式，这也是符合经验直觉的方式，即有先后顺序地，一步一步把一个任务完成。而在处理复杂问题时，因为不同事物的关系是网状的，对人来说，流程化的线性处理方式就很难应付了。这时，尽管分解任务这种模块化处理方式，因不太符合人的经验直觉，对人会有些难度，但是，相较于流程化方式，它却显得容易多了。

因而可以说，对于简单程序的开发，面向过程比面向对象容易，而对于复杂程序，尽管面向对象有难度，但也比面向过程容易。

2019-11-19


一生一世一双人

刚开始，觉得老师前面几章说的有点啰嗦。看到这里，突然觉得很有必要再回顾思考一下前面几章的内容。😂😂

作者回复: 😂 信小争哥就对了...

2019-11-19


GeXeLr


可是所有人都用贫血模型的前提下，不延续项目的原有 MVC 风格非常难以推行，而且我作为新人，听话、不出事是不是比创新更重要。。

2019-11-18


刘强

上班路上看文章，下班路上看评论！😬😬

2019-11-18


刘旺旺

原来一直在写面向过程的代码啊

2019-11-18


老杨同志

贫血模型是服务类无状态，无状态的类适合水平扩展，并且可以使用单例来应付所有请求。避免重复创建和销毁类

2019-11-18


tuyu


关于 setter 和 getter, 国内很多培训机构一开始都是教大家这么用，包括阿里云上面的 java 学习视频，都是国内前辈的习惯影响的，还好有幸看到正确的讲解

2019-11-18


leslee


额... 小争哥 那个面向切面编程会讲一下吗？看了一些解析好像不怎么懂...

作者回复: 😁 在设计模式模块里，会讲一下的

2019-11-18


月坛小雨

老师讲课举例的时候，能不能稍微带点 python 的例子？（另外，老师在加餐里有 Java 的基础知识，非常贴心了）

作者回复：我 python 不怎么懂啊 抱歉啊

2019-11-18


逆流的鱼

DTO 这个形态的疑惑就没消失过😂

2019-11-18


小畅

get、set 方法老师以前在讲的时候，也不讲为啥，上来就是直接设置。现在才知道封装的作用。工具类、配置类的细分对后期维护起来方便多了，有时候把控适合细分的度挺重要的，要多些项目经验会把控好这个度

2019-11-18


Paul Shan


面向对象是把数据和方法打包，隐藏内部状态，暴露外部需要的方法。这种把数据和方法并列处理的方法也有一个弊端，那就是很多情况下，数据和方法的体量并不对等，例如 String，数据很少，对应的方法却很多，如果把数据和方法放到一个类里，势必方法数目巨大，数据基本淹没在方法中，而且对这么多方法不分类来处理也带来维护负担，这和全局方法过多是一个道理。Kotlin 语言采用的是 extension methods 来处理这种情况，简而言之就是数据被多个方法群调用，然后调用的时候可以根据 import 来分类。请问王老师，还有其他更好的方法来处理这种情况吗，多谢！

2019-11-18


啦啦啦

面相过程更符合人类思维，和命令式编程差不多

2019-11-18


醉比

感觉老师说的几个情况已经很全面了，一直在做 MVC 相关开发，也一直感觉自己写了很多面向过程的代码，但是却不知道哪里出现的问题。感觉现在大家对于新建对象还是过于随意了，其实还是有很多门道在里面。

2019-11-18


cc


搜了一下 c 如何写出面向对象风格的代码。

直观感觉是用 c 把 c++ 编译器隐式完成的对象模型显式写出来，666😂

2019-11-18


玄兴梦影

我写得最多的就是面向过程，现在在学习 JAVA，发现自己写的也是面向过程

2019-11-18


剑八

java 语言编程风格框定了必须要以类的形式进行开发。

并且语言层面提供了 4 大特性用以支撑面向对象开发。

2020-06-27


见南山

以前每次写的时候，都会搞出来很多 Bean 对象加上 set get，以为面向对象就是构造很多对象出来，原来是还是面向过程啊

2020-06-22


大方方

我是 technical animator 转学 untiy3D C# 编程的，选这门课程作为提高程序设计的能力途径。之前项目里经常用多态做扩展，算是典型面向对象应用。但是采用的 MVC 构建在数据方面又类似贫血模型的面向过程风格。现在 Unity 官方开始革新的 DOTS 技术 ，又开始鼓励大家从面向对象改成面向数据编程，某种程度似乎又回到了面向过程的一些精神。

2020-06-20


肖家文

C 语言完全可以面向对象，私有的属性和方法可以放进.c 源文件中的结构体，c 源文件中的结构体继承.h 中 public 的基类，多态就更是不在话下了。虽然很绕，但是写个几次就熟练了

2020-06-19


『至爱闫』

不用 setter 如何更好的把数据赋值给实例。？比如数据库 mybatis 不加 setter 如何给 DO 赋值呢。？不加 setter 如何又把值赋值出去呢。？难道推荐使用构造或者 builder 么。？

作者回复：没说一定不用啊，必要的时候就用呢

2020-06-05


朝小树

lombok 插件或者各种生成器会直接生成各种 get，set 方法，我们要根据情况，开放哪些字段的权限

2020-05-24


李达龙

最近工作上实现的一个模块分支语句用的太多了，一方面可读性会变差，不易理解，可扩展性，可维护性都不太好，典型的面向过程风格！用的面向对象编程语言却写了面向过程的代码

2020-05-20


郭俊杰

老师，入坑 py，一起 AI 吧。

作者回复: py？😊

2020-05-15


八百

1.😜ོ接触到的都是贫血模式，别人这么写，我也这么写，直到看到 ddd

2. 排期太紧，还要值班，太累，就简单写就好，简单是美，没有故障是美。

3. 项目代码已经是贫血模式，保持下风格统一

2020-05-14


Mr.S


用了一阵子 Go 写 web 程序，基于现有的开发模式和框架很容易写出面向过程的代码

如： 使用 gin 框架写 controller 接口，全是全局方法，model 层的一些查询语句，也是全局方法

2020-05-12


注定非凡

面向对象编程和面向过程编程是两种编程风格，我们时常会在使用面向对象的编程语言时，写出面向过程的风格的代码。

出现这种现象的技术原因：

1：滥用 get,set

2，是构建大且杂的 contents 类，util 类

3，基本贫血模式的编程模型

另外非技术的原因是：

1，面向过程编程更简单，易上手，而面向对象则需要首先思考如何规划类对象之间关系，属性的封装

2，面向过程是一种从下往上是思考模式，符合人们按部就班的思考习惯

2020-05-11


scmath


面向对象是自底而上的思考过程，先把任务拆分为类或抽象为接口，再设计类之间的调用关系，根据流程组装类。面向对象 OOA OOD OOP

不符合人类思考问题的习惯，面向过程更符合人类思考问题的习惯，所以导致很多贫血模型。

2020-05-11


scmath


贫血模型数据和类分离后，强制要求属性都有 public set 方法，破坏了数据的封装，原来只能在类内部赋值的属性得不到数据保护。go 也有这个问题，为了让包外的序列化方法和使用统一的 SQL Driver 的 scan 程序可见 (set)，必须首字母大写，也破坏了数据的封装。分层开发也破坏的数据的封装，VO<-->BO<-->Entity 都必须要求属性是 public。

2020-05-11


JKwar


接手一个项目，分享判断全部写的 if else ，花了一整天改成策略模式了。

2020-05-05


JKwar


原来我一直在写面向过程编码啊

2020-05-05


JKwar


除了 java 直用过 kotlin，看来还得学一下 c＋＋

2020-05-05


Geek_d5c720


争老师，现在写项目感觉都是把需求分解成了一个一个的步骤，很自然的就想到定义一个一个对象，对象里面有这些步骤对应的方法，然后就拿对象去拼接这些步骤。我想知道有没有一个简单易懂的原则，让我面对这些需求不再是想着一步一步的操作，而是一个一个对象的关系呢？

作者回复：后面会讲到的 你往后看看

2020-04-27


KID


虽然用着 c#，但是也经常会写成面向过程的代码，特别是 view 的部分

2020-04-26


Geek_鬼才

对于 mvc 模型一直隐隐觉得有些问题，但是不知道到底哪里有问题，学习了本节内容后恍然大悟

2020-04-25


Geek_小白

贫血模型 我认为主要还是应为开发中 大多是先上线 然后才有业务变更。简约的设计有利于业务开发和更新，活下来才有重构的机会

2020-04-19


Geek__93441785f6a2


之前也订阅了您的数据结构与算法之美，您这两个专栏中的文章真的解答了许多我之前没有搞明白的或者理解不深的问题

2020-04-19


travel


贫血模型的流行跟 spring 框架的广泛应用分不开

2020-04-11


铁血柔情

其实 vue.js 也是一种面向对象编程的语言，先定义对象，还有对象属性实现一系列的功能。在工作中遇到的就是一个 service 的实现类中写了不是当前业务的功能，这个类有上千行的代码，跟当前业务相关的只有一百行。

2020-04-07


酸辣土豆丝

只用面向对象编程的函数些业务逻辑，没有去抽象类

2020-04-05


海林

我有种感觉这么多年，一直用面向对象编程语言写面向过程的代码，这么多年都白过了

2020-04-02


海林

因为稍微有点流程搞了不下于三个的 if else 的语句，我觉得就是面向过程编程

2020-04-02


木白

数据处理相关的程序，比如数据分析，数据预处理，数据清洗，etl 这些，就是拿到一批数据先干什么，然后再干什么，最后输出数据，这是典型的需要流程化思考模式的需求。面向过程编程和函数式编程更加适合这种场景。为什么是函数式呢，因为所谓的「以算法为主」，就可以把一个个算法操作开发成一个个小函数（称为算子），就可以通过函数式编程把这些算子应用在数据上。

2020-03-29


面向百度编程

我之前就是 set get 方法来一套，还有 util 工具类，还有 mvc 模型，看来我只停留在老师所说的层面上了，我思想有待提高

2020-03-28


鸳鸯戏水蝶

DDD。


2020-03-28


番茄鸡蛋

按模块或类型设计 utils 类

2020-03-27


猎手

不应该局限于面向对象或者面向过程，从实际出发

2020-03-27


改名不换人

在写 MVC 后台的时候考虑过这到底是不是面向对象，后来也没有深入研究，这次看来能弄懂了，继续学习！

2020-03-26


不学不行啊

在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

2020-03-21


Marvichov


https://miro.medium.com/max/3000/0*kU-C5Y7F2UGEYGsV.jpg 发这个图片对比了贫血和充血模型 rich domain model。原文链接 https://blog.pragmatists.com/domain-driven-design-vs-anemic-model-how-do-they-differ-ffdee9371a86

2020-03-21


索旭东

经常以为是面向对象，其实经常是用面向过程

2020-03-19


张三

第一次知道 Collections.unmodifiableList () 这个方法，受益匪浅。

2020-03-18


路人甲

原来我一直 写了这么多的面向过程的代码。

2020-03-04


binarylei


关于滥用 getter、setter 方法，这让我想起了 Spring 中 BeanFactory 类的设计。Spring BeanFactory 只允许查找，不允许修改数据，它提供了一个子类 ConfigurableListableBeanFactory 类则提供了大量的配置方法，如果 setBeanExpressionResolver 等。Spring 中一般提供 BeanFactory 给用户使用，ConfigurableListableBeanFactory 则提供给开发者使用，这样设计避免了滥用 getter、setter 方法，同时也符合单一职能原则。

2020-02-26


88591


原来我一直是手握屠龙宝刀砍柴用。

2020-02-25


悠游

想起了当年刚从 c 转 java 的时候，写的代码被 review，leader 说一眼看过去就是面向过程的代码...

2020-02-24


Scarf


争哥，有个问题，你说‘而是哪个类用到了某个常量，我们就把这个常量定义到这个类中’，那如果某个常量被多个类使用，那在每个使用这个常量的类里都增加一个常量的定义？这样做是不是增加了代码量？？

2020-02-23


未来小娃

其实我觉得之所以用面向对象的编程语言写出面向过程的代码主要是对 OOP 理解的不到位，正如文章所说面向过程编程如何人脑的思考方式，也就是第一部干什么第二步干什么自然而然就写成了面向过程的代码，前面提到两者的区别组织方式的不同，其实写代码的时候多考虑一点，我可以怎么分「块」，每块的职责是什么，每块有哪些内容构成（属性和方法，只要职责明确了这两点也就清楚了）块之间是怎么交互的，这些问题思考清楚才算得上面向对象编程。你想想啊，小到工具类的命名、类的命名，大到现在的若干个微服务，不都是一个个「块」么，所以啊，还是想想清楚到底什么才是面向对象编程以及面向对象编程的四大特性才能在实际的开发中运用自如。扩展一下，为什么很多公司那么注重编程规范其中一个原因是代码的易读性会更好，易读性怎么体现不就落实到这一个个「块」中么。比如大一统的 Constants 类为什么不好，最大的问题就是职责不清晰，你让你一个保安去干财务你觉得合适么，你知道他是保安还是财务呢？！

2020-02-20


Heaven


在实际开发过程中，所有的 Entity 都是使用的 @Data 注解去生成的 getter setter 方法，完全没有封装性

2020-02-18


拉欧

说实话面向对象（以及 DDD）的经典书籍看了一堆，但是没写过几行真正面向对象的代码；上面提到的内容有种灵魂拷问的感觉，也隐约找到了自己一直以来的瓶颈所在

2020-01-17


Wings


没看懂什么叫贫血和充血模型……

2020-01-16


淘海鱼

1. 滥用 getter/setter 方法这一节，本质讲的是对象的自洽性与权限的控制。

2. Util 类中采用面向过程方法是最简洁的最合理的设计，如无必要，勿增实体。

3. 贫血模式。框架的原因所致。而框架为何要如此设计？我理解这是对业务开发友好。

2020-01-16


依韵

滥用 getter setter 的情况确实挺常见，不过这个问题相对来说是比较容易发现和修正的。购物车那个例子中，数据需要外部访问的情况，作为一个前端工程师，常见的处理思路就是将数据深拷贝，供外部使用，即时恶意修改也不会对原来的逻辑造成影响。不过由于基本没写过服务端的代码，不确定此思路是否适用于服务端，会不会内层占用的问题。

面向对象的语言及代码组织形式，却完全写的是面向过程的情况，值得反思。

2019-12-31


桂城老托尼

见了太多 facade bizshare coreservice repository client , 感觉都是在解决过程的问题，真正的 ddd 实践很少见，大部分领域都和表结构一一对应。

2019-12-30


T 神

之前一直在想我们每天都在用 MVC，几乎所有逻辑都在 service 里面，面向对象到底去哪了，希望争哥后面能解惑。

作者回复：后面有讲到的

2019-12-29


Joewing


这一章节 VO BO 让我想到了 DDD

2019-12-27


chief


好多框架对对象序列化都是使用 get set 方法实现的。因为使用了这些框架，不得已创建 get set 方法，这种情况怎么办？

作者回复：这种情况就要脱邪恶也没办法 后面实战篇会讲到

2019-12-27


山下小妖

将整体流程切分，然后自行创建多个类来包装这些代码，没有考虑类是什么，类有哪些属性和行为。这真的是很头疼的一件事，看似有了很多起了名字的类，非但没有帮助理解业务，反而造成了理解障碍。

2019-12-26


小飞

想请问老师，为什么说 JDK 的设计是面向过程的呢？为什么我反倒认为 JDK 里面的设计是面向对象的设计呢？JDK 中，通过类来划分，类中提供了各自不同的方法来实现功能，对于调用者来说直接调用方法实现功能，并不需要考虑实现细节。

作者回复：并没有说 jdk 是面向过程的啊 我是说 jdk 中也存在面向过程的设计

2019-12-26


迷羊

一、哪些代码设计看似是面向对象，实际是面向过程的？

1. 滥用 getter、setter 方法

设计实现类的时候，除非真的需要，否则不要给属性定义 setter 方法。如果 getter 方法返回的是集合容器，也要防范集合内部数据被修改的风险

2.Constants 类、Utils 类的设计问题

这两种类尽量做到职责单一、定义一些细化的小类，比如 RedisConstants、FileUtils，不要定义一个大而全的 Constants 类、Utils 类。将这些类的属性和方法划分归并到其它业务类中是最好不过的了，能提高类的内聚性和代码的可复用性

3. 基于贫血模型的开发模式

因为数据和操作是分开定义在 VO/BO/Entity 和 Controller/Service/Repository 中的

二、在面向对象编程中，为什么容易写出面向过程风格的代码？

1. 因为面向过程编程风格符合人的流程化思维方式。而面向对象编程风格是一种自底向上的思考方式，线将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按流程组装，完成整个任务。

2. 除此之外，面向对象编程比面向过程难一些，类的设计需要技巧和一定设计经验

三、面向过程编程及面向过程编程语言就真的无用武之地了吗？

1. 如果开发微小程序或者一个数据处理相关的代码，以算法为主，数据为辅，面向过程编程风格更适合一些。

2. 面向过程编程是面向对象编程的基础，类中每个方法的实现逻辑就是面向过程风格的代码

四、结论

不管是哪种风格的编程方式，最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。控制好面向过程编程风格的弊端和副作用，在掌控范围呢为我们所用，就不用避讳在面向对象编程中写面向过程风格的代码。

去其糟粕，取其精华。

2019-12-25


