# 0203 理论 3：里式替换（LSP）跟多态有何区别？哪些代码违背了 LSP？

王争 2019-12-11



2.0x



讲述：冯永吉 大小：8.94M 时长：09:45

在上两节课中，我们学习了 SOLID 原则中的单一职责原则和开闭原则，这两个原则都比较重要，想要灵活应用也比较难，需要你在实践中多加练习、多加体会。今天，我们再来学习 SOLID 中的「L」对应的原则：里式替换原则。

整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天我主要通过几个反例，带你看看，哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的「多态」有点类似。所以，我今天也会讲一下，它跟多态的区别。

话不多说，让我们正式开始今天的学习吧！

如何理解「里式替换原则」？

里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的：

If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。

在 1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则，英文原话是这样的：

Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。

我们综合两者的描述，将这条原则用中文描述出来，是这样的：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

这么说还是比较抽象，我们通过一个例子来解释一下。如下代码中，父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息。

public class Transporter {

private HttpClient httpClient;



public Transporter(HttpClient httpClient) {

this.httpClient = httpClient;

}

public Response sendRequest(Request request) {

// ...use httpClient to send request

}

}

public class SecurityTransporter extends Transporter {

private String appId;

private String appToken;

public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {

super(httpClient);

this.appId = appId;

this.appToken = appToken;

}

@Override

public Response sendRequest(Request request) {

if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {

request.addPayload("app-id", appId);

request.addPayload("app-token", appToken);

}

return super.sendRequest(request);

}

}

public class Demo {

public void demoFunction(Transporter transporter) {

Reuqest request = new Request();

//... 省略设置 request 中数据值的代码...

Response response = transporter.sendRequest(request);

//... 省略其他逻辑...

}

}

// 里式替换原则

Demo demo = new Demo();

demo.demofunction (new SecurityTransporter (/* 省略参数 */););

在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。

不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？

我们还是通过刚才这个例子来解释一下。不过，我们需要对 SecurityTransporter 类中 sendRequest () 函数稍加改造一下。改造前，如果 appId 或者 appToken 没有设置，我们就不做校验；改造后，如果 appId 或者 appToken 没有设置，则直接抛出 NoAuthorizationRuntimeException 未授权异常。改造前后的代码对比如下所示：

// 改造前：

public class SecurityTransporter extends Transporter {

//... 省略其他代码..

@Override

public Response sendRequest(Request request) {

if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {

request.addPayload("app-id", appId);

request.addPayload("app-token", appToken);

}

return super.sendRequest(request);

}

}

// 改造后：

public class SecurityTransporter extends Transporter {

//... 省略其他代码..

@Override

public Response sendRequest(Request request) {

if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {

throw new NoAuthorizationRuntimeException(...);

}

request.addPayload("app-id", appId);

request.addPayload("app-token", appToken);

return super.sendRequest(request);

}

}

在改造之后的代码中，如果传递进 demoFunction () 函数的是父类 Transporter 对象，那 demoFunction () 函数并不会有异常抛出，但如果传递给 demoFunction () 函数的是子类 SecurityTransporter 对象，那 demoFunction () 有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进 demoFunction 函数之后，整个程序的逻辑行为有了改变。

虽然改造之后的代码仍然可以通过 Java 的多态语法，动态地用子类 SecurityTransporter 来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。

好了，我们稍微总结一下。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

哪些代码明显违背了 LSP？

实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是「Design By Contract」，中文翻译就是「按照协议来设计」。

看起来比较抽象，我来进一步解读一下。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。

为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。

1. 子类违背父类声明要实现的功能

父类中提供的 sortOrdersByAmount () 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount () 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。

2. 子类违背父类对输入、输出、异常的约定

在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。

在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。

在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。

3. 子类违背父类注释中所罗列的任何特殊说明

父类中定义的 withdraw () 提现函数的注释是这么写的：「用户的提现金额不得超过账户余额……」，而子类重写 withdraw () 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。

以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。

实际上，你有没有发现，里式替换这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂我今天讲的这些，这个原则就不难掌握，也不难应用。

重点回顾

今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。

里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解「design by contract，按照协议来设计」这几个字。父类定义了函数的「约定」（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的「约定」。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

课堂讨论

把复杂的东西讲简单，把简单的东西讲深刻，都是比较难的事情。而里式替换原则存在的意义可以说不言自喻，非常简单明确，但是越是这种不言自喻的道理，越是难组织成文字或语言来描述，有点儿只可意会不可言传的意思，所以，今天的课堂讨论的话题是：请你有条理、有深度地讲一讲里式替换原则存在的意义。

欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview

© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (227)

Chen

135 看设计模式，246 看数据结构与算法。争哥大法好

2019-12-11

年轻的我们

个人理解里氏替换就是子类完美继承父类的设计初衷，并做了增强对吗

作者回复：理解的没错

2019-12-13

辣么大

LSP 的意义：

一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用 LSP 实现更高效的排序算法。

二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合 contract。

三、改进抽象设计。如果一个子类中的实现违反了 LSP，那么是不是考虑抽象或者设计出了问题。

补充：

Liskov 是美国历史上第一个女计算机博士，曾获得过图灵奖。

In 1968 she became one of the first women in the United States to be awarded a Ph.D from a computer science department when she was awarded her degree from Stanford University. At Stanford she worked with John McCarthy and was supported to work in artificial intelligence.

https://en.wikipedia.org/wiki/Barbara_Liskov

2019-12-11

失火的夏天

里氏替换最终一句话还是对扩展开放，对修改关闭，不能改变父类的入参，返回，但是子类可以自己扩展方法中的逻辑。父类方法名很明显限定了逻辑内容，比如按金额排序这种，子类就不要去重写金额排序，改成日期排序之类的，而应该抽出一个排序方法，然后再写一个获取排序的方法，父类获取排序调用金额排序，子类就重写调用排序方法，获取日期排序。

个人感觉也是为了避免「二意性」，这里是只父类的逻辑和子类逻辑差别太多，读代码的人会感觉模棱两可，父类一套，子类一套，到底应该读哪种。感觉会混乱。

总之就是，子类的重写最好是扩展父类，而不要修改父类。

2019-12-11

任鹏斌

里氏替换就是说父亲能干的事儿子也别挑，该怎么干就怎么干，儿子可以比父亲更有能力，但传统不能变

2019-12-11

Kevinlvlc

我觉得可以从两个角度谈里式替换原则的意义。

首先，从接口或父类的角度出发，顶层的接口 / 父类要设计的足够通用，并且可扩展，不要为子类或实现类指定实现逻辑，尽量只定义接口规范以及必要的通用性逻辑，这样实现类就可以根据具体场景选择具体实现逻辑而不必担心破坏顶层的接口规范。

从子类或实现类角度出发，底层实现不应该轻易破坏顶层规定的接口规范或通用逻辑，也不应该随意添加不属于这个类要实现的功能接口，这样接口的外部使用者可以不必关心具体实现，安全的替换任意实现类，同时内部各个不同子类既可以根据不同场景做各自的扩展，又不破坏顶层的设计，从维护性和扩展性来说都能得到保证

2019-12-11

时光勿念

呃，我不知道这样理解对不对。

多态是一种特性、能力，里氏替换是一种原则、约定。

虽然多态和里氏替换不是一回事，但是里氏替换这个原则 需要 多态这种能力 才能实现。

里氏替换最重要的就是替换之后原本的功能一点不能少。

2019-12-11

Jxin

里式替换是细力度的开闭原则。这个准则应用的场景，往往是在方法功能的调整上，要达到的效果是：该方法对已经调用的代码的效果不变，并能支撑新的功能或提供更好的性能。换句话说，就是在保证兼容的前提条件下做扩展和调整。

spring 对里式替换贯彻得不错，从 1.x 到 4.x 能看到大部分代码都坚强的保留着兼容性。

但 springboot 就有点跳脱了，1.x 小版本就会有违背里式替换的破坏性升级。1.x 到 2.x 更是出现跳票重灾的情况。带来的损失相信做过 springboot 版本升级的人都很有感触，而这份损失也表达出坚守里式替换原则的重要性。不过，既然 springboot 会违背经营多年的原则（向下兼容），那么绝非空穴来风，相信在他们看来，违背里式替换做的升级，带来的价值能够盖过损失。所以我觉得里式替换依旧是个权衡项，在日常开发中我们要坚守，但当发现不合理，比如设计缺陷或则业务场景质变时，做破坏性改造也意味着即使止损，是一个可选项。

2019-12-11

墨雨

多态是语法特性，是一种实现方法。里式替换是设计原则，是一种规范。其存在的意义是用来规范我们对方法的使用，即指导我们如何正确的使用多态。

2019-12-11

destiny

VIP 提现可透支这种情况如何不违背里氏替换原则？

2019-12-12

Cy23

听完感觉就是，子类可以无损替换父类，就是里氏替换原则。对否

2019-12-11

知行合一

多态是种能力，里氏是一种约定。能力是摆在那里的，约定却不一定强制遵守，有时候可能会打破约定。需要权衡

2019-12-11

qqq

遵守协议，保证一致性

2019-12-11

ladili

多态是工具，是实在的东西。里式替换是设计思路，是虚的东西。

多态做到外壳，做到结构一致。

里式替换在结构一致的前提下还要保持底层逻辑一致。

设计模式都是用来指导开发的。里式替换指导父类更加抽象复用，子类更加贴近最初的原则。

2020-02-23

雨幕下的稻田

LSP 感觉是在多态的基础上强调了协议的重要性

2019-12-20

帆大肚子

在可拔插的设计中，保证原有代码的正确性

2019-12-11

小文同学

父类假如在协议上约定得非常细，方法命名中说明了实现细节，就会导致子类扩展受限，也是对里氏替换的一种限制。

2020-02-22

董瑞

里氏替换原则存在的意义：

1. 增强父类或接口进行约定，子类进行实现的设计原则，明确父类是抽象定义，子类是具体实现的面向对象编程思想

2. 为子类设计和实现提供了明确而有用的指导思想，子类的协议实现不能超越父类的抽象定义，否则，违背约定的子类实现会导致系统可读性、可运行性会出现不符合预期的逻辑行为

3. 增加了对多态编程方法的应用指导，多态是一种编码实现的思路，设计和实现可以很宽泛，应用里氏替换原则的指导，可以设计出高质量的多态编程，从而让面向对象编程实现的程序的可读性、健壮性更好

2020-01-06

迷羊

一、如何理解里氏替换原则？

1. 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。（示例可查看专栏文章）

2. 里氏替换原则更有指导意义的描述是：按照协议来设计。子类在设计的时候，要遵守父类的行为约定 / 协议。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；注释中所罗列的特殊说明。同理也可以对应到接口和实现类。

二、哪些代码明显违背了 LSP?

1. 子类违背父类声明要实现的功能

父类中提供的 sortOrdersByAmount () 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个方法之后是按照创建日期来给订单排序的。那子类的设计就违背里氏替换原则。

2. 子类违背父类对输入、输出、异常的约定

父类中某个函数约定：运行出错返回 null；获取数据为空时返回空集合。子类重写函数之后，运行出错返回异常，获取不到数据返回 null。那子类的设计就违背里氏替换原则。

父类中某个函数约定，输入数据可以是任意整数，子类实现只允许输入数据是正整数，负数就抛出，也就是说子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里氏替换原则。

父类中某个函数约定，只会抛出 ArgumentNullException 异常，子类的设计实现抛出了其他的异常，那子类的设计就违背了里氏替换原则。

3. 子类违背父类注释中所罗列的任何特殊说明

父类中定义的 withdraw () 提现函数的注释是这么写的：「用户的提现金额不得超过账户余额……」，而子类重写 withdraw () 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。

4. 判断子类的设计实现是否违背里氏替换原则，我们可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行事呗，就有可能说明子类的设计实现没有完全遵守父类的约定，子类就有可能违背了里氏替换原则。

三、多态和里氏替换原则的区别

多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

2020-01-04

G

我感觉里式替换对心智的负担比较大，虽然没有改写父类，但实际父类不再使用了，等同于修改了父类。这种重构让我想起了 js 的痛苦，逻辑都要在运行时才能知道，而且静态编译时，编译器无法帮助推断，还不如多态直接告诉编译器。

2019-12-22

岁月

我觉得，子类的设计更多的是为了增加 "某个需求的实现" 的方式，比如后端，一个读写类，子类可以分别实现多种类型数据库的读写。比如做前端，一个界面的渲染，子类可以提供多种多样的渲染结果。所以一般子类是不会去重写父类的 "按照数量排序" 这种代码，除非真的只是为了优化性能，但是优化性能一般是直接修改父类代码而不是新增一个高性能子类，除非是增加一个 "用空间换时间" 这样的高性能子类，但是这样的子类又变成了我一开头说的：为了增加 "某个需求的实现".

2019-12-20

李小四

设计模式_17:

里氏替换：

协议 (一致性) 带来效率！

从多态的角度，真的可以随便写，越是与父类不同，就显得越多态。

但如果没有限制 / 协议地多态，抽象就困难起来，在任何时候都需要考虑所有子类的实现细节，多态也就没有意义。

2019-12-11

WoW

在继承当中，尽量不要去重写父类的方法

里氏替换原则告诉我们，继承实际上是提高了两个类的耦合性，在适当的情况下，我们可以使用组合，依赖，聚合等来解决问题！

2019-12-19

Treasure

在改造之后的代码中，如果传递进 demoFunction () 函数的是父类 Transporter 对象，那 demoFunction () 函数并不会有异常抛出，但如果传递给 demoFunction () 函数的是子类 SecurityTransporter 对象，那 demoFunction () 有可能会有异常抛出。

——————————————————

为什么可能会有异常啊，看了好久，也没发现原因，求解答。

2019-12-17

秋天

打卡坚持学习

2019-12-15

无道 win

有个疑问，如果现实开发中遇到类似于 SecurityTransporte 类新增校验的情况，那么应该怎么处理呢？是否违背李式替换，在子类中新增父类中没有的异常？

2019-12-11

。华伟

感觉是严格意义上的对扩展开放，对修改关闭

2020-08-25

火影。海诺

没有全新的了解…… 印象深刻的一个理解是，抽象意义上的子类在替换父类后不能改变代码原来的逻辑和程序正确性！还是会回到扩展性这个问题是，替换原则也要准寻的一个原则是你可以扩展我，但你不能改变我！

2020-08-17

Geek_小白

里氏替代原则，父类的行为 子类要与其一致。对修改关闭 对扩展开放。但是我认为重载父方法 在其内部调用 super. 父类方法前后做一些类似日志操作 应该不算是违反了 里氏替代原则吧

2020-04-28

KK

里式替换原则，可以形象的理解为：做一个上进的乖孩子！

2020-04-05

黑客时间

如果我确实需要一个像这种参数校验的功能，如果没有这两个参数，会对后续的业务流程产生影响，那该怎么扩展这个方法呢

2020-03-24

杨小将军

最直接的感受是增加可读性，也就是只要理解父类的方法是做什么的，阅读子类时大原则是不变的，只是逻辑实现会有点不一样

2020-01-02

传说中的成大大

提到里氏替换原则，让我想起了，cpp 的纯虚类，和纯虚函数就有点类似里氏替换，他必须要实现父类的纯虚函数，再由于 cpp 函数编译过程的原因就导致必须要和父类的函数，名字，参数，返回值等等都一模一样！

2019-12-14

Yayu

关于『里氏代换原则』

这个世界上如果没有继承，就不会有里氏代换原则。该原则本质是想用设计规范来约束可能出现的恶劣结果，而这个恶劣结果源于语言层面的劣质特性。

2019-12-12

Zhe_Pu

里式替换原则保证子类的实现不超过父类的接口定义规范，只是对功能的扩展，而不是对功能的修改，满足」对扩展开发，修改关闭「。同时在父类定义的框架下，子类虽然可以扩展，但也不能超过父类定义的范围，也在一定基础上满足了单一设计原则。

2019-12-11

thomas

一个词说里氏替换原则就是：合约。子类要遵守父类设定的合约，也就是设计的初衷。子类改变逻辑思维边界是父类声明的合约。

2019-12-11

狼的诱惑

多态是 JAVA 语法，里氏替换是设计思路和规范；

里氏替换是在多态语法的基础上实现的，在不改变函数原有逻辑的基础上对函数功能的一种增强

老师讲的很好

2019-12-11

高源

听王老师讲的很好理解😊书上的比较绕

2019-12-11

江南一笑

从自然认知上理解子类父类的关系。比如："人" 是 "男人"、"女人" 的父类，但 "成年人" 就不是 "男人","女人" 的父类。把找个逻辑关系把握住了，就抓住了 liskov substitution principle.

2020-12-23

刘建军

感觉一直在违背这个原则，override 就是为了改变行为

2020-12-16

liupan

感觉里氏替换肯定是多态的实现，但是多态不一定满足理氏替换，有可能破坏了原则

2020-12-12

落尘

里氏替换原则，是指导如何设计继承父类的子类的原则。最核心的思想是「design by contract 按照协议设计」，具体来说就是子类不能改变父类的逻辑行为，不能破坏程序的正确性。

其实里氏替换原则与基于接口编程的原则有共通之处，还记得争哥讲接口的时候提到接口就是「contract 协议」。顾名思义就是要遵循「协议」来实现接口和设计子类的方法实现。那么什么是「协议」，归根结底就是，OOP 中类所抽象出来的行为。

里氏替换原则遵循了 OOP 抽象的需要，规范了继承时容易出现的多态问题，避免运行时出现不易察觉的错误。

2020-12-05

狼行天下

LSP 规定子类替换父类，不能改变父类的输入、输出、异常等约定

常见的反例类型包括：1、子类违背父类声明要实现的功能。2、子类改变父类的输入、输出、异常等约定。3、子类违背父类注释中所罗列的特殊说明

作者回复：嗯嗯 ������

2020-11-24

航哥很帅

里式替换原则的关键在于子类继承父类以后，可以改变重写函数的业务逻辑，但是有一些东西是不能改变的，比如：函数声明要实现的功能，输入和输出的限制，抛出异常的情况等。说的更简单一些，里式替换原则其实就是让子类的继承更加增强了。子类可以通过继承来实现多态，但这个继承是有限制的，这个限制就是里式替换原则。

有一个非常简单的检查子类是否满足里式替换原则的方法：用父类中的单元测试方法验证子类中的功能是否正常，如果单元测试出现异常，就说明极有可能子类的实现违反了里式替换原则。

2020-11-17

紫日

用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

2020-10-24

刘长锋

个人理解，里氏替换原则，使类的代码功能设计更规范，更符合源码阅读者的预期，方便维护。

2020-10-23

大力水手 Jerry

在面向对象领域，我们关注多态，除了希望利用函数行为的 ** 差异性 ** 外，还希望函数行为 ** 表现一致 **，确保相关业务逻辑实现的一致：我们希望所有实现类的特定接口行为表现，在输入条件，输出结果（正常和异常）都是一样的。否则我们就需要根据具体类（不论它们是否是父子类，还是接口 / 实现类关系）的不同，定制不同的业务处理逻辑，而这将大大的损害多态的名声。

2020-10-06

朱月俊

Design by contract 适用于不同模块，类，方法之间交互，不会因为模块，类，方法内部实现的改变而影响其他模块，类，方法的功能，从这个层面来说，达到了解耦的效果。

2020-09-27

Harlan

里式替换法则更多是一种开闭原则

2020-09-10

Younger Ku

还有个依赖倒置，和李氏替换也有一定关系吧。今天学了李氏替换感觉理解更深入了一层。

2020-09-09

醉碧川

里氏替换原则的理解，父类能做到的事情，子类必须一板一眼的照做，不能做任何的变动，但是父类没有的功能，子类可以增加。

2020-09-09

大力

里氏替换原则的意义就是，子类可以任意扩充或替换父类的逻辑，前提是在不违反父类制定的「协议」的情况下。

2020-09-08

JerryZhu

里氏替换原则最大作用就是在保证父类实现方法的 入参 出参 异常等不变的前提下，尽可能的实现子类对父类多样化功能的扩展，我来举个例子不知道对不对，老师可以帮我检查一下，比如提现可以发送通知，而父类只有提现的逻辑，子类可以扩充一个异步 mq 提现通知，这个算不算里氏替换，因为发送 mq 通知业务如果并不需要关注是否一定发送成功，那么完全不会影响到原父类逻辑

2020-09-05

郁晨

子类与父类实现逻辑与输入输出的信息都不违背

2020-09-04

宇天飞

LSP：指导子对象的设计，保证子对象继承父对象的行为不变，包括声明、注释、异常、功能等

2020-09-03

郑大钱

里式替换是规范使用多态的一个原则，不改变父类方法原有的执行流程，不修改父类方法的设计初衷，只通过重写的方式来扩展父类的方法。

如果不得已要修改父类的设计，那要考虑看看是不是抽象出了问题，是否需要重构代码。

2020-08-31

好名字

父类方法尽量通用，父类是接口类最好，子类可以任意定义实现，都不会影响里示替换，否则子类重写父类方法，就一定不要修改输入 / 输出 / 异常情况。等于说继承不要无限制的继承。

2020-08-26

TING

子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定

2020-08-22

Henry

感觉实际开发中用多态的情况比较多，很难保证以后会不需要改变父类的行为。

2020-08-20

嘉嘉☕

里氏替换原则，就是对继承行为做了控制，告诉子类标准；并且与开闭类似，不要破坏原有代码的正常运行，不要破坏原有的单元测试

2020-08-20

超越自我

老祖宗定下来的规矩，后代不要打破它，要传承。

2020-08-19

Canon.Din

里式替换几个使用场景

1. 代码重构，提取逻辑，代码迁移或者改调用方时，切记不可手贱优化

2. SQL 拆分时，代码实现 SQL 逻辑就要一个条件一个条件对应，遗漏条件就不满足里式替换了

2020-08-18

David

lsp：按照协议设计。子类只能增强，不能破坏协议。

意义：遵循协议编程 沟通成本低。

2020-08-10

Jason.w

继承要做到增强而不破坏.

2020-08-07

Geek_31594d

遵循协议 继承传统 增强

2020-08-06

克一

里氏替换选择，好比父子关系，子的籍贯，姓这些原则的协议不能改，其他的可以跟老子不一样，比如生几个孩子，娶几个老婆。

2020-08-02

汉江

里式替换原则我觉得意义有两点：1 减少代码出错的概率 2. 减少沟通成本

2020-07-31

写代码的

里氏替换原则存在的意义就是提升代码的可维护性和灵活性。里氏替换原则一般要和静态工厂方法结合，这样替换成子类的工作只需要在这个静态工厂方法里做，而不需要在整个项目中去修改代码。

2020-07-29

Geek_71cea9

多态更多是子类继承父类的一种能力和实现方式，来达到扩展性 ，而里斯替换是一种设计原则 和规范 需要在日常写代码中去遵守

2020-07-09

谭棋钊

我的理解：在面对需求时，我们会想到可以用多态来实现，而在实现的过程中，需要用到里式替换原则的思想

2020-07-02

zlig

多态是一种很强的扩展能力，需要控制使用，比如子类通过多态能把父类的加法扩展成减法。里氏替换原则就是对多态的超能力的一种约束，在上面的例子中，子类的扩展也只能是加法，具体怎么加不管。

2020-07-01

西门吹牛

里斯替换的实现基础是多态和继承，在继承的基础上进行了加强。用多态语法实现的代码，不一定满足里氏替换原则，里斯替换对子类有更高的要求。但是满足里斯替换原则的代码，一定是建立在多态和继承的基础上。

2020-06-30

被过去推开

里氏替换原则最基本的逻辑行为是不破坏原有逻辑的行为。假如我要根据不同的接收方发送不同的消息协议，那么可以依照里氏替换原则，增加或删减消息。

2020-06-25

见南山

里氏替换原则就是，子类重写父类方法时，只能增强原有方法的功能，不能修改本身的逻辑

2020-06-24

maybe a miracle

死扣定义，不属于单一职责原则、接口隔离原则。但是实际上我们认为它是符合单于职责原则、接口隔离原则的，这个函数很简单，只是对一个数的递增后返回递增前的值。是个完整且功能单一的数字操作，符合单于职责原则。对于调用者来说，他希望递增一个数字、递增一个数字并返回之前的值的需求，然后调用这个函数。这个函数并未有其它过多的操作，记录递增前的值也不需要任何其它消耗的操作才能获得，符合接口隔离原则

2020-06-23

maybe a miracle

里氏替换原则指导类继承设计，在扩展的同时不修改原有行为逻辑，实现热替换

2020-06-23

命运的脚步

父类做了边界的设定，子类增强了父类的功能，但不要越过边界。

2020-06-22

maybe a miracle

里氏替换原则的意义：指导子类设计，应该遵循父类的协议。如果一个子类已经不按照父类的协议，这个子类就是有问题或者已经不该继承这个父类了。一个子类违反里氏替换原则，那么使用的时候会产生让人误解的因素，导致类的误用或用错导致代码错误

2020-06-14

N。

里氏替换原则指导设计子类的时对父类的增强，而非改变父类原本逻辑

2020-06-10

scmath

里式替换是指导多态的设计原则，按照契约来扩展父类，契约包含函数「名称」和「注释」要实现的功能、函数的签名 (入参和返回值) 约定、异常处理约定。

golang 对的函数返回值是集合时不要用指针！！空对象、空集合、null 有编译检查可以强制一致。

在编写扩展实现时，违反里式替换不会有编译错误。

2020-06-03

微末凡尘

子类可以完全的替换父类实现相同的功能

2020-06-03

微末凡尘

里氏替换原则就是子类完美的继承了父类的功能，而且做了增强，更加的完善和高效

2020-06-03

Random.nextName()

利用多态的特性进行代码组织和扩展，基于里式替换原则进行子类的设计。

2020-05-23

师哥

里式替换 就是说子类可以替换父类，并且程序的逻辑性和正确性 都不受影响。它的主要原则就是按照协议来设计。

2020-05-18

Next

里式替换的意义：

避免程序出现意外的错误，保证扩展的可靠性；保证逻辑清晰可信，提高可读性、可维护性。

2020-05-13

zhou

里式替换原则，就好比一辆车，低配车是父亲，高配车是儿子。

2020-05-12

Tobias

个人理解里氏替换 可以通过 集合的包含关系来描述：子类的功能逻辑是一个集合，父类的功能逻辑一个集合，子类集合必须包含父类集合。

2020-05-07

刘同青

子类可以重写父类方法，但是要支持父类对该方法所有的定义。作用：当使用多态时，代码中除了实例化时会 new 子类对象，其他代码使用的均是父类中的方法，编码也是根据父类中的方法的定义和注释进行，甚至这时候还没有子类的实现，所以如果子类不遵从父类约定随意重写，就可能完成使用父类方法的代码出现问题，

父类方法定义可能抛出的异常是 ParamException

所以代码中捕获异常

但是有个子类重写后非要抛出 ValidateException，

这就造成获取异常的代码失效，

总结就是：凡事都要有个公共标准，要不然会越来越乱

2020-05-07

编程界的小学生

为啥我觉得策略模式肯定违反了这个原则，因为策略模式针对的不同算法，它的结果正确性肯定会遭到破坏，希望老师解答下，有点困惑。

2020-05-04

Magic

面向对象继承关系中，子类和父类的关系是 is-a，即任何使用父类的地方都可以用子类来代替。这不仅是语法上的，也是语义上的。里氏替换原则就是用来保证这一点的

2020-04-28

指尖流逝

里式替换原则：多态特性的一种现实应用，可以将代码中」某块变化的功能「和不变的功能进行隔离，在有需要的时候灵活替换」变化「，既然是替换，那么就需要遵守规则或约定：输入、输出、异常三者都需要符合既定约束

2020-04-25

郭强

里氏替换原则解决了什么问题，不遵守会造成什么影响？我对这个原则的意思懂了，但理解的不深刻。最好能有实际项目中里氏替换原则带好实际好处的例子！

2020-04-21

minsky

个人理解里氏替换原则是在前提上保证多态特性在使用时不出错的，或则说是让多态特性更完善和精准。可以想象如果子类设计时不遵循里氏替换原则，那么代码使用多态时经常会出现一些意想不到的错误，尤其是父类或者接口有多个子类的时候。

2020-04-16

zhanyd

里氏替换原则就是父类给子类设定的边界，子类可以在边界内自由发挥，但是不能越过边界，超出父类的控制。

2020-04-08

KK

里式替换原则可以形象的理解为：做一个乖孩子。

2020-04-05

改名不换人

里式替换原则的意义我认为就是在我们通过多态 (继承) 来扩展程序的功能时，不能因为扩展了新的功能而影响了原有代码的逻辑，也就是要遵守父类方法的协议，使得子类可以安全的替换所有父类出现的地方。这个原则的关键是：保证原来程序的逻辑行为不变和正确性不被破坏。

2020-04-03

Ray

个人观点：

最后讲到的里式替换原则与多态是区别很重要，更好的区分了这二者的概念

里式替换是设计原则，而多态是代码的实现方式，从本质上来讲是不一样的

2020-04-02

这得从我捡到一个鼠标垫开始说起

里氏替换原则避免替换了实现了之后，出现不正确的行为。

2020-04-01

Nick

我是这么理解的，LSP 原则其实也是符合面向接口编程而不是面向实现编程这一原则的，接口或者是父类定义好的方法，子类则不能违背其约定或者说是原则。

2020-03-31

面向百度编程

如果说按照 design by contract 的话，那么我觉得继承了父类既然不做修改，遵从约定，那么子类就是把原有的功能都继承下来，从而自己在增强原有功能，达到替换效果，感觉有点装饰者模式，代理模式味道，我指的味道是思想上的哈，都是增强功能

2020-03-30

墨鱼

里式替换原则是：按照协议设计，子类如果要修改父类的代码，核心逻辑不能变，实现可以修改，包括注释里写的设计原则。

2020-03-30

鸳鸯戏水蝶

感觉 LSP 和 Java 中子类覆写父类方法要求是一样的。

2020-03-28

韶年

里式替换的使用场景是什么？不符合里式替换的继承有什么坏处？

2020-03-28

韶年

子类调用 super.sendRequest (request)，那子类存在的意义是什么呢？仅仅是设置密码吗？这样子是不是过度设计了。

2020-03-28

韶年

感觉比开闭原则难理解多了，看了两边硬是没看明白。

2020-03-28

Kevin.zhang🌏

不支持 OOB 的 C 语言其实也支持李式替换原则，函数指针真神器！可以实现接口、多态、模板方法等 OO 特性。

2020-03-28

忆水寒

有点类似于继承并增强了父类功能，就像模版模式那样。又有点像策略模式。总之，接口保持和父类一致。

2020-03-26

然

里氏置换原则是用来指导子类继承父类如何设计的原则，子类需要遵守函数原有的约定：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明

2020-03-24

jaryoung

今天学习里氏替换原则，收获如下：

规约要遵守，例如你继承别人的超人的能力，你要去干坏事（大家都知道超人是好人）

约定包括：：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

2020-03-24

陈包佳

里氏原则指导了子类的设计原则，要求子类替换父类后不能破坏父类的功能和逻辑。与多态的区别，多态是面向对象的特性，是程序实现的方法，而里氏原则是指导子类继承父类时的设计原则，要求子类能按照父类定义的功能编写方法，不能改变父类程序的功能，以及输入输出和异常。

2020-03-23

秋风画扇

同面向接口编程一个道理，使用时不需要关注内部实现。里式替换也一样，不能改变规定好的协议，保证接口、方法统一。

2020-03-22

Eden Ma

存在意义：方法实现功能上的同一性、一致性，这样不会导致子类实现的方法出现意料之外的情况.

2020-03-19

林峰峰

design by contract，按照协议来设计，通过父类定义协议，其他子类遵守。这个可以规定子类的行为。大家统一按照一个设计进行，方便外部调用。

2020-03-14

未来小娃

【设计模式笔记 18】20200313

之前理解的里氏替换是子类可以替换父类，里氏替换是是指在不改变父类功能的情况下子类替换父类。但是这个原则能解决什么问题呢，保持程序的扩展性，假如子类替换父类后功能变了就违反了父类的功能特性，逻辑就被改变了，这说明程度不够健壮。那假如一定要改变父类的功能怎么办呢：1）使用接口；2）使用抽象方法，这样任何子类都可以实现自己的逻辑，父类只是一个函数，没有功能的约定。下面说下多态和里氏替换原则的关系，里氏替换是一种指导怎么设计父类和子类的原则，多态是一种语法，没有功能约束，一个是语法一个是原则。

2020-03-13

88591

代码是人来写，所以需要效率和质量。任何有利于效率和质量的设计就是好的，反之则需要权衡利弊，改进设计。大多数情况下面经典的设计原则都是高效率和高质量的设计，但是也需要依据实际情况进行取舍。

2020-03-13

liuxiaoyu

多态，更多的是指从 java 语法层面，父类引用可以指向子类的一个实例，运行时执行子类的方法；

LSP，侧重的是约定父类中被子类重写的方法行为，即重写的方法不能在逻辑上与父类原方法有出入。

所以，两者说的是不同的事情。

2020-03-05

糖

有一点疑问：子类在重载父类的函数之后，如果子类和父类的重载函数对于外在表现完全一致，那么除了实现方法的不同之外，怎么体现子类相对于父类的扩展呢？比如像文中提到的 vip 用户 withdraw（）函数还和普通用户存在一样的行为，那 vip 用户相对于其他用户是不是就没有区别了呢？

2020-02-28

色即是空

大前提就是，易用、易读、易维护、易扩展；LSP，就主要是为了易读，易维护、易扩展好像也包含在里面；心法完全靠领会啊

2020-02-23

Heaven

我个人认为里氏替换原则的存在意义，

1. 方便维护我们的开闭原则 即对修改关闭对扩展开放，避免因为不必要因为新的扩展而打破父类所约定的协议，二是，在重构的时候，在原有服务类的基础上新增子类，在子类当中做到更高效地实现原有的父类的需求，从而替换父类

2020-02-22

嘿泥鳅

我认为回答任何原则的意义都要落地到专栏开头讲到的，如何写出高质量的代码和其评判标准上来。里式替换原则主要指导继承关系如何设计，那么为什么要设计继承关系？是为了让子类能替换父类，那又为什么要替换父类？答案是多态，多态主要解决的是扩展性和复用性，也是很多设计原则、设计模式的实现基础。综上，里式替换原则存在的意义主要解决的是编程中复用性、扩展性的问题。

2020-02-12

巨龙的力量啊

多态是能这么做，里氏替换是应该这么做

2020-02-11

wai

我认为里式替换原则存在的主要意义：一个项目都是团队开发，针对父类会有多个子类，不同的人设计不同的子类的时候要有一个统一的设计标准，确保程序运行时尽量减少未知异常的出现。

2020-02-05

Nestor.liu 刘明丰

里式替换原则存在的意义还是很大的，首先能把这条原则说清楚，一定是一位经验丰富的编码人员，在不断的总结和的出来的宝贵经验。它能解决问题的是在我们使用多态特性的同时基本能保证整体的系统能正常工作，不出现不可预期的情况。

2020-02-04

密码 123456

我觉得，这里用的最好的就是 spring。比如提供的缓存抽象。只要实现对应的接口，就可以轻易的替换使用缓存的规则。

2020-02-02

javaadu

利用 LSP 原则可以实现 OCP，如果违反了 LSP，那么程序也会违反 OCP

2020-01-29

南山

我只关心结果是不是我想要的，你怎么做到我不管

2020-01-29

老余

里式替换原则可以约束父子类行为的关系。任何使用父类的地方可以使用子类替换，并且没有异常行为。理解里式替换原则，最核心的就是理解「design by contract，按照协议来设计」这几个字。父类定义了函数的「约定」（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的「约定」。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

2020-01-28

磊

里式替换原则存在的意义：使父类的行为和属性在被继承的过程中不被修改，以保证程序的稳定性

2020-01-28

SXPeople

历史替换原则：忠于原创，高于原创

2020-01-23

桂城老托尼

学习到了，之前没太注意和多态的区别

2020-01-20

gwen

里式替换就是父类定义了函数的「约定」（或者叫协议），那子类必须按照约定来实现，可以改变函数的内部实现逻辑，但不能改变函数原有的「约定」。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。检验方法是使用父类的地方，使用子类来替换，测试用例是 PASS 的！

2020-01-15

www

里氏替换原则存在的意义：

父类的静态方法其实就是一种约定 / 协议，如果子类继承了父类，而又不遵守这种约定，那么则与「继承」这个特性相违背，这时就应该考虑新写一个父类来继承了

2020-01-15

DFighting

里氏替换原则给我最大的好处是方便扩展，很完美地阐述了子类和父类的关系：继承不代表可以 override 任何逻辑，子类需要遵从父类的 contract。真落到实处，我感觉设计父类的时候就需要很有经验的工程师结合业务涉及基础逻辑和交互框架，不然就是在不断的重构中优化代码。后者应该更现实点

2020-01-13

刘学习来学习

lsp 是设计上面的一种原则，用来指导设计，多态是编程语言提供的能力，换一种语言来理解这个就好理解一点了

2020-01-09

宇宙全栈

LSP 的意义：

1、可读：父类型的变量赋值了一个子类型的实例，这是不用读子类代码，也能确定程序的逻辑。

2、可维护：优化代码时，不用担心有坑，不用改测试用例。

2020-01-07

弹簧人

多态和里氏替换并不冲突。里氏替换也是针对父类和子类而言的。对于父类的方法，多态是指 overide。只要 overide 的方法和父类逻辑是一致的就行

2020-01-07

CHS

子类在继承父类的功能的时候，要在父类原有逻辑的基础上实现增强，不能改变父类的原有的逻辑，保证逻辑的一致性。

2020-01-06

ちよくん

扩展父类的业务实现方案，但是不要修改业务规则以及协议规则

2020-01-05

Yangjing

遵从里氏替换原则，再代码发生改变、扩展时，不会有异常。因为从语法上多态保证了编译时的正确，如果子类无法完全替换父类，有可能程序就会有一些没考虑到的异常

2020-01-03

fomy

1、应用场景有哪些？

答：子类实现父类所有的方法，并且对父类进行增强。符合开闭原则，对扩展开发，对修改关闭。

2、跟面向接口编程有什么区别？

答：（个人见解）面向接口编程也符合里氏替换原则，只是里氏替换原则的其中一种实现而已。想听听大家的理解。

2020-01-03

James

就是遵从父类语意，不修改原有逻辑以及程序正确性。

2020-01-03

程晓擘

二刷啦，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦，进一步思考，父类引用指向子类，我们拿着父类的引用，不知道指向的是哪个子类，所以子类必须遵守父类的规范，要不出了问题，开发者一头雾水。

2020-01-02

啦啦啦

这个原则就是子类可以修改父类的实现逻辑，但是不能改父类对外的约定

2019-12-31

Richie

个人理解，里氏替换原则与多态的关系，就是理论和实践的关系，里氏替换原则指导我们如何正确的使用多态特性。

2019-12-31

程晓擘

二刷喽，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦。

2019-12-30

汤小高

多态是一种编程语言提供的能力，LSP 是限制滥用多态的一种原则和约束，即子类可以重写父类的方法，但是不能修改原父类方法本身要求实现的约定，包括要实现的功能、抛出的异常等，但是子类重写的方法中可以在原父类实现的功能基础上拓展一些新功能。不知道我理解是不是对的？

2019-12-28

Next

如果子类和父类的功能约定不一致，调用者就需要关注子类和父类的细节来保证调用的正确性，而且正确性没有保证；

输入输出约定不一致，客户就不能进行一致性调用，增加了额外编码量和维护成本，而且随着后续的扩展，代码将变得混乱复杂度，可读性，维护性将急剧增加！

2019-12-26

杨松

老师您好，我遇到个问题，和这节课没什么关系，但困扰很久，不知道老师和一起学习的同学们是否有好的建议。问题如下：

我单位有俩个网段：132.XX.XX.XX 和 10.XX.XX.XX，我现在有一台 centos7 的服务器，里面部署着基于 springboot 开发的一个小系统，我现在想在该服务器上配置俩块网卡，132.XX.XX.101 和 10.XX.XX.101，想让两个网段的用户都可以访问，但配置过程中发现我只能在一块网卡的配置文件中添加网关，这样现在造成只能是网关的那个网段可以访问系统，另一个网段的用户根本平 ping 不通，请问大家有什么好办法吗？

2019-12-24

EdisonLi

举个 Android 开发的例子，比如我现在想要实现加载图片功能，想获取 Bitmap, 然后加载，父类定义一个接口用来拿到 Bitmap 实现加载图片的逻辑，假如子类继承的父类老版本使用的 ImageLoader 框架进行加载，现在我想要使用 Glide 进行加载图片，其实最终的目的就是拿到图片的 bitmap，我不管你用什么框架进行加载图片。

2019-12-21

AaronChun

多态于里氏替换原则区别：多态是编程语言中支持的一种特性，增强程序设计的扩展性和复用性，里氏替换是对继承关系中子类该如何设计作出说明。

2019-12-21

yu

个人理解，LSP 存在的意义是为了统一子类和父类的行为，对调用方更可控；避免调用时因为行为不一致，或者新加了子类后出现了新的异常，而调用方未处理的情况。

2019-12-20

被歌唱拯救中

在使用父类的角度有疑问：

针对子类做针对性的编程 (即向下转型，而且是安全的向下转型) 是否可取？是否违反了里氏替换原则？

给人的感觉是，其实是已经违反了里氏替换原则，这样做只是在违反之后采用的补救措施。

java 提供这样的语法，是不是有他的设计考虑？什么时候可以这样使用。

例如：

```java

public void method(BaseClass baseInstance) {

if (baseInstance instanceof ASubClass) {

ASubClass subInstance = (ASubClass)baseInstance;

subInstance.xxxx();

}

}

```

2019-12-20

August

我觉得 LSP 的意义在于，能够完美继承父类现有的约定的同时，又能灵活的按照自己的需求进行重写，就像原则中规定的一样，不要人为的去破坏这种已有的约定就好

2019-12-19

蜗牛

有条理、有深度地讲一讲里式替换原则存在的意义。

：兼容以前实现的代码，减少出错的可能性

2019-12-18

shniu

LSP 的意义是应对复杂多变的需求

首先，我们要合作方之间设计规范，设计约束，设计如何共同完成一件事情

其次，有了规范，可能在不同阶段会有不同的实现来满足不同阶段的发展，那每种实现都必须严格符合规范和约束，不能随意变动，这也是为了尽可能保护协议的稳定性，做到对扩展开放

2019-12-18

陈拾柒

有两个疑问，希望老师解答一下

1. 对于某些没有抽象类的语言，例如 oc，自己实现抽象类的逻辑的时候，定义好抽象类，但是在抽象类中的方法实现，都使用 NSAssert 去抛出异常，这样在开发的时候就可以不能直接使用抽象类，子类必须重写实现抽象类的方法才行。这种是否违背了里氏替换原则，是否有必要在父类中使用 assert 抛出异常？

2. 对于里氏替换原则，子类输入参数的类型范围必须大于父类，这个我可以理解。但是输出类型，准确的说应该是子类输出参数的类型和父类相同或者是父类输出参数的子类吧？老师这一点说的不是很详细，觉得可以作为补充。

2019-12-18

二十四

里氏替换原则的意义：从灵活性上讲，代码调用方的逻辑不需要做修改；从可读性上讲，父类的方法含义和注释不会与子类产生冲突。

2019-12-17

斐波那契

听完这一讲感觉又迷惑了 不违反约定这个可以理解 但是子类不能「修改」父类这个就不清楚了 拿这一讲里面一个例子 -- 子类对于负数就抛异常 相对于父类要求更严格了 -- 来说，如果需求是要求变严格那应该怎么改？直接在父类上改么？

2019-12-17

|･ω･｀)

我对里氏替换原则的理解是：外部在调用子类的时候，和调用父类是一样的，不会导致其他的效果或者影响流程

外部可以安全地替换任意实现类

2019-12-16

落叶飞逝的恋

校验是否满足里氏替换原则：使用父类的单元测试去测试字类的功能模块

2019-12-16

我的心里只有工作

今天看了文章，才明白里氏替换原则

2019-12-16

Kevin

LSP 可以理解为是 开闭原则的边界约束。对扩展开放，开放到什么程度，不能开放到修改了原有代码逻辑。也是对修改关闭的一种体现。

2019-12-16

马哲富

听完感觉恍然大悟

2019-12-16

堵车

违背了里氏替换原则会有什么后果呢？比如有个订单查询方法，参数有多个。父类允许参数都是空，子类要求必须有一个值不为空。子类校验了参数，抛出异常。这样就会违反历史替换原则。这样改回导致什么问题呢？

2019-12-16

Douglas

还是争哥牛，总是把别人解释不通不明的说的彻底。

2019-12-15

246 小言

里氏替换原则是设计准则，多态是我们实现子类时候用到的编程方法，我们设计子类时候应当按照里氏替换原则的准则去设计，当然编程是自由的。

2019-12-15

javaadu

里式替换原则存在的意义：对面向对象程序开发中子类和父类的设计有明确的指导作用 — 子类应该在不影响父类功能的前提下进行功能增强

2019-12-15

淞淞同学

我的理解，多态是满足了语法和编译层面上的转换兼容，没有逻辑实现层面上的转换兼容。里氏替换原则要求的是两个函数可以替换类似重构的要求，不改变原有函数的行为。

2019-12-14

小刀

扩展而非修改

2019-12-14

李稳

里式替换：按协议设计，子类可以改变逻辑，但不能改变约定.

约定 1. 功能 2. 输入输出异常 3. 注释

多态：java 语法特性

里式替换：设计原则，执导子类设计

2019-12-14

join

多态是面向对象编程的一种特征，而里氏替换是编程的设计原则，里氏替换可以通过多态的方式来实现。

里氏替换比多态有更多的约束。

2019-12-13

Miaozhe

里氏替换，能写出低耦合的代码，方便扩展，重减少重构的影响。

不过如果基类设计的质量差，会影响后续子类的实现。

2019-12-13

Miaozhe

多态是思想，指导大家实现程序的可扩展性。

里氏替换原则，是原则和规范，能约束大家，写出可读性，可维护性强的程序。

2019-12-13

相逢是缘

打卡

1、里式替换原则定义：子类对象可以替换程序中任何地方的父类对象，替换之后程序的逻辑和正确性保持不变；

2、核心是 "按协议来设计"，父类定义函数的「约定」，子类可以改变内部分实现逻辑，但是不能改变约定。具体来说需要遵循以下规则不能改变：

1）函数声明要实现的功能

2）输入、输出及异常

3）其他的特殊的约定和说明

从上层接口设计看，这要求在进行接口或父类设计时对上层的约定足够抽象，比较通用。从子类设计看，不要破坏上层的协议约定。

3、里式替换和多态的区别：关注的角度不一样，多态是面向对象语言的一种语法，是编程的一种实现思路。里式替换原则是一种设计原则，用来指导继承关系中子类如何进行设计

2019-12-13

NYang

课堂笔记

里式替换原则是一种代码的设计规范，更多是人为约束的。不同于多态，多态是代码的特性。

多态保证子类在替换父类的过程中程序运行正常，但不要求子类实现符合父类的规范。

而里式替换规定子类的实现必须符合父类的规范，包括但不限于方法的入参，出参，异常等。

2019-12-13

丿淡忘

lsp 存在的意义直白点应该就是保证代码的可读性吧

2019-12-13

小先生

如果就是需要改变父类的实现和期望输出。应该怎么做？

2019-12-13

Geek_e7834d

子类是父类契约的具体实现，但是子类如果扩展了父类怎么办？扩展的功能在调用的时候就无法使用父类的接口，只能转换为子类来调用。这种情况怎么解决呢？ 增加另外一个接口来描述扩展的部分功能？

2019-12-13

quietwater

里式替换原则存在的意义在于面向抽象编程，也就是面向约定编程，父类定义了约定，子类遵守约定，使用时只使用父类，也就是向上转型，符合开闭原则。

2019-12-13

小海

里氏替换主要用来指导子类如何设计，而子类存在的意义就在于功能的扩展，结合里氏替换的定义，得出该原则存在的意义在于保证原有功能稳定的前提下（兼容性），做出更具备健壮性的功能扩展。

2019-12-13

Jackey

前面提到许多设计模式和设计原则都是为了代码的可扩展性。我认为 LSP 也是，当代码需要修改时，直接继承一个类，进行修改，讲父类应用之处都替换成子类。从而达到扩展功能的目的。不知道这样理解对不对

2019-12-12

wenxueliu

这讲非常赞，考虑到大多数人会把里式替换原则理解为多态。关键是把抽象的原则给出了具体可实施的标准

2019-12-12

程斌

另外一种方式接口约定存在，接口是项目一开始就定义好的，而利用里氏替换原则来重写方法，也是保证返回值与参数的一致性，从而可以达到兼容的目的。

2019-12-12

AgCl

听完之后，虽然老师强调了多态和里式替换原则是两个概念，总觉得多态的效果是不符合里式替换原则而有意义的

2019-12-12

随心而至

是人就要吃饭。

男人是人，所以男人也要吃饭。

女人是人，所以女人也要吃饭。

2019-12-12

CarlXu

多态不是为了实现和父类不一定的功能的吗？ 如果子类完全遵守父类的约定，就直接使用父类方法就好了，干嘛要重写呢。

2019-12-12

醉比

第一遍学完这节课，我的问题就是里式替换存在的意义是为啥哈哈哈哈

作者回复：我自己觉得意义也不大 你可以看下我文章里的说明😂

2019-12-12

王喜春

想了解下，使用里氏代换后系统的带来的好处，如哪些开源框架中有使用？

另一方面，现在的业务系统「设计」（姑且叫设计）时，大多不知这个原则，体现的问题是？怎么破解？

2019-12-12

Paul Shan

多态是分离接口与实现，以及抽象类与具体类的具体工具，是编程语言层面的功能。里氏替换替换原则是从对象运行的环境去审视对象的公共方法和属性。所有能够满足接口的对象不但要满足了接口或者基类语言层面的约束（这一点和多态类似），也要满足所有接口和基类功能层面的约束（这一点和多态不同）。

我想 Java 编译期的异常可能就是基于这个层面设计的。但是把异常分为编译期和运行期也增加了很多编程负担，新的语言 Kotlin 就没有这项区分。

我个人觉得这条原则实战中用的不多，因为异常，类型检查等通常是实现细节，放到基类和接口中本身就很值得商榷，接口或者基类足够抽象，派生类足够灵活，一般也就够用了。

2019-12-12

筱乐乐哦

如果不遵循里氏替换原则，可能会有以下问题：

1、类继承会变得很混乱，因此奇怪的行为会发生

2、对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度

个人想法：

1、可以通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。

2、父类设计的应该简单单一，这样子类才能方便拓展，如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。

3、可以检测出自己开发的新功能是否对原有功能产生了影响，这点我感觉很重要

2019-12-12

王小念

「里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。」这里讲到‘不改变原有程序的逻辑’。

后面「父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。」这里又讲到‘可以改变内部时间逻辑’。

乍一看感觉有点矛盾和疑惑。

后来想想，前者可能是指的整个程序上的业务逻辑，后者指的是如何实现这些业务逻辑的具体函数的实现逻辑，不知道理解的对不对？

2019-12-11

AaronYu

里式替换原则存在的意义：子类可以扩展父类的功能，但不能改变父类原有的功能。

2019-12-11

Reloaded

取钱那个例子，子类可以透支取钱为什么就不符合里氏替换原则了呢，而且对于设计原则来讲，难道不应该刨除业务逻辑吗

2019-12-11

左

所有的多态实现，假如不遵循里氏替换原则，就会出异常。

2019-12-11

刘大明

里式替换原则。我觉得应该是父类替换子类，程序的行为没有任何变化。正是因为此，才让开闭原则成为了可能。对修改关闭，对扩展开放。

2019-12-11

阿冰 777

里氏替换原则。我觉得目的就是为了防止以后扩充功能的时候，对原先的父类造成了影响。当子类复写父类的功能，要保证你复写的时候，函数的行为是和原先一样的，这样就不会对原有的功能造成破坏。其实就是理解按协议编程，什么是按协议编程？我们对一个类的函数 / 行为 进行规定，他有前置条件，后置条件，和内部不变式。如果子类复写了他，那么必须保证前置条件不会增强，后置条件不会减弱，内部不定式不变。什么是前置条件，个人理解就是对函数输入的约束，后置条件就是对函数返回的约束，内部不定式可以理解为断言，就是对内部属性进行断言，复写的时候断言依旧全部通过。所以我觉得可以用测试用例来保证里氏替换原则，找到前置和后置的零界点，同时在内部增加断言.

2019-12-11

守拙

课堂讨论 answer:

里氏替换原则 (LSP) 是 OOD 中继承方面的指导原则：凡是父类实例存在的地方，应该可以用子类实例替换，且程序不被破坏。

从程序设计角度自顶向下看，LSP 鼓励使用多态的方式设计 api。

从编码实现的角度看，LSP 约束子类慎重的实现从父类继承的方法，让开发者更谨慎的实现子类，不要违反父类的 Contract，从而提升代码的健壮性。

2019-12-11

[耶] 友超

"里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。" 我感觉这就是答案了，为了保证父类的方法被子类重写时，其基本逻辑不会被改变。

2019-12-11

辉仔 lovers

之前没有想过多态和里式替换的关系，以为使用多态，子类就可以替换掉父类。

总结：多态是面向对象的编程方式。里式替换是一种设计原则，指导子类是如何设计的。

2019-12-11

LJK

接口类也适用吗？

2019-12-11

Eden Ma

LSP 存在的意义我觉得应该是提高了代码的稳定性和易于理解性，后续维护可以更清晰的明白子类的职责，减少一些不明所以的状况发生。

2019-12-11

Crazy.

子类可以扩展父类的功能，但不能改变父类原有的功能

2019-12-11

秋惊蛰

如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换.

事实上，这不止是父类和子类之间的关系，而是接口与实现之间的应该遵守的原则.

2019-12-11

程序员小跃

我所理解的里式替换，最重要的意义在于子类是对父类的进一步的从内容上扩充，但是最终返回的是和父类实现一样的结果。

就像楼上「辣么大」说的第一条，优化父类的算法，提高性能；或者优化里面实现的函数，数据结构的方式，达到自定义的条件，但是最终呈现回同一个想要的结果，这点意义重大。

这样就能很好的扩充现有的一些父类不足的地方，我们可以更好的去操作

2019-12-11

pines

1. 里式替换原则 是子类重写父类接口的限定，不过内部逻辑怎么处理，但是结果的返回，错误的处理必须完全一致。

2. 他的存在意义让开闭原则变得更加健壮。在此降低了业务代码修改的风险

2019-12-11

Smallfly

里氏替换原则可以认为是开闭原则的一种具体运用。子类替换父类，实现了功能的「扩展」，并且修改没有影响原来的使用逻辑，因此可以认为是「关闭的」。

2019-12-11

👽

订单排序的反例：

如果从原有的按照金额排序，变为了按照创建时间排序，是不行的。

但是，如果从单纯按照金额排序，变成了，首要排序条件是金额，次要排序条件是创建时间，这种情况违背里氏替换吗？

2019-12-11

潇潇雨歇

里氏替换原则是一种协议，约定；对于子类的约定，必须要遵守父类函数的约定，如果子类破坏了原有的设计，说明设计没有弄好，我觉得这是设计层面上的指导意义。

2019-12-11

J.Spring

虽然多态和 lsp 角度不同，但感觉 lsp 也是对多态的一种扩展或补充。

2019-12-11

Yayu

只可意会不可言传的东西是不是都不够有生命力？面向协议设计，为什么不把里氏替换原则中的父类替换成接口？如果换成了接口，这个原则有什么必要存在吗？

2019-12-11

evolution

里氏替换是代码涉及多态时，需要参考的一个原则。目的是对外提供一致性的输入输出值

2019-12-11

sprinty

重写的父类方法时，其子类实现对方法外部环境的影响应该小于等于父类。

子类 -> 父类，实现类 -> 接口。

2019-12-11

拂尘

感觉里式替换原则的话，也是上一章的开闭原则的一个支撑咯。因为只有当完全遵守约定进行的扩展，才能够在不修改原有代码的基础，完美的兼容。

2019-12-11

子夜

里氏替换

子类可以在任何地方替换父类，而不影响原有程序的逻辑行为。

里氏替换的好处还是为了使得代码有更好的扩展性和维护性，父类和子类有一样的行为，也方便测试。

里氏替换最核心的就是 design by contract，按照协议来设计这几个字。父类定义了函数的「约定」（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的「约定」。这里的约定包括：

函数声明要实现的功能；

对输入、输出、异常的约定；

甚至包括注释中所罗列的任何特殊说明。

里氏替换和多态还是不一样的，多态是子类可以替换父类，更多情况是在形参上父类接受子类，就可以了。而里氏替换还需要满足约定，替换后，程序逻辑、功能、行为、表达含义还是要跟原有的一样。

2019-12-11

编程界的小学生

我觉得里氏替换也采取了面向对象的多态特性，只是再多态的基础上多了几个约束条件，使函数变的有条不紊。

2019-12-11

PHP 是世界上最好的需要

我理解的 里氏替换强调的是「保留特征」，子类具体实现逻辑与父类可以截然不同，但是对父类而言子类却保留了基本的输入输出约定。对于多态，里氏替换会比较「守规则」而多态则比较「任性」。考虑到应用场景，里氏替换比较适合不同业务线里相同业务点，但是最终的产出是雷同的，只是输入数据和具体实现逻辑存在差异。不对的希望老师指正

2019-12-11

jaryoung

优雅地扩展的作用，而不是瞎扩展。规约大于配置，顺从规约，一切美好。

2019-12-11

William

多态是特性，是面向对象的特性.

里氏替换是原则 - 父类出现的任何地方都可以用子类代替，而不影响功能和逻辑。是定义子类编码的规范，子类对于扩展父类的方法实现的时候 ，不能违背父类定义.

但是还是有点跟多态（重写方法）搞混...

2019-12-11

小晏子

里氏替换的意义在于提供了在不改变原系统设计的前提下，提供了扩展原有软件系统功能的作用。以文中的例子为例，比如原系统退钱的功能（withdraw）并没有通知用户的功能，这时我们为了增加通知的功能，我们可以利用 LSP 原则扩展 withdraw 函数的功能，让其在成功退钱后发送通知出去。

2019-12-11

bearlu

135 学习设计模式，246 学习数据结构与算法

2019-12-11

miracle

什么场景下需要用里式替换选择，这个跟子类扩展父类的功能好像是对立的？

2019-12-11

ghostfevil

个人觉得里氏替换原则的意义在于代码的复用性和可扩展性，里氏替换原则对父类的定义要求足够的通用性，这样子类继承和扩展就方便许多。

2019-12-11

deepz

没明白这样的话，用子类替换的意义。。意思是所有子类功能都一样是吗🤔 还是说继承下来了重写的方法必须按照父类约定的「协议」来，然后子类自己定义的方法用来表示子类与子类间的不同。🤔 就没太明白用多态来实现里氏替换，那多态的意义就。。额。。回头再看看文章回味下🙄

2019-12-11

teddytyy

子类中有方法不是重载自父类的方法是不是就不符合里式替换了？

2019-12-11

阿卡牛

个人觉得主要为了扩展性

2019-12-11

业余爱好者

多态是语法层面的，里式替换是业务层面的。我的理解是，多态是里式替换的子集，是里式替换实现的手段。

父类或接口是一种协议，子类实现必须严格遵守协议实现，这样才能在父类出现的任何的地方用子类任意替换。客户端的使用只需关注父类提供的协议所述的功能。这是面向接口编程的思想。要实现这一目标，子类必须严格按照父类的协议实现。而实现手段是编程语言语法上的多态。

2019-12-11

