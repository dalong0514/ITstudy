# 0507. 享元模式 1：如何利用享元模式优化文本编辑器的内存占用？

王争 2020-03-06

上一节课中，我们讲了组合模式。组合模式并不常用，主要用在数据能表示成树形结构、能通过树的遍历算法来解决的场景中。今天，我们再来学习一个不那么常用的模式，享元模式（Flyweight Design Pattern）。这也是我们要学习的最后一个结构型模式。

跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。今天，我会通过棋牌游戏和文本编辑器两个实际的例子来讲解。除此之外，我还会讲到它跟单例、缓存、对象池的区别和联系。在下一节课中，我会带你剖析一下享元模式在 Java Integer、String 中的应用。

话不多说，让我们正式开始今天的学习吧！

享元模式原理与实现

所谓「享元」，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

这里我稍微解释一下，定义中的「不可变对象」指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set () 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。

接下来，我们通过一个简单的例子解释一下享元模式。

假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个「房间」，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。

public class ChessPiece {// 棋子



为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？

这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：

// 享元类



在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。

那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。

享元模式在文本编辑器中的应用

弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的：如何利用享元模式来优化文本编辑器的内存占用？

你可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。

尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：

public class Character {// 文字




在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter () 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？

实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：

public class CharacterStyle {


public class Editor {



享元模式 vs 单例、缓存、对象池

在上面的讲解中，我们多次提到「共享」「缓存」「复用」这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。

我们先来看享元模式跟单例的区别。

在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。

我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。

我们再来看享元模式跟缓存的区别。

在享元模式的实现中，我们通过工厂类来「缓存」已经创建好的对象。这里的「缓存」实际上是「存储」的意思，跟我们平时所说的「数据库缓存」「CPU 缓存」「MemCache 缓存」是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。

最后我们来看享元模式跟对象池的区别。

对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？

你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。

虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠「复用」这个字眼的话，对象池、连接池、线程池等池化技术中的「复用」和享元模式中的「复用」实际上是不同的概念。

池化技术中的「复用」可以理解为「重复使用」，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的「复用」可以理解为「共享使用」，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。

## 重点回顾

1、享元模式的原理。所谓「享元」，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

2、享元模式的实现。享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。

3、享元模式 VS 单例、缓存、对象池。我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的「复用」理解为「重复使用」，主要是为了节省时间。

## 黑板墙

在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？在文本编辑器的例子中，调用 CharacterStyleFactory 类的 getStyle () 方法，需要在 styles 数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？

### 01

1、在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？没有必要，设计成享元模式主要是为了节省内存资源.ChessPiece 中的 positionX 和 positionY 共占用 8 个字节，而把 ChessPiecePosition 设计成享元模式，ChessPiecePosition 的引用在 ChessPiece 中也是占用 8 个字节，反而还需要额外的内存空间来存放棋盘中各个位置的对象，最终就得不偿失了。当启用压缩指针时，ChessPiece 对象占用 (12+4+4 + 补 4) 24 个字节。当不启用压缩指针时，ChessPiece 对象占用 (16+4 + 补 4+8) 32 个字节。

2、在文本编辑器的例子中，调用 CharacterStyleFactory 类的 getStyle () 方法，需要在 styles 数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？用 map 来存储数据 CharacterStyle, 重写 CharacterStyle 的 hash 方法，查找时就创建出新的对象来获取该 hash 值，用该 hash 值在 map 中查找是否存在，如果存在就直接返回，如果不存在就先添加到 map 中再返回。2020-03-06

### 02

补充一下，对于第二个问题，用 LinkedHashMap 容器并开启它的 LRU 策略来装 CharacterStyle 更好，因为根据一个使用者的习惯，常用的字体风格就是自己最近使用的。2020-03-08





Xion


1. 没有必要，每局游戏的棋子位置不是完全相同的数据，这取决于用户的输入，随着时间的推移会不断地变化。而使用享元模式保存的数据，应当是那些不变的，会被大量对象复用的数据。

2. 可以考虑使用哈希表保存文本格式，用多出来的一点点空间占用换取 O（1）的查询效率。

2020-03-06


Wh1


在避免创建 CharacterStyle 对象同时，以 O (1) 的时间复杂度判断 CharacterStyle 是否已经被创建，代码如下：

public class CharacterStyleFactory {


    private static final Map<Integer, CharacterStyle> styles = new HashMap<>();


    public static CharacterStyle getStyle(Font font, int size, int colorRGB) {


//key = font 的哈希值 + size + colorRGB 以保证哈希值唯一性，同时也避免了重复创建 CharacterStyle 的开销

        int key = font.hashCode() + size + colorRGB;


        if (styles.containsKey(key)) {


            return styles.get(key);


        }


        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);


        styles.put(key, newStyle);


        return newStyle;


    }


}


2020-03-06


hhhh


课后思考题:

1. position 可以使用享元模式，但是对于位置信息而言，两个 short 类型的整数可以表示，大量的位置信息也不会占据太多的存储空间，使用享元模式一定程度上增加了代码实现的复杂度，造成 move () 方法代码不够直观

2. 重写 CharacterStyle 的 hashcode () 方法，使用 map 作为对象池，map 的 key 就是 hashcode () 的值

2020-03-06


Fstar


1. 没有必要。棋盘上位置的点集是有限的，是可以设计成享元的。但我们只需要存两个很小的整数，用上享元代码就会变复杂，另外指针也要存储空间。设计成享元可以，但没有必要。

2. 用哈希表提高查询速度：将 font, size, style 连接为字符串（比如 'yahei-12-123456'）作为 hash 表的 key。

2020-03-07


Wh1


小争哥你好，采用享元模式重构的代码中，CharacterStyleFactory 的 getStyle () 函数是不是设计的有问题。无论 styles 中是否存在已经创建好的享元对象，都会新建一个 CharacterStyle 对象。照这么看，styles 岂不是根本就没有存在的必要了。

我认为代码应该改为如下：

public static CharacterStyle getStyle(Font font, int size, int colorRGB) {


// 遍历 styles, 如果 styles 中有相同对象，则返回

        for (CharacterStyle style : styles) {


            if (style.equals(font, size, colorRGB)) {


                return style;


            }


        }


        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);


        styles.add(newStyle);


        return newStyle;


    }


2020-03-06


Frank


打卡 今日学习享元设计模式，收获如下：

当某个需求中有大量的对象是相似的（或者对象中的某些属性是类似的），且是不可变的，此时可以使用享元设计模式将其进行缓存起来以达到共享使用，节省内存。

个人觉得享元模式体现了 DRY 原则，DRY 原则是说不要写重复的代码，应用到对象存储方面，可以理解为不要存储相同的数据。

2020-03-06


Jackey


前面看的时候就在想感觉有点像连接池，当看到一个「共享使用」，一个「重复使用」时真是有种恍然大悟的感觉

2020-03-06


xk_


像连接池、线程池。我们使用它们的时候，在初始化时会创建好连接或者是线程，在使用的时候就可以直接使用，不需要创建了，节省了创建的时间。

享元模式是共享对象的，是存在于内存中，在设计模式出来的时候，内存条可是嗷嗷贵的啊！在当时节省一点内存，真的是非常高大上的一件事了！

2020-04-17


Monday


private void init() {


        chessPieces.put(1, new ChessPiece(


                ChessPieceUnitFactory.getChessPiece(1), 0,0));


        chessPieces.put(1, new ChessPiece(


                ChessPieceUnitFactory.getChessPiece(2), 1,0));


//... 省略摆放其他棋子的代码...

    }


这段代码的第 2 个 put 的 key 应该是 2 吧

2020-03-14


Rayjun


棋牌中的位置也可以设置为享元，因为棋盘上位置个数有限，使用享元也可以节省内存

2020-03-06


xsbb2


要不要把文字编辑器中的文字设计成享元呢？

正方：常用汉字也就 3000 多个，超过 3000 字原则上就需要

反方：设计成享元能节省多少空间呢？或者会不会更浪费空间？

哈哈😄

作者回复：是个值得讨论的问题～

2020-07-17


小蚂蚁

关于思考题 1，感觉将位置设置成享元也可以啊，因为棋盘的位置是有限且固定的

2020-03-16


Heaven


对于问题一，首先说，围棋棋盘有 361 个点，如果将位置封装成享元模式，要封装 361 个对象，如果拥有大量的棋盘去共享这些位置，那么是可以节省内存的，但是我个人倾向于不使用享元，我们来表示位置的数据类型是 int, 有本身自带的享元对象池，做到了一定的复用，不需要占用太多的内存，而且使用享元对象，在查找享元对象的过程，也需要消耗一定的时间，所以没有必要去为了 4 个字节浪费那么多的事情

对于问题二，这就是一个简单的空间换时间的问题，时间耗时长，那么就用一个空间问题来解决，可以使用一个散列表来进行相关的存储，在 Java 中更是简单，直接使用 Map 对象即可

2020-03-12


kylexy_0817


对于第一个问题，个人认为没必要且不能把位置信息设计成享元吧，因为相同棋子在不同的棋局位置都可能不一样

2020-03-11


Jeff.Smile


要点总结

1 代码实现主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。

2 应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的「复用」理解为「重复使用」，主要是为了节省时间。

思考题:

①位置在棋盘中组合方式比较多变，不适合做成享元

② 可以考虑使用 map 存放 style 数据

2020-03-06


刘同青

感觉享元更像创建型

2020-05-11


Edward Lee


连接池的对象获取需要考虑并发，享元模式中的共享对象则不需要

2020-05-08


Wizard


享元的共享有點類似資料庫為了減少資料冗余範式的概念，透過共通資料提出變成新的表，使在更新，刪除，上有更大的靈活度，例如用戶的個人資料，如果有使用到的地方都要複製一份，那就會變成資料冗余了

2020-05-06


面向百度编程

没有必要：如果设置为享元有排列组合的多重性，如果不设置，则是整体与位置组合，能大大的减少组合带来的风险，对于性能，我觉得可以用二分查找，和 hash 函数（map）存储

2020-05-01


jaryoung


对于问题二，是不是就是 Windows 下如果安装了太多字体，点击 word 获取的字体的时候导致过慢的原因？

2020-04-30


zhengyu.nie


享元大部分场景是等于多例模式，和单例还是有区别的，单例要的是控制进程内唯一对象，享元一般的场景是同一个对象大家一起用，比如扑克牌、棋子。一般都不会只有一个对象

2020-04-29


墨鱼

享元： 共享单元，也就是把大量重复的对象，通过工厂函数创建出来，然后通过引用，达到复用的目的。

我想了一下，好像前端这个模式基本上用不上，因为很少涉及大量的数据（起码我是这样）。也就基本上用不上这个模式。

2020-04-18


张钟强

问题 1：应该需要看同一时间点的局数，如果局数达到一定量的话，所占用的内存会比棋子位置和棋子样式排列组合占用的内存多。

2020-04-15


全炸攻城狮

从享元模式的应用来看，是从会大量创建的目标对象里，抽离出了部分属性（他们的特点是固定或者值的类型有限），这部分属性又封装成一个属性对象，通过工厂模式创建后缓存在 list 或 map 中。用到对象的时候，从缓存中取出这个属性对象组装成我们需要的目标对象。节省的空间就集中在这个属性对象这里

2020-04-02


tt


JAVASCRIPT 中对象共享属性的实现有些类似享元模式，把对象的共有属性放在构造函数的 prototype 属性引用的对象上。只不过 JS 中 prototype 属性的属性是可以动态变化的。推测在 C++ 代码实现时，也是利用 Map 或者 List 来缓存已经创建好的共有属性的。

2020-03-28


change


1、享元即可共享的单元，目的是为了复用对象，节省内存，前提条件是对象不可变；

2、借助于工厂模式，用 List 或 Map 缓存已经创建的享元对象，以达到复用的目的；

3、享元模式 VS 单例模式、缓存、池化技术：不仅看代码实现，还要看设计意图 (即解决的问题)

3.1、单例只能创建一个对象，多例虽然可以创建多个对象，其目的是为了限制对象的个数，享元模式可创建多个对象，且一个对象可被代码多个地方调用，其目的是复用对象，节省内存；

3.2、缓存是为了提供访问效率，而不是节省内存够；

3.3、池化技术虽然也是为了复用 (重复使用), 但是是为了节省时间，而享元模式的复用 (共享使用), 为了节省空间；

2020-03-28


忆水寒

第一个，没必要。

第二个，可以考虑使用 hashmap，查找效率高一些。

2020-03-28


梦倚栏杆

我看到享元模式的第一反应是原型模式，感觉都是抄作业：享元模式，是看着别人的作业抄都懒得抄，直接拿过来上交。原型模式，抄别人作业，写上自己的名字

2020-03-27


辉哥

针对于第二个问题，可以重写 CharacterStyle 的 hashCode 方法，然后使用 hashMap 以 hashCode 为 key,CharacterStyle 对象为 value 来缓存。当调用 getStyle 方法时，先用 CharacterStyle 对象的 hashCode 去查找 hashMap 是否有缓存该对象，有就去判断 equals 是否为 true，为 true 就返回 hashMap 中的对象。hashMap 查询为 null 或者 equals 为 false, 则把对象加入 hashMap 中，并返回该对象

2020-03-22


Geek_3b1096


一直以来误解享元模式 == 单例

2020-03-19


传说中的成大大

关于思考题

1. 我觉得没得必要 享元模式 最主要的就是保存和共享不可变的对象 对于 position 这中随时都在变的对象不合适 而且每个棋局的棋子坐标各不相同 (享元模式 主要是通过对共同的不可变的对象或者字段进行抽取已达到节省内存的目的)

2. 从代码上来看 可以把三个条件通过一个 hash 处理 出一个 hash 值再做映射 即可达到 o (1)

2020-03-18


茄子

getStyle () 方法每次都会创建一个新的 CharacterStyle 对象，这代码难道没有问题吗？

2020-03-17


李小四

设计模式_54:

# 作业

1. 不合适，我看到很多留言分析了内存的占用，说的很有道理，只是享元模式的使用场景是不变的内容，position 数据是随着时间变化的，本来直接给 position 赋值即可，现在要在已知 position 的情况下，找到 value 就是 position 的享元对象，毫无必要的步骤。

2. 可以使用散列表存储，@李湘河 同学的答案特别好，使用 LinkedHashMap 并开启 LRU 策略，很好的细节。

# 感想

保证正确的前提下，我们可以根据需求做一些优化：比如为了更快的运行速度多消耗一些内存，也可以为了更小的内存消耗共享不可变对象。

2020-03-16


L🚲🐱


思考题 1: 没有必要，因为他们不属于大量重复的对象 2. 可以用 map 存储，重写 hashcode, 用 hash 作为 key

2020-03-16


小蚂蚁

1、从业务需求上考虑，每个棋局棋子的位置大都不同，没必要将 chessPiecePosition 设计成享元。2、用 hashmap

2020-03-16


zx


对于百万在线的系统，棋盘的位置数量是有限的，可以设计为享元模式

2020-03-10


不似旧日

spring 的对象注入是复用对象它是用了享元模式么？感觉文中示例代码中的工厂模式也不是必须的；如果不用工厂模式直接把 ChessPiece 注入到 ChessBoard 那么还是享元模式么？

2020-03-09


jaryoung


问题 1：没有必要，因为他们不属于大量重复或者相似对象。

问题 2: map 存储最近几种常用的字体（LRU），如果寻找不到，再进行遍历去找。

2020-03-09


，


课后题 1: 没必要，原因是：使用享元模式的目的是节省内存，然而在当前场景下优势并不明显，以下为个人测试所得

使用工具类：版本为 4.0.0 的 lucene-core 包中的 RamUsageEstimator, 使用方法为 shallowSizeOf ()

测试环境：64 位 oracle JDK 1.8.0_181 , 默认开启压缩指针 (可以在测试类中打断点，然后用 jps 找到当前测试类的 pid, 用 jinfo pid 查看是否有参数 - XX:+UseCompressedOops, 有此参数则为开启着压缩指针)

测试说明：因为引用类型 String,Color 枚举类已经存在享元模式，所以在以下只计算对象 ChessPiece,ChessPieceUnit 的大小，不包含他们内部引用类型的大小

在开启压缩指针的情况下:int 类型长度为 4 字节，引用类型长度为 4 字节

解释:

案例一中的 ChessPiece 大小为：12 (markword+klass)+4+4+4+4+4=32 Bytes

案例二中的 ChessPieceUnit 大小为：12 (markword+klass)+4+4+4=24 Bytes

案例二中的 ChessPiece 大小为：12 (markword+klass)+4+4+4=24 Bytes

基于以上，在有一万场对局的情况下:

案例一: 32*30*10000 = 9600000 bytes = 9375 kb

案例二: 24*30+24*30*10000 = 7200720 bytes = 7032 kb

也就是说，如果以上逻辑没有错的话，案例二只比案例一节省了 3mb 左右的内存，优势并不明显

2020-03-09


李湘河

问题 1：没必要，位置信息一直在变，不符合使用享元模式的特征；

问题 2：由于常用的字体格式就是那么几种，这里可以使用 LRU 队列存储；

2020-03-07


岁月

课堂讨论题

第一题，我的回答是：没必要，这是因为一个指针在 64 位机器上的大小一般是是 8 个字节，而棋盘的位置信息，我估计可以用一个短整形来表示，一个短整形占用字节数大概就是 2 个字节到 4 个字节，所以一个坐标占用的大小都没超过一个指针的内存大小。

这道题总的来说，要不要用享元模式，主要是看能节约多少内存，如果节约不了或者节约没多少的话就没有这个必要了。

第二题，万能的散列表又来了，可以把多个属性的内容转成一个哈希，作为 key 放到跑列表里，这样就能快速访问了。。。😹

2020-03-07


Jemmy


最近看在 Redis 源码，有个这个全局对象，感觉用的就是享元模式：

// server.c


struct sharedObjectsStruct shared;


2020-03-07


辣么大

享元模式：复用不变对象节省空间。

何时使用：系统中存在大量重复对象，考虑使用享元模式。（对象，相同的字段等等）

如何使用：Java 中使用 List 或者 Map 缓存创建好的对象。

与池化的区别：池化：空间换时间，例如连接池提前创建。

2020-03-07


webmin


1. 在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？

没有必要设计为享元，但是如果从节省存储空间的角度考虑，可以进行压缩，棋盘的大小是有限且固定的（围棋 19*19 应该是最大的棋盘），可以把 x,y 二维表示法，变为一维表示，这样有压缩效果，具体如下：以围棋为例 x 表示第几行，y 表示第几列的话 pos = (x * 19) + y，反推 x = pos/19,y=pos%19

2020-03-07


小刀

position 的位置相对来说，是有限的，也可以设计为享元

2020-03-07


相逢是缘

一、定义（理解）：

当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

二、使用场景：

同上

三、实现方式：

享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。

四、享元和单例、缓存、对象池

应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的「复用」理解为「重复使用」，主要是为了节省时间。

（区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题）

2020-03-07


迷羊

之前学设计模式中都说池化技术就是用了享元模式，争哥这里做了更细致化的区分👍。

2020-03-07


Demon.Lee


/*


     * Note that it is generally necessary to override the {@code hashCode}


     * method whenever this method is overridden, so as to maintain the


     * general contract for the {@code hashCode} method, which states


     * that equal objects must have equal hash codes.


     */


     public boolean equals(Object obj) {


        return (this == obj);


    }


老师故意只重写了 equals 方法，没有重写 hashCode 方法，是为了第二道思考题吧，真的用心良苦，突然被感动了😭。

2020-03-06


守拙

1. 在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？

绝对有必要。棋盘上的 position 是有限的，如果通过枚举创建享元对象，会节省大量的内存.

   


2. 在文本编辑器的例子中，调用 CharacterStyleFactory 类的 getStyle () 方法，需要在 styles 数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？

为 CharacterStyle 类添加扩展字段，记录被使用次数。每次调用 getStyle () 使用快排按照被使用次数排序遍历.

2020-03-06


do it


课堂讨论

讨论 1、没有必要，因为每个棋子的位置可能一样。

讨论 2、可以采用 map

2020-03-06


Eden Ma


1. 我觉得没必要吧，因为棋子是不断变化的。可以考虑共享一个初始状态.

2. 可以改成 hashMap 存储.

2020-03-06


阿德

在棋盘中，各个位置都是固定，如果房间数比较大，那么这些位置也是可以作为共享以节省空间的

2020-03-06


hanazawakana


位置应该不会被共享使用吧。另外遍历可以改成 hashmap。

2020-03-06


test


1.int 占用四个字节，而设计为 map 或者 list 需要有容器和指针的消耗，个人认为没有必要做成享元；

2. 可以做成 hashmap

2020-03-06


小晏子

因为享元模式主要是共享那些不可变对像，所以对于 position 这种会经常变化的属性不适合设计成享元。

遍历 list 耗时，那我们可以使用 map 来存储 characterStyle，map 的 key 可以是 font size colorRGB 连接成的字符串或者通过它们计算出的 hash 值，value 就是 characterStyle 对象，当查找时，先判断 key 是不是存在了，如果已经存在，直接返回 value 值，反之，将 value 存到 map 里。这样查找时间复杂度 O (1)。

2020-03-06


黄林晴

打卡

2020-03-06


上善若水

争哥讲的，的确透彻。

2020-03-06


高源

学习设计模式课程有一段时间了，需要思考和加深学习的东西很多啊，如何能把学习的这些设计模式运用到实际的开发中是我最终想法，无论那种模式，都有你学习的地方😊

2020-03-06


