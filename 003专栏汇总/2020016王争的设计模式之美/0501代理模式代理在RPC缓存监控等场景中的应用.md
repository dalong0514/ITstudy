# 0501. 代理模式：代理在 RPC、缓存、监控等场景中的应用

王争 2020-02-21

前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。

其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，「定制化」地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

从今天起，我们开始学习另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。

话不多说，让我们正式开始今天的学习吧！

代理模式的原理解析

代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。

这个例子来自我们在第 25、26、39、40 节中讲的性能计数器。当时我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：

public class UserController {


//... 省略其他属性和方法...

private MetricsCollector metricsCollector; // 依赖注入

  public UserVo login(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


//... 省略 login 逻辑...

    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


//... 返回 UserVo 数据...

  }


  public UserVo register(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


//... 省略 register 逻辑...

    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


//... 返回 UserVo 数据...

  }


}


很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。

为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：

public interface IUserController {


  UserVo login(String telephone, String password);


  UserVo register(String telephone, String password);


}


public class UserController implements IUserController {


//... 省略其他属性和方法...

  @Override


  public UserVo login(String telephone, String password) {


//... 省略 login 逻辑...

//... 返回 UserVo 数据...

  }


  @Override


  public UserVo register(String telephone, String password) {


//... 省略 register 逻辑...

//... 返回 UserVo 数据...

  }


}


public class UserControllerProxy implements IUserController {


  private MetricsCollector metricsCollector;


  private UserController userController;


  public UserControllerProxy(UserController userController) {


    this.userController = userController;


    this.metricsCollector = new MetricsCollector();


  }


  @Override


  public UserVo login(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


// 委托

    UserVo userVo = userController.login(telephone, password);


    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


    return userVo;


  }


  @Override


  public UserVo register(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


    UserVo userVo = userController.register(telephone, password);


    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


    return userVo;


  }


}


//UserControllerProxy 使用举例

// 因为原始类和代理类实现相同的接口，是基于接口而非实现编程

// 将 UserController 类对象替换为 UserControllerProxy 类对象，不需要改动太多代码

IUserController userController = new UserControllerProxy(new UserController());


参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？

对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：

public class UserControllerProxy extends UserController {


  private MetricsCollector metricsCollector;


  public UserControllerProxy() {


    this.metricsCollector = new MetricsCollector();


  }


  public UserVo login(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


    UserVo userVo = super.login(telephone, password);


    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


    return userVo;


  }


  public UserVo register(String telephone, String password) {


    long startTimestamp = System.currentTimeMillis();


    UserVo userVo = super.register(telephone, password);


    long endTimeStamp = System.currentTimeMillis();


    long responseTime = endTimeStamp - startTimestamp;


    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);


    metricsCollector.recordRequest(requestInfo);


    return userVo;


  }


}


//UserControllerProxy 使用举例

UserController userController = new UserControllerProxy();


动态代理的原理解析

不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。

如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的「重复」代码，也增加了不必要的开发成本。那这个问题怎么解决呢？

我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？

如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。

public class MetricsCollectorProxy {


  private MetricsCollector metricsCollector;


  public MetricsCollectorProxy() {


    this.metricsCollector = new MetricsCollector();


  }


  public Object createProxy(Object proxiedObject) {


    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();


    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);


    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);


  }


  private class DynamicProxyHandler implements InvocationHandler {


    private Object proxiedObject;


    public DynamicProxyHandler(Object proxiedObject) {


      this.proxiedObject = proxiedObject;


    }


    @Override


    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {


      long startTimestamp = System.currentTimeMillis();


      Object result = method.invoke(proxiedObject, args);


      long endTimeStamp = System.currentTimeMillis();


      long responseTime = endTimeStamp - startTimestamp;


      String apiName = proxiedObject.getClass().getName() + ":" + method.getName();


      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);


      metricsCollector.recordRequest(requestInfo);


      return result;


    }


  }


}


//MetricsCollectorProxy 使用举例

MetricsCollectorProxy proxy = new MetricsCollectorProxy();


IUserController userController = (IUserController) proxy.createProxy(new UserController());


实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。

代理模式的应用场景

代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。

1. 业务系统的非功能性需求开发

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。

如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。

2. 代理模式在 RPC、缓存中的应用

实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。

关于远程代理的代码示例，我自己实现了一个简单的 RPC 框架 Demo，放到了 GitHub 中，你可以点击这里的链接查看。

我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？

最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。

针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。

重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。

1. 代理模式的原理与实现

在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

2. 动态代理的原理与实现

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的「重复」代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

3. 代理模式的应用场景

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。

课堂讨论

除了 Java 语言之外，在你熟悉的其他语言中，如何实现动态代理呢？

我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。

欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (75)

小兵

组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。

继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。

2020-02-23


大土豆

争哥的专栏，真的是太影响我了，每个设计模式都贴近实战，无比通透，今年我做了一个很重要的决定，我要把 23 种设计模式，都用在项目中。

2020-02-21


，


java 中，动态代理的实现基于字节码生成技术 (代码里就是 newProxyInstance 片段), 可以在 jvm 运行时动态生成和加载字节码，类似的技术还有 asm,cglib,javassist, 平时编译 java 用的 javac 命令就是字节码生成技术的 "老祖宗"

java 中用到字节码生成技术的还有 JSP 编译器.AOP 框架，反射等等

深入理解 java 虚拟机第三版里对动态代理的描述:

动态代理中所说的 "动态", 是针对使用 Java 代码实际编写了代理类的 "静态" 代理而言的，它的优势不在于省去了编写代理类那一点编码工作量，而是实现了可以在原始类和接口还未知的时候，就确定了代理类的行为，当代理类与原始类脱离直接联系后，就可以很灵活的重用于不同的应用场景之中

     


2020-02-21


LJK


是时候展示我动态语言 Python 的彪悍了，通过__getattribute__和闭包的配合实现，其中有个注意点就是在获取 target 时不能使用 self.target，不然会递归调用 self.__getattribute__导致堆栈溢出：

class RealClass(object):


    def realFunc(self, s):


        print(f"Real func is coming {s}")


class DynamicProxy(object):


    def __init__(self, target):


        self.target = target


    


    def __getattribute__(self, name):


        target = object.__getattribute__(self, "target")


        attr = object.__getattribute__(target, name)


        


        def newAttr(*args, **kwargs):


            print("Before Calling Func")


            res = attr(*args, **kwargs)


            print("After Calling Func")


            return res


        return newAttr


2020-02-21


trier


粗略「翻译」至 PHP，中间省略了很多关键的判断，主要是想知道有多少 PHPer 在看。

interface IUserController


{


    public function login(String $telephone, String $password);


    public function register(String $telephone, String $password);


}


  


class UserController implements IUserController


{


    public function login(String $telephone, String $password)


    {


        echo 'is Login' . PHP_EOL;


    }


  


    public function register(String $telephone, String $password)


    {


    }


}


class MetricsCollector


{


    public function recordRequest($requestInfo)


    {


    }


}


class RequestInfo


{


    public function __construct($apiName, $responseTime, $startTimestamp)


    {


    }


}


class MetricsCollectorProxy


{


    private $proxiedObject;


    private $metricsCollector;


    public function __construct(MetricsCollector $metricsCollector)


    {


        $this->metricsCollector = $metricsCollector;


    }


    


    public function createProxy(object $object)


    {


        $this->proxiedObject = $object;


        return $this;


    }


    public function __call($method, $arguments)


    {


        $ref = new ReflectionClass($this->proxiedObject);


        if (!$ref->hasMethod($method))


            throw new Exception("method not existed");


        $method = $ref->getMethod($method);


        $startTimestamp = time();


        $userVo = $this->callMethod($method, $arguments);


        $endTimeStamp = time();


        $responseTime = $endTimeStamp - $startTimestamp;


        $requestInfo = new RequestInfo("login", $responseTime, $startTimestamp);


        $this->metricsCollector->recordRequest($requestInfo);


        return $userVo;


    }


    private function callMethod(\ReflectionMethod $method, $arguments)


    {


// 前置判断省略

        $method->invokeArgs($this->proxiedObject, $arguments);


    }


}


$proxy = new MetricsCollectorProxy(new MetricsCollector);


$userController = $proxy->createProxy(new UserController);


$userController->login(13800138000, 'pwd');


2020-04-11


辣么大

感谢争哥，今天终于学会了「动态代理」

还是要动手试试，代码在这是 https://bit.ly/37UqLNf

学有余力的小伙伴，附上一些资料吧：

https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html


https://www.baeldung.com/java-dynamic-proxies


2020-02-25


Eden Ma


1、OC 中通过 runtime 和分类来实现动态代理.

2、组合优势可以直接使用原始类实例，继承要通过代理类实例来操作，可能会导致有人用原始类有人用代理类。而继承可以不改变原始类代码来使用.

2020-02-21


webmin


1. .net 支持反射和动态代理，所以实现方式和 java 类似；golang 目前看到的都是习惯使用代码生成的方式来达成，根据已有代码生成一份加壳代码，调用方使用加壳代码的方法，例好：easyJson 给类加上序列化和反序列化功能；gomock 生成 mock 代理。

2. 组合与继承的优缺点：

没有绝对的优缺点，要看场景比如：

当被代理的类所有功能都需要被代理时，使用继承方式就可以编译器检查（被代理类修改时编译期就可以检查出问题）；

当被代理的类只是部分功能需要被代理时，使用组合方式就可按需代理，但是如果原来不需要的，后来也需要了就比较尴尬了。

继承可能会让代理类被迫实现一些对代理类来说无意义代码，继承方式对代理类的侵入比较大，而组合的侵入影响比继承可控。

2020-02-21


Jeff.Smile


动态代理有两种:jdk 动态代理和 cglib 动态代理。

2020-02-21


不似旧日

笔记：

- 什么是代理模式：它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

- 代理模式得实现：

- 静态代理

1. 实现被代理对象口： 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。

2. 继承被代理对象：代理类继承原始类，然后扩展附加功能。

- 动态代理 ： 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

1. jdk 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。

2. cglib 动态代理是利用 asm 开源包，对被代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。

2020-02-24


distdev


请问 如果对于业务方法 有多个非业务功能 比如 metrics, logging 还有其他的 应该实现在一个代理 class 里？还是一个 filter chain 里？

2020-02-24


迷羊

Java 中的动态代理原理就是运行的时候通过 asm 在内存中生成一份字节码，而这个字节码就是代理类的字节码，通过 System.getProperties ().put ("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); 设置可以保存这份字节码，反编译后看下其源码就知道 Java 中的动态代理是什么原理了。

2020-02-22


小晏子

C# 中可以通过 emit 技术实现动态代理。

基于继承的代理适合代理第三方类，jdk 中的动态代理只能代理基于接口实现的类，无法代理不是基于接口实现的类。所以在 spring 中有提供基于 jdk 实现的动态代理和基于 cglib 实现的动态代理。

2020-02-21


lcf 枫

目前看到这里有点懵 分不清代理和装饰器了

2020-03-22


阿德

动态代理那里的 invoke 方法的第一个参数 proxy 有什么用，一直搞不清楚

2020-03-09


Summer 空城

老师好，有个地方不太明白，请指点下。

Spring 框架实现 AOP 的时候是在 BeanFactory 中生成 bean 的时候触发动态代理替换成代理类的么？

如果我们自己想对某个 Controller 做代理的时候要怎么处理呢？一般是用 @Controller 注解某个 Controller 的，而且这个 Controller 不会实现接口。

谢谢老师！

2020-02-21


老余

动态代理和 js 中的类装饰器如出一辙哈

2020-03-24


Monday


针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。

如此后台不也得需求实现两套代码吗，cached=true 查询缓存，其他的走实时查询。

2020-03-12


小文同学

继承的代理类是通过重写来实现代理，如果超类本身方法间会调用，则被新增的代码也会被重复调用。这其实已经是一种修改，不是一种扩展了。相比下，组合型代理就没有这个问题

组合型代理需要原来的类有接口 (抽象类)，代理类可以实现接口，来通过组合构成代理。继承型代理则没这个问题。

2020-03-07


whistleman


打卡～看懂啦，写的真好

2020-02-27


cricket1981


@Aspect


@Component


public class CacheAspect {


    @Pointcut("execution(* com.example.demo.controller..*(..))")


    public void controller() { }


    @Around("controller()")


    public Object around(ProceedingJoinPoint point) throws Throwable {


        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();


        Map<String, String[]> parameterMap = request.getParameterMap();


        Object retVal = null;


        if (parameterMap.containsKey("cached") && parameterMap.get("cached")[0].equals("true")) {


            // parameterMap


            System.out.println("get data from cache");


retVal = 1; // 省略从 cache 获取值

        } else {


            Object[] args = point.getArgs();


            retVal = point.proceed(args);


        }


        return retVal;


    }


}


2020-02-25


贺宇

python 的装饰器是不是代理模式

2020-02-23


hanazawakana


组合比继承更灵活，但可能需要重复的代码实现，这就需要用到委托技术解决。继承更简单，如果相应类的行为不太会改变，可以用继承。

2020-02-21


放个屁臭到了自己

为啥我感觉静态代理像是装饰器模式

2020-08-03


夜空咏叹调

以前在使用 java 的动态代理时都有点知其然而不知其所以然的感觉，一直没想明白为什么要多构造一个代理类出来，今天看代理模式突然有种豁然开朗的感觉，这个专栏真的收获很多！！

2020-07-23


小猛

- 什么是代理模式：它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

- 代理模式得实现：

- 静态代理

1. 实现被代理对象口： 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。

2. 继承被代理对象：代理类继承原始类，然后扩展附加功能。

- 动态代理 ： 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

1. jdk 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。

2. cglib 动态代理是利用 asm 开源包，对被代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。

2020-07-06


小猛

https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html


https://www.baeldung.com/java-dynamic-proxies


2020-07-06


蹦哒

iOS 的同学们，突然又想到，类似 UITableView 这种在自己内部调用 delegate 的设计，和标准的代理模式代码实现方法的差别其实是：因为是框架，所以在代理模式的基础上使用了依赖反转，所以由框架来调用代理类了

2020-07-03


蹦哒

iOS 同学一起来讨论一下是不是这样哈：有些系统类直接用 delegate 作为属性值，比如 UITableView（包括 delegate、dataSource），看起来和代理模式的代码实现不一样，但是作用是一样的，就是给原始类增加和原始类无关的功能，这应该也算是代理模式了；另外，从行为角度或者说算法角度来看，iOS 中的这种实现属于模板模式，即在原始类的扩展点上扩展功能

2020-07-03


见南山

面向接口的所有子类都必须代理，会出现将不需要代理的类也必须去代理的情况。接口可以实现多个、灵活、可以代理多个同一个类型的对象。

继承模式的优点是只需要代理需要的某几个方法，缺点是必须针对特定的父类代理。

2020-06-30


无双 BaOY_WHA

C++ 没有反射机制，因此实现动态代理比较复杂（我感觉必须先自己实现一套反射机制才行）。

不过，C++ 代码中可以嵌入其他脚本语言（如 lua ），动态加载、运行脚本……

2020-06-18


aoe


代理模式和装饰器模式有点像，我觉得最大区别是：代理模式只拦截一次原始逻辑，装饰器模式可以多次嵌套拦截原始逻辑。

看到动态代理的代码，突然意识到，作为一个 Java 程序员居然看不懂这段代码，要赶快补习了。

几个月之后再来看这篇文章，以前看过居然全忘了……

2020-06-18


宁悦

代理模式的应用场景：

1. 业务系统的非功能性需求开发，如：监控，统计，鉴权，限流，事物等，这些功能需要在不破坏原有功能的基础上，添加新的功能。

2. 在 RPC，缓存中应用。

实现方法：

1. 通过接口实现，业务类和代理类实现同一个接口，在代理类的实现中，调用业务类的代码。

2. 通过继承的方式实现，没有办法实现定义接口的时候，通过继承的方式来实现代理

3. 当需要代理的类过多的时候，采用动态代理的方式来减少系统的代码量。

动态代理参考链接：https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984

2020-06-11


Kevin


基于继承的静态代理实现的 demo 中稍微有些瑕疵。

login () 和 register () 方法应该直接调用 super.login () 和 super.register () , 然后再 super 前后插入额外的代码 。这样更像在代理，而不是在继承修改父类。给争哥提个不成熟的小建议。

作者回复：我看看，多谢！

2020-06-02


👽


AOP 简直是代理模式的最佳实践。

2020-05-27


Geek_小白

代理顾名思义 就是对要调用的方法再次封装到一个新类中，这个类会调用你需要目标方法。

一、

function a (){// 要做的事}

function 代理 (){

// 你可以在你要代理的方法前加逻辑

a();


// 也可以在方法后面加

}


调用 代理 ()

二、动态代理

所有要被代理的类都是用同一个规范。

比方说都用 invoke (){具体逻辑}

a.invoke


b.invoke


c.invoke


..... 这样写太麻烦。

可以在动态代理类中放一个 list<string> 变量

用来存存储要代理的类名

动态代理里面调用方法

public void invoke(){


迭代 list

    {


反射 创建被代理的具体类

具体类.invoke

    }


}


2020-05-26


nil


看完了，代理和装饰者傻傻的分不清，看目录后面有讲解区别和联系，加油学习

2020-05-07


俊哥

想到了代理模式的另一个应用场景，对被代理类的接口进行访问权限控制，比如只有特定对象才有权限调用被代理类的接口，非法对象调用接口返回失败。

2020-05-06


zhengyu.nie


代理现在应用的确实比较广泛，比如说用 byte-buddy 或者 cglib (基本上不更新、byte-buddy 可以推一下了)。

常见的有 rpc client 端、aop 切面、注解元驱动、mybatis mapper 之类的。

争哥下面这段话已经非常精准了～

"代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发"

2020-04-29


夏目

继承模式局限于 Java 的单继承，但可以选择实现代理。组合模式必须全部代理，可以灵活选择代理的子接口

2020-04-26


面向百度编程

我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。

组合相对于灵活，能更好的替换组合，而继承耦合度高，如果过于复杂，不好维护

2020-04-22


墨鱼

代理模式是：不改变原始类代码的情况下，通过引入一个代理类，给原始类添加功能。

感觉这个可以跟 VPN 的原理一样。不改变原始网络，只是通过一个代理服务器，让原本不能访问的网站能访问。

JavaScript 的 ES6 有一个 proxy, 实现代理模式优先考虑这个

2020-04-15


布吉岛

动态代理有两种，jdk 的动态代理（面向接口，obj.getInterfaces ()），cglib 的动态代理（面向类，obj.superClass ()），spring aop 使用的是 cglib 动态代理

2020-04-11


xk_


基于组合的代理模式，实现起来很方便。缺点是无法对第三方类库进行代理。

基于继承的代理类，如果需要代理的方法和类太多了，就会导致重复代码过多，扩张性不够好。

2020-04-08


xzy


组合模式，即使一个简单的功能类，也需要定义接口，开发起来比较麻烦

继承模式，无法重写 final 方法，因此父类中的 final 方法无法被代理

2020-04-07


嘻哈

争哥，rpc demo 中 server 用 多线程的方式作用是什么，不太懂

2020-03-28


杰洛特

请问老师，动态代理里面 invoke 函数的第一个参数 Object proxy 有什么用呢？函数实现过程里并没有用到这个参数。

2020-03-26


梦倚栏杆

我有个疑问：为什么 java 的原生库只支持实现代理接口的匿名类呢？按照老师的说法：可以有接口用接口，没有接口继承父类就好。为什么非得限制一下呢？是因为担心有一些类或者方法声明为 final 或者 static 违反继承原则吗？那 cglib 修改字节码就可以突破这个限制？

2020-03-24


韵呀

纸上得来终觉浅，绝知此事要躬行。

2020-03-19


不学不行啊

单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，「定制化」地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

2020-03-19


刘伟龙

@Override


        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {


            long startTimestamp = System.currentTimeMillis();


            Object result = method.invoke(proxiedObject, args);


            long endTimeStamp = System.currentTimeMillis();


            long responseTime = endTimeStamp - startTimestamp;


            String apiName = proxiedObject.getClass().getName() + ":" + method.getName();


            RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);


            metricsCollector.recordRequest(requestInfo);


            return result;


        }


proxy 应该是 proxiedObject 吧，是不是写错了

2020-03-14


Heaven


今天我回答下第二个问题，在原有的 JDK 中的代理，是一种基于接口的代理模式，要求代理类只能去代理某些接口，于是乎，为了能直接代理一个代理类，cglib 加入了，可以传入一个对象实例，来进行包裹，从而达到代理这种需求，两者实际来说，JDK 的代理类创建时间比 cglib 快的太多了，于是乎更加适合在框架中定义为非单例的类去代理，cglib 适合于生成单例式类的代理类

2020-03-10


霹雳大仙 pp

优先组合；

面向抽象编程，代理和被代理类两者都依赖抽象；

组合方式更加灵活；

2020-03-04


binarylei


JDK 动态代理采用组合方式（可以通过 ProxyGenerator 获取代理后的对象字节码），而 CGLIB 动态代理是采用继承方式。所以 CGLIB 只能代理非 final 修辞的类。

之前在 Spring 5.1 版本中碰到无法获取代理类上注解的 bug，其原因就是 CGLIB 是继承方式，可以递归获取父类上的注解，而 JDK 动态代理采用组合方式就无法获取代理类的注解。在 Spring 5.2 中通过其它的手段获取 DJK 代理类的注解，已经修复了这个问题。

现在元编程非常流行，如何获取被代理类的元信息，也很重要。

2020-03-02


疯狂咸鱼

老师，java 的反射在 JVM 层面到底是个什么逻辑？为什么只给了的类的全路径，JVM 在运行期间就能得到该类的 class 文件并生成 Class 对象？

我理解是在 JVM 运行期间开了个线程根据解析到的类的全路径名字找到这个文件，通过类加载器加载到内存中。换句话说，走的过程和 new 一个对象一样，只不过 new 是在编译期完成，反射是在 JVM 运行期间根据需要去加载。两者所都还是要经过类加载过程，所消耗的时间 (代价) 是一样？不知道我这样理解对不对？

2020-03-02


每天晒白牙

代理模式有两种实现方式

1. 代理类和原始类实现相同的接口，原始类只负责原始的业务功能，而代理类通过委托的方式调用原始类来执行业务逻辑，然后可以做一些附加功能。这也是一种基于接口而实现编程的设计思想

2. 如果原始类没有定义接口且不是我们开发维护的，这属于对外部类的扩展，可以使用继承的方式，只需要用代理类继承原始类，然后附加一些功能

2020-02-28


传说中的成大大

第一问 基本上没有遇到过代理模式

第二问 我感觉都差不多 前面讲的时候是加了个条件基于接口编程，如果原始类没有实现接口，那么采用继承，但是抛开这个条件来看 其实组合和继承没多大区别 唯一的一点就是继承会破坏封装性而已

比如 代理类实现接口类的 login 而第三方库叫 login_now 我们不能修改第三方库 那么只能在代理类当中使用第三方库的 login_now 其实想想也没多大区别啊 组合和继承 往有大佬能指点一下

2020-02-26


uranusleon


第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。-- 谁可以帮忙解释一下为什么替换成本较大？如果在代理类中调用计数器框架，后面如果更换计数器框架，则代理类中也需要修改，替换成本和不使用代理类也没有看出区别。

2020-02-25


守拙

课堂讨论:

2. 我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。

使用继承方式实现代理模式是一种折衷做法：原则上 proxy 和 client 对象并不是严格的 is-a 关系，业务变动会导致 client 类和 proxy 类必须一起修改，耦合严重.

使用组合的方式实现代理模式才是正派用法. client 和 proxy 职责分离，client 类甚至可以包装多层代理！你细品.

2020-02-24


xinquanv1


组合方式更好。组合更加灵活，特别是需要用到一些其他类提供的额外功能的时候，组合可以更好的实现复用，而继承则做不到，而且 java 只能单继承！

设计原则也有云：多用组合少用继承｡◕‿◕｡

2020-02-24


平风造雨

1. java 和.net 通过反射实现动态代理，其它语言比如 python 可以用自省来实现，本质都是利用类的 metadata 进行编程。

2. 组合的方式创建代理类显得更轻量和灵活，继承的层次多了，有时候会不太理解逻辑，方法不停的给 override。

2020-02-24


李小四

设计模式_48:

我怎么感觉在代理这种用法中，组合的方式完胜呢。

2020-02-23


相逢是缘

打卡

一、使用场景：

1）务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理；

2）在 RPC、缓存等应用场景；

二、实现方式：

1）代理类和原始类实现同样的接口，通过委托的方式调用原始类；

2）通过继承扩展附加功能；

3）动态代理方式，运行的时候动态地创建原始类对应的代理类（相对 1、2 中的静态代理，不需要针对每个类都创建一个代理类）；

2020-02-23


javaadu


最熟悉的还只有 Java，问题 1 看别的同学留言学习了。

问题 2 我的思考如下：

基于组合

1. 优点：扩展性更好，多层增强下来也比较清楚

2. 缺点：对于三方库无法应用

基于继承

1. 优点：应用面更广

2. 缺点：代码多；多层增强的话，继承体系变得越来越复杂

2020-02-23


Frank


代理模式可以实现业务需求与非业务需求之间的解耦。这样一来使得业务列与非业务类职责更加单一，可维护性提高。代理有静态代理与动态代理。

静态代理有两种实现方式：基于接口 + 委派 和 基于类 + 继承覆写目标类方法。静态代理可适用于被代理类不多，不复杂，可控的情况下。其劣势在于：需要为每一个目标类创建代理类，一旦类增多，维护成本增加。一旦要扩展接口中的功能，代理类与被代理类都需要作相应的修改（违反开闭原则）；在做代理之前，被代理类所有的东西都需要已知，人工干预太多；

动态代理能弥补静态代理的问题，在代理之前，所有的东西可以是未知的。不事先为每个被代理类编写代理类，而是在运行时，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。其劣势在于：必须要有接口的支持。如果需要绕开接口这一点，则使用 cglib 动态代理来实现。

回到代理模式的本质是实现业务与非业务之间的解耦。其可以应用在业务系统的非功能性需求开发，如日志，监控，限流，事务等。同时也应用于 RPC, 接口缓存等场景。

2020-02-22


Demon.Lee


如果这篇都看不懂，就真是我们自己的问题了。

2020-02-22


峰

我在想有木有可能需要在方法中间添加相关的逻辑。

2020-02-22


天之炼狱

争哥，数据转换用什么样的设计模式比较好。比如数据库表转换到 XML，或者是 XML 转换到数据库表，但 XML 的结构可能因地区要求还不一样。

2020-02-22


Wh1


终于等到代理模式

2020-02-21


岁月

课堂讨论题

1. 略

2. 组合模式有一个缺点，就是需要对原始类的全部方法都实现一遍。继承则没有这个问题了。不过继承确实无法对一些声明为 final 的方法进行代理了.

对了我有一个疑问，就是代理模式只能代理接口方法吗？像有对象属性这些，貌似只能写一个 getter 方法来代理啊？如果是这样的话，那组合模式遇到那种有属性的类，岂不是要写一大堆 getter 方法了？而且其他设计模式好像都是关注接口里面的方法，并不会关注对象的属。大家能否指点一下，谢谢. (这个问题源于我在写自己的类库的时候，因为对象的类型声明为接口，所以使用对象的时候无法访问它的属性，给编码造成了一些麻烦)

最后顺便提一下，iOS 中的代理模式跟这篇文章讲的思想有很大区别，iOS 的代理类主要是用来做数据源，用户自己实现代理类中规定的接口，然后提供给使用类的对象用来获取数据.

2020-02-21


SXPeople


组合代理比继承代理模式，在纵向横向的扩展都要灵活

继续跟着大牛🐮的脚步向前进

2020-02-21


Vicent🍀


一：Objective-C 中 Delegate 委托我一般叫做代理，oc 中可以声明代理方法和代理对象，如果原有类想要增强，就要声明代理协议和持有代理对象，调用的时候去调用代理对象的代理方法，但我觉的这种编程方式应该不属于动态代理的范畴。因为即使是通过协议约定了方法（类似接口）但实现代码块是维护在一个单独类中，并且需要手动的实例化并传递给实用类。

二：

组合模式：

优点：觉得这种更灵活，可以根据接口定义不同的代理方法进行区分，职责分明，封装性好

缺点：代码量会增加；调用链会稍微增长；

继承模式：

优点是可以增强一些无法侵入修改的代码；

缺点是感觉耦合度会提高，如果要修改代理方法，必须要修改继承类，不如使用接口切换方便。有些类 final 了，神仙难救啊。

2020-02-21


progyoung


以前准备面试的时候，总也搞不懂 aop 背后的原理，今天算是整明白了，谢谢小争哥。

2020-02-21


岁月神偷

看完争哥对代理模式的讲解，不仅明白了其原理和实现，更理解到了它的使用场景。感觉学习模式最精华的部分不在原理和实现，而在使用场景，争哥在这方面的内容做得很好，点赞。

2020-02-21


FIGNT


只会 java。基于接口和继承都是使用了多态的特性，在运行时用代理类替换。没有优劣之分，应用场景不同。就像争哥提到的，有些没有实现任何接口，而且不是我们开发的类。这时候就用基于继承的动态代理。

2020-02-21


