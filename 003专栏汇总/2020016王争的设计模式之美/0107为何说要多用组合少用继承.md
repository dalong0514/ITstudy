# 0107 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

王争 2019-11-25




2.0x





讲述：冯永吉 大小：9.95M 时长：10:51

在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。

话不多说，让我们正式开始今天的学习吧！

为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。

假设我们要设计一个关于鸟的类。我们将「鸟类」这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。

我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly () 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly () 方法的父类，那鸵鸟就具有「飞」这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly () 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：

public class AbstractBird {


//... 省略其他属性和方法...

  public void fly() { //... }


}


public class Ostrich extends AbstractBird { // 鸵鸟

//... 省略其他属性和方法...

  public void fly() {


    throw new UnSupportedMethodException("I can't fly.'");


  }


}


这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly () 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：

从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注「鸟会不会飞」，但如果我们还关注「鸟会不会叫」，那这个时候，我们又该如何设计类之间的继承关系呢？

是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。

如果我们还需要考虑「是否会下蛋」这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…… 一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。

总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。

组合相比继承有哪些优势？

实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。

我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对「会飞」这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：

public interface Flyable {


  void fly();


}


public interface Tweetable {


  void tweet();


}


public interface EggLayable {


  void layEgg();


}


public class Ostrich implements Tweetable, EggLayable {// 鸵鸟

//... 省略其他属性和方法...

  @Override


  public void tweet() { //... }


  @Override


  public void layEgg() { //... }


}


public class Sparrow impelents Flayable, Tweetable, EggLayable {// 麻雀

//... 省略其他属性和方法...

  @Override


  public void fly() { //... }


  @Override


  public void tweet() { //... }


  @Override


  public void layEgg() { //... }


}


不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg () 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？

我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly () 方法的 FlyAbility 类、实现了 tweet () 方法的 TweetAbility 类、实现了 layEgg () 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：

public interface Flyable {


  void fly()；


}


public class FlyAbility implements Flyable {


  @Override


  public void fly() { //... }


}


// 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {// 鸵鸟

private TweetAbility tweetAbility = new TweetAbility (); // 组合

private EggLayAbility eggLayAbility = new EggLayAbility (); // 组合

//... 省略其他属性和方法...

  @Override


  public void tweet() {


tweetAbility.tweet (); // 委托

  }


  @Override


  public void layEgg() {


eggLayAbility.layEgg (); // 委托

  }


}


我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。

如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：

public class Url {


//... 省略属性和方法

}


public class Crawler {


private Url url; // 组合

  public Crawler() {


    this.url = new Url();


  }


  //...


}


public class PageAnalyzer {


private Url url; // 组合

  public PageAnalyzer() {


    this.url = new Url();


  }


  //..


}


还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode () 函数。这个时候，我们只能采用继承来实现了。

public class FeignClient { //feighn client 框架代码

//... 省略其他代码...

  public void encode(String url) { //... }


}


public void demofunction(FeignClient feignClient) {


  //...


  feignClient.encode(url);


  //...


}


public class CustomizedFeignClient extends FeignClient {


  @Override


public void encode (String url) {//... 重写 encode 的实现...}

}


// 调用

FeignClient client = new CustomizedFeignClient();


demofunction(client);


尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以「多用组合少用继承」这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。

重点回顾

到此，今天的内容就讲完了。我们一块儿来回顾一下，你需要重点掌握的知识点。

1. 为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

2. 组合相比继承有哪些优势？

继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

3. 如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

课堂讨论

我们在基于 MVC 架构开发 Web 应用的时候，经常会在数据库层定义 Entity，在 Service 业务层定义 BO（Business Object），在 Controller 接口层定义 VO（View Object）。大部分情况下，Entity、BO、VO 三者之间的代码有很大重复，但又不完全相同。我们该如何处理 Entity、BO、VO 代码重复的问题呢？

欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (164)

Paul Shan


我的观点比较极端，用接口，组合和委托代替继承。原因如下：

1. 人无法预知未来，现在比较稳定的类继承关系将来未必稳定。

2. 两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。

3. 相对于接口 + 组合 + 委托增加的复杂度，代码统一成接口 + 组合 + 委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。

4. 新的编程语言让接口 + 组合 + 委托变得容易，例如 Kotlin 就有专门的语法糖支持，消除了很多模板代码。

5. 接口 + 组合 + 委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。

2019-11-25


探索无止境

我个人感觉 VO 和 BO 都会采用组合 entity 的方式，老师是否可以在下一节课课聊聊上节课留下的思考题，您的处理方式？

作者回复：抽空集中答疑一下吧

2019-11-25


守拙

课堂讨论 answer:

Entity，Bo，Vo 三者之间，显然并不存在 is-a 关系，首先排除使用继承。

其次三者间也并非是严格的 has-a 关系，half measure 之一是考虑使用组合（composition） + 委托（delegation）的方式解决代码重复的问题，但并不是我心中的最佳答案.

我的答案是不解决三者间的代码重复问题。Value Class 就只是 Value Class, 代码重复并不是业务上的代码重复，那就让它重复吧.

2019-11-25


花儿少年

VO,BO,DO 表示什么前面都说过了，我觉得得换一个思路去看待这种模型转换的问题。

这里我们将 BO 看做 ddd 里面的核心域中的实体。那么这个对象的变化应该对 VO 或者 DO 隐藏起来，VO 是对外的模型，为什么需要感知到内部业务的变化，DO 是具体的存储方式，这是由实现决定的，在业务逻辑中也不应该关心。重要的是隔离，让这三者独立变化。

所以我的结论是，既不应该用继承，也不应该使用组合，使用防腐层，模型转换层隔离这种变化才是最好的。

但是实际上在很多业务中 BO 和 DO 是差不多的，于是就混用了，在业务不复杂的时候，也没太大关系。业务运行的很好，也不难理解。

追求完美，却不可能处处完美。

2019-11-26


兔 2🐰🍃

看下来对组合跟委托两个概念表示不太明白，看了代码后才，以及网上查阅后才明白。

继承 (Inheritance)：利用 extends 来扩展一个基类。is-a 的关系。

组合 (composition)：一个类的定义中使用其他对象。has-a 的关系。

委托 (delegation)：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。有 uses-a, owns-a, has-a 三种关系。

2019-11-25


Shanks - 王冲

希望，评论区能增加一个 <b> 可选开关 </b>，「只看作者回复」的评论「(*/ω＼*)」

2019-11-25


Geek


打卡✔

看完之后有种感觉，我们平常写的 spring 的依赖注入这种形式，是不是就是跟组合，委托这种模式啊

2019-11-25


sabo


GO 完全摒弃了继承，在语法上只有组合，接口之间也可以组合 (这也是官方鼓励的做法)。

2019-11-25


cc


希望作者能在课程末尾梳理下上一节课程的课后习题，或者集中点评下大家的留言。感谢

作者回复：可以的...

2019-11-25


kk


希望老师，在每一节课能回答一下上一节课的问答

2019-12-04


tt


谈谈对下面一段话的理解：

「我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。」

理解或总结如下：

1、「比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代」，我的理解为：is-a 意味着 has-muilti-a's 或者 has-all-needed-a's。故而需要实现多个接口，而接口抽象的是操作或者方法而非数据（数据和方法的抽象由抽象类来完成），所以具体的操作要由被组合进来的类对象来完成，站在类间关系的角度来看，外部类和被组合类之间的关系被称为「委托」。

2、这里面，被组合类的代码被抽象到了接口中，或者反过来说接口的具体操作下沉到了被组合类中，这就是「代码复用我们可以通过组合和委托来实现」的含义，代码被不同的被组合类「分门（类）别类」的复用了。

3、「多态特性我们可以利用接口来实现」，因为接口代表了某种契约，而多态就是用子类代替父类。只要实现了某种接口，按照契约，自然就可以在某些方面或某种程度上代替父类。所以我觉得接口是「更细粒度更多控制的更有节制的继承」。

回到本课的问题。

之前的课说到 VO，BO，Entity 是典型的面向过程的编码，里面基本都是数据，没有方法。那么自然不可以用接口来减少代码的重复，只能用继承了。

但是 MVC 的结构，我理解它是一种分层客户端服务器架构，Layered Client-Server，每一层为其之上的层服务，并使用其之下的层所提供的服务。为了减少层之间的耦合，必要的重复是可以的。

2019-11-25


James


我的个人感觉，等待高手更好的回答 //

Entity 在 VO,BO 中基本上都是一模一样的，使用组合把 Entity 引用进来，然后在 BO,VO 中创建各自独特的属性 /

2019-11-25


Jxin


1.bo vo 和 entity 三个命名在现在面向服务而非页面的后端编程，并不合适。

2. 这里最好用组合。entity 是最小的实体单元，bo 可能面对多个 entity 聚合，vo 可能面对多个 bo 聚合，这种场景下，显然组合更适合。虽然也存在 entity 和 bo 一对一的场景，或者 bo 中只有一个主 entity 的场景，这种场景用继承倒也不为过。但是，为了套路单一，减少阅读思考，统一组合便是，没必要再引入继承。

3. 老项目里面，代码已经高度耦合，而且不是面相接口写的代码，那么整体改动成本会很大。这种情况下用继承实现多态我觉得挺合适。

4.java1.8 提供接口的方法默认实现后，我觉得继承的处境真的挺尴尬，新项目反正能用继承实现的用组合也可以。所以除非父子关系特别明显（继承不深其实比组合直观），不然没什么必要用继承了。

2019-11-25


辣么大

很多同学提出复用 Entity（DO），我有不同意见：若修改 DO，可能会影响到 BO 和 VO。

我们都知道 DO 对应数据表，如 PersonDO 类有 id，age，name。

若现在需求改变，age 要从政府系统获取，原有的 Person 表要删除 age 字段，相应的 DO 类就要修改，UI 仍然显示 person.age。BO、VO 有如果使用了 DO 就会受到影响。

为了降低影响，BO,VO 考虑使用 PersonDTO。

上面的例子中 DTO 中保留 Person.age 属性，在 Service 层中将 DO 转换为 DTO，转换时 PersonDTO.age 从其他系统获取。

这样虽然增加了代码量，对 DAO 层的修改影响降到最低。

2019-11-25


李湘河

现代军事武器中的开发都在追求模块化开发，这样装备之间通用性更强，战损时随时可以替换掉损坏的模块，这样又可以重新作战，当要增强坦克某一部分的性能时，仅改进对应的模块就行，感觉很像组合的思想。就像文中说的，对于结构稳定，层次浅的地方完全可以用继承，或者说可以局部用继承，比如 VO 层，对于用户检验，分页等都可以抽象出来

2019-11-25


辣么大

Entity，也称为 DO （Data Object），与数据库表结构一一对应，到过 DAO 层向上传输对象，应独立为一个类。

BO，VO 可以采用继承或者组合的方式，复用 DO 的代码。

谨慎使用继承方式来进行扩展，不得已使用的话，必须符合里氏替换原则，父类能够出现的地方子类一定能够出现。

2019-11-25


黄林晴

打卡✔

老师好，今天刚用继承优化了代码臃肿的问题，但是感觉好奇怪，请老师指导:

所有的消息都会先到一个 A 类中，在 A 类中，根据消息类型，比如类型 1 2 3 4 去处理不同的业务，每一类的业务都需要处理对应数据，原本随着消息类型的增加不断往这个 A 类中扩展代码，导致不好维护，所以我对每个业务模型建对应的类继承这个 A 类，在 A 类中将消息转给对应类去处理，其实 new 一个类 将所有参数传过去也可以，但是因为参数太多太多不美观，所以使用了继承，但回过头来想，我的继承只是被动使用的，好像和继承的原理相违背

2019-11-25


Brian


目前一项目中使用 SpringBoot 开发，其中对象定义为入参为 DTO，数据库实现为 Entity，业务返回结果为 VO，三者对象完全独立，其中大部分属性相同，在 DTO 对象 添加 convertToEntity 方法，Entity 添加 convertToVO 方法，实现对象属性拷贝。同时在 DTO 和 VO 中使用组合方式，有很少数的继承。

2019-11-28


沧月丶下

public class FeignClient { //feighn client 框架代码

feighn -> feign 勘误～

作者回复：嗯嗯多谢指出

2019-11-25


M


万人血书，请老师讲解最优的方案，顶起来！！

2020-01-21


双儿么么哒

很想知道老师对思考题的答案，困扰我很久了

2019-11-26


Jackey


VO 就是用来指定对外暴露的字段，跟 DO 不算是 is-a 关系，稳定性也不高，所以个人认为不需要处理和 DO 的重复代码

2019-11-26


ANYI


这个课堂讨论，争哥啥时候可以给大家讲解下，这个貌似都是大家比较关注的点，😄

作者回复：恩恩，好的，抽空答疑一下

2019-11-26


默

这次的思考题正好也是困惑我很久的问题，看看大家有什么好的方式。

之前我的做法是用组合 + 委托的方式，但发现这种方式其实还是无法实现分层，即间接的将两个硬关联起来，增减属性的时候需要同时修改两个对象的代码；

如果是继承关系，那么相当于多出一个类，让三个对象同时继承该类，但这个新衍生出的对象又怎么理解它呢？它与其他三个对象是否有 is-a 的关系？不能单纯的为了复用而继承。

最后我极端的做法是将三者合为一体，抽象理解成「数据承载对象」… 哈哈，但是这个对于 VO 对象，通常需要根据接口要求返回特定格式的数据，所以变成不伦不类的对象了。

😭


2019-11-25


不记年

vo，entity，bo 只承载数据，不承载业务。虽然具有重复的代码，但却服务于不同的业务，采用任何一种方式都会耦合，不如就让代码重复着

2020-01-30


DFighting


可以使用组合 + 继承来解决代码重复的问题，但实际项目中我更倾向于不同层次之间的冗余 (前提是 MVC 框架)，因为我理解的优秀的代码是服务于优秀的设计架构的，也就是说不通层次之间的代码中肯定会有冗余，因为数据是在不同层次中流转的。不过在同一个层次中的代码冗余就有优化的必要了

2019-11-27


Miaozhe


老师，针对你举鸟的例子：使用组合＋接口＋委托 代替继承的例子。如果在 Spring 中，怎么通过接口（自动注入）调用 Ostrich 鸵鸟的实现方法（下蛋和叫）？Tweetable 和 EggLayable 接口各定义一个接口变量由鸵鸟初始化？这样感觉雍余了。

请解答一下？

作者回复：你的意思是通过接口调用两个方法对吧，如果实在有这个需求，可以重新定义一个接口，extends 另外两个接口。不过，你说的 spring 注入的情况，完全可以不依赖接口呀，直接依赖实现类也可以的。

2019-11-27


小先生

请问老师，好多类想要拥有相同的一个属性，考虑到代码复用性，是否只能继承啦

作者回复：也可以用组合的，组合也能解决复用的问题

2019-11-25


xk_


entity 就不用动了，VO 和 BO 都可以使用组合 entity。我自己曾经抽取过 VO 和 BO 的共同属性，这个方法特别不好，只要父类要修改，子类也要跟着修改，子类调用的方法也要修改。

如果用组合的方式，那改动就会相对少很多。代码也会清晰很多。

要是很多 entity 有共同的属性，倒是可以抽出来作一个抽象类。

2019-11-25


傲慢与偏执，

我只有在该类需要更细化详情信息的时候会组合详情类的 list 看了这节课后 受益匪浅

2019-11-25


欠债太多

我们现在采用 entity 实现，VO 和 BO 都去继承它，减少代码重复。看了专栏后，我认为可以通过讲 VO 和 BO 组合成 Entity 实现，不知道这样做，是不是合适

作者回复：好像不合适，怎么通过 vo 和 bo 组合成 entity 呢？

2019-11-25


秋风画扇

个人观点：我们变成是围绕着数据打桩的，BO、VO、Entity，核心是需要持久化的 Entity，BO 为了更好的进行业务处理在 VO 上进行扩展，VO 则是为了展示在 Entity 上的扩展。当然 VO、BO 各自也有属于自己层面的属性，需要做到暴露「共有」属性，隐藏「特有」属性。BO、VO 可以扩展 (继承) Entity，又各自「特有」属性。可以借鉴组合的思路，BO、VO 各自一些属于自己逻辑层的特有属性

2020-03-21


唐龙

C++ 有多继承，也可以使用虚继承来避免菱形继承存在的问题，这样是否也可以解决文章中提到的各种鸟的问题啊。

2020-02-03


迷羊

一、为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

二、组合相比继承有哪些优势？

继承主要有三个作用：表示 is-a 关系，支持多态，代码复用。这三个作用可以使用其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。

三、如何判断该用组合还是继承？

1. 继承改写成组合要做更细粒度的拆分，定义更多的类和接口，或多或少会增加代码的复杂程度和维护成本，实际的项目开发中，要根据具体的情况，来选择该用继承还是组合。

2. 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。

3. 一些设计模式也会固定使用继承或组合。比如装饰者模式、策略模式、组合模式等使用了组合关系，模板模式使用了继承关系。

四、具体案例

1. 如果 A 类和 B 类都用到了某个功能，但是用业务上来讲它们既不是父子关系，也不是兄弟关系。这时候为了代码复用，就不应该生硬的抽象出一个父类出来，会影响到代码的可读性，这时候使用组合更加合理。

2. 如果不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。

2019-12-27


饭粒

Entity、BO、VO 这个重复代码问题也纠结过，BO，VO 不需要 Entity 的所有属性，所以继承不大合适。用组合的话要套个其他实例单独写方法，麻烦。现在都是直接单独写，重复就重复了，而且一般也不会有复杂的逻辑，就重复属性和 getter/setter。

特别想知道这个问题合适的做法。希望老师能在下节讲下上一节的问题，再布置下下节的问题，个人感觉这种方式比放到统一答疑章节要好很多。

2019-11-26


强哥

结合 DDD 领域驱动设计，不是应该每层都做转换吗？例如 dto，bo，po 等。

2019-11-26


Monday


1、我们现在的项目只有 Entity 与 VO，而且两者之间互不相关，确实有太多的属性和方法重复了。

2、思考题：学习了今天内容，个人觉得可以使用委托和组合的方法，将 Entity 与 VO 共有属性抽象出来一个类，然后 Entity 与 VO 来组合此类。

2019-11-25


小白

go 语言对组合的支持更加纯粹，比 java 优雅。

package main


import (


"fmt"


)


type Flyable interface {


fly() error


}


type FlyAbility struct {


}


func (b *FlyAbility) fly() error {


fmt.Println("I can fly.")


return nil


}


// 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility

type Ostrich struct {


FlyAbility


// TweetAbility


// EggLayAbility


}


func main() {


var flyable Flyable = &Ostrich{}


flyable.fly()


}


2019-11-25


啦啦啦

<?php


// 叫

interface jiaoable


{


    public function jiao();


}


// 飞

interface flyable


{


    public function fly();


}


// 下单

interface eggable


{


    public function egg();


}


// 叫的实现类

class jiaoablity implements jiaoable


{


    public function jiao()


    {


        echo 'jiao';


    }


}


// 鸵鸟类

class tuoniao implements jiaoable,eggable


{


    private $jiaoobj;


    public function __construct()


    {


        $this->jiaoobj = new jiaoablity();


    }


    public function jiao()


    {


        $this->jiaoobj->jiao();


    }


    public function egg()


    {


echo ' 我是鸵鸟我会下单 ';

    }


}


// 麻雀类

class maque implements jiaoable, flyable


{


    private $jiaoobj;


    public function __construct()


    {


        $this->jiaoobj = new jiaoablity();


    }


    public function jiao()


    {


        $this->jiaoobj->jiao();


    }


    public function fly()


    {


echo ' 我是麻雀我会飞 ';

    }


}


2019-11-25


小晏子

因为 Entity，BO，VO 都是描述对象的，只不过是用于不同目的的对象，这些对象之间会有很多重复的元素定义，针对这样的重复定义，我倒是感觉可以使用继承，将重复的那些元素都提取出来作为父类，然后 entity，VO，BO 去继承这个父类，在实现自己独有的元素。而接口主要是针对不同能能的复用，用在 E，B，V 身上并不合适。

2019-11-25


Cy23


打卡✔

继承的层次过深带来的缺点看明白了，组合和委托不太理解，回头又好好看了看代码，视乎理解了，希望不要忘记了。也不知道是否理解对了？

记下自己的体会：

组合 —— 类中包含其他实现类，感觉就是把大的功能分成多个类来实现，然后再根据需要组合进来使用。

委托 —— 类中实现接口方法的时，把具体的实现方法调用其他类中的方法处理，也就是委托给别人（被委托者）帮他写好具体的实现。

作者回复：理解的没问题！

2019-11-25


编程界的小学生

这种的我认为继承会好一点，将公用属性抽离到父类中，因为他的层次最多两层，而且用组合的话可能会带来某些不便，比如 vo 里面放个其他类，返回给客户端的时候属性分为两层，共有属性是在子 json 对象里的，感觉不妥。

2019-11-25


程晓擘

这篇文章，受益匪浅，激动的睡不着觉了。

2019-11-25


西电

请教一下，如果是按照功能分成多个基类，然后再按需继承。

比如将大的基类分成，Fly 类，Tweet 类，Egg 类三个类。

鸵鸟就只继承 Tweet 类，Egg 类

这样也可以实现接口，组合，委托的效果啊，请问一下这样有什么坏处呢？

作者回复：有些语言不支持多重继承，而且从语义上也不对，什么是 Fly 类啊，飞是行为，更适合用接口来表达，不适合作为类吧

2020-07-15


ujshenry


讲解跟贴近实际，vo bo entity 实际中也用到 基本就定义一个大而全的 bean

2020-06-25


注定非凡

多用组合可以让我们，把精力和注意力集中在我们需要钱实现的对象身上，继承则需要我们在关注当前对象的同时，还有关注其继承的父类特性

2020-06-19


郭强

接口中的方法不是可以写默认方法吗，就不需要再额外写委托类了，方便很多。

2020-06-05


小强哥

理解组合和委托的区别，组合是把一个类对象当做另一个类的成员变量；委托是使用组合的对象执行某个方法或者行为

2020-05-31


hiqian


把实体之间相同的部分抽出来作为父类

2020-05-26


Zeng Shine


组合是拼接共性，继承是包含共性。包含关系的耦合度更高。

2020-05-23


刘同青

// 翱翔

class Soar implements FlyAble {


  @Override


  public void fly() {


// 自由翱翔...

  }


}


// 狗刨

class DoggyPaddle implements SwimAble {


  @Override


  public void swim() {


// 狗刨...

  }


}


// 天鹅

class Swan implements FlyAble, SwimAble {


Soar soar = new Soar (); // 组合

DoggyPaddle doggyPaddle = new DoggyPaddle ();// 组合

  @Override


  public void fly() {


soar.fly ();// 委托

  }


  @Override


  public void swim() {


doggyPaddle.swim ();// 委托

  }


}


// 老鹰

class Hawk implements FlyAble {


Soar soar = new Soar (); // 组合

  @Override


  public void fly() {


soar.fly ();// 委托

  }


}


// 企鹅

class Penguin implements SwimAble {


DoggyPaddle doggyPaddle = new DoggyPaddle ();// 组合

  @Override


  public void swim() {


doggyPaddle.swim ();// 委托

  }


}


2020-05-13


师哥

Entity、BO、VO 之间是通过继承来解决代码复用的，因为这种场景类稳定，继承层次浅。这是最初的想法不知道，看看以后有什么好的处理方式

2020-05-13


「@」


VO 大部分都是需要暴露给外部的，不能用来继承，我觉得 BO 继承 entity，然后 VO 组合 BO 的方式比较稳妥

2020-04-28


gtp


终于明白为啥少多用组合少用继承了！！！

2020-04-12


KK


组合 + 委托的方式会不会增加代码之间的耦合度，从而降低代码的可维护性？

2020-04-04


70


对于组合，php 新增了关键字 trait 来处理，使用起来很方便。

2020-03-30


鸳鸯戏水蝶

继承好像用的最多的也是 entity/BO 之间的实体类继承。

2020-03-28


墨鱼

继承可以解决代码复用的问题，但是不推荐，主要原因是多度继承会导致代码难以维护。通过组合也可以实现继承的特性。

具体情况具体分析，如果非常确定继承的层次不多，可以使用继承。如果继承层次过多，还是使用组合为好。

2020-03-25


忆水寒

MVC 其实已经在层与层之间很清晰了，只要在每一层的接口设计好就可以了。尽量减少重复代码

2020-03-24


然

针对老师留下的题目，我认为可以使用继承，把共有部分抽取出来

2020-03-24


Initiative Thinker


可以用抽象类代替接口吗

2020-03-21


索旭东

代码里的委托好像不是委托，只是个函数调用吧

2020-03-19


治慧

课后习题:entry bo vo 本质上没有任何继承关系可说的；从业务角度上虽然存在重复的字段，但是是不同的业务 也不适合 组合 + 委托的方式

2020-03-18


🌀Pick Monster 🌀


继承的优点是可以提高代码的复用，但过渡复杂的继承会影响代码可读性和维护性。

组合的优点是提高代码的复用，降低业务结构的复杂度，但会增加分支结构导致需要更细粒度的设计。

继承类似于多线程的 synchronized 关键字，不能细粒度控制可能导致性能问题。组合类似于 Lock 锁，可以进行更细粒度的控制，但使用复杂度可能会提高。

所以我们应该根据具体的业务选择合适的方案。

2020-03-17


ladili


如果层级不多，有时候继承在语义上比较好吧。

组合和委托确实灵活很多。多个重复的逻辑，委托到另外一个独立的功能类里面去，然后在组合回来，很灵活。

2020-03-12


88591


继承的一个误区，为了代码复用，故意抽象公共一个父类出来。虽然解决了代码复用问题，但是影响了代码的可读性，可维护性。这样是得不偿失。应该用其他手段来实现代码复用

2020-03-12


赵云

想问下老师有什么比较好的建议去实现这些重复的问题

2020-03-11


壹

看到鸟的这个例子我就想到 swift 的协议，解决这个问题比 Java 优雅太多了

2020-03-04


未来小娃

今天主要讲组合和继承的使用，总结一下就是结构稳定继承层次浅（不超过两层）可以使用继承，否则使用组合 + 接口 + 委托单位方式。我的倾向是有共同结构或者业务上是同一类的优先使用继承，否则使用组合的方式。仍然回归定义，接口是行为的抽象，与行为相关的代码逻辑优先使用组合，在定义接口的时候要考虑得行为的通用性，也就是符合单一职责。下面说下思考题，entity、vo、bo 本身就是不同层面的业务对象，entity 是数据层对象，vo 是展示层对象，bo 是业务层对象，如果三者之间有通用的属性就各自定义好了，如果多种业务都有一些公共的属性则可以单独定义这么个 bo、vo，然后使用组合的方式拿过来就好了。而且从业务看这不是重复代码，感觉问题可以更具体点

2020-02-23


色即是空

还是不忘评价代码好坏的几条标准，可用，可维护，可扩展。。。。我们的目标是高质量的代码

2020-02-22


Ant


回顾了一下很受益，谢谢老师

2020-02-21


Heaven


对于这个问题，在实际开发中，我们经常使用 Beans 这个工具类其中的 copproperties () 方法去解决代码重复赋值问题，但是经过了这几天的学习，发现经常使用的 mvc 是一个面向过程的贫血模型，所以我给出的解决答案是使用接口 组合以及委托这种方式去替换它，这是我学完这节课的一个设想，但这三者之间并没有什么直接的关系，我认为这三者没必要去解决他们的代码重复问题，他们三个本身来说就应该是相对独立的，不然有这么多代码重复，我们为什么不将其放到一个对象里面了？在整个 MVC 三层之间都共用一个对象.

2020-02-19


wysobj


老师，我理解继承的核心目标是提供一种更符合人类思维模式的代码组织手段，除了代码复用也可以提高代码的可读性。只不过这个技术很难运用得恰当，容易造成过度设计或者结构腐化，所以需要慎重使用。您举的鸟的例子就能体现，其实鸟类概念的定义本身就没有飞翔的属性，所以不能提供 fly 方法。这种场景就像在代码开发中很多人最开始对一个类的边界理解有些许偏差导致设计问题，后续调整继承关系的成本很高。所以说与其说继承一无是处，不如说使用继承特性十分危险。

2020-02-14


Geek_7ead05


优先考虑用组合，接口和委托实现继承的功能。

2020-02-01


Citizen Z


个人认为，那些 xO 还是各自独立的好，因为属于不同层面的对象，从建模角度讲，他们之间不是相同领域的对象，只是恰好大部分字段相同，如果数据转换时有太多 target.setXxx (source.getXxx ())，仅仅为了方便和减少代码量，可以考虑采用小工具的方式，如 copyProperties、字段 mapping 等手段来实现

2020-01-12


老纳法号叫乱来

关于思考的问题，DO，VO，BO，DTO 等，属于不同领域，各自的职责不一样，所以无所谓相同的属性。比如 DTO 做为参数的入参对象，会在属性上加一些校验注解或者在加一些 swagger API 接扣文档注解，而其他的 O 并不需要，尊从单一职责原则

2020-01-09


天空只能仰望？

继承便于代码复用，层次过深增加代码复杂程度和可读性，组合使用灵活便利，会增加类的复杂程度同时会增加部分代码冗余，屏蔽特性弊端正确使用才是王道！

2020-01-06


厉害了我的国

确实是这样，每个层都定义了相似的对象，很丑陋！

2020-01-05


海绵薇薇

接上一条，我的问题：

老师好，我是一名前端，就用 React 代码来阐述我的理解。

我理解的组合可能比较狭隘，具体如下：

页面上有元素 ABC 和 D

status = 1 的时候展示 A B C

funciton Container1() {


  return <>


    <A />


    <B />


    <C />


  </>


}


status = 2 的时候展示 A B D

funciton Container2() {


  return <>


    <A />


    <B />


    <D />


  </>


}


status = 3 的时候展示 A B C D

funciton Container3() {


  return <>


    <A />


    <B />


    <C />


    <D />


  </>


}


function Home(status) {


  switch(status) {


    case 1:


      return <Container1 />


    case 2:


      return <Container2 />


    case 3:


      return <Container3 />


  }


  return <Container1 />


}


这里可以理解为 ABCD 的组合形成了 Container，但是在不同 status 状态之间 <A /><B /> 被重复了多次。

如果单独将 AB 这种组合抽取出来总觉得不对，因为抽取的理由仅仅是这几个状态的时候，他们是一起出现的。

我想如果使用模板方法，不同状态，重写基类的方法可能会减少这种重复，例如：

class Container {


  A() {


    return <A />


  }


  B() {


    return <B />


  }


  C() {


    return <C />


  }


  D() {


    return <D />


  }


  render() {


    return <>


      <this.A />


      <this.B />


      <this.C />


      <this.D />


    </>


  }


}


class Container1 extends Container {


  D() {


    return null


  }


}


class Container2 extends Container {


  C() {


    return null


  }


}


class Container3 extends Container {


}


以上。

开发中用的是组合的方式，发现有重复，所以才有此问。

作者回复：哪种更方便用那哪种 并不是说绝对杜绝继承。继承层次不深 结构不复杂的话 用继承没问题的

2019-12-29


fly


1、继承是面向对象的四大特性之一。继承主要解决代码的复用问题。

2、继承层级太深，继承关系复杂，会影响代码的可维护性。这时候用组合、接口、委托的方式，替代继承的 is-a、多态、复用。

3、继承并非一无是处，组合也不完美。如果继承关系稳定，层级浅选用继承关系；如果继承关系不稳定，关系复杂，用组合来替代。

4、继承相关设计模式：模板模式；组合相关设计模式：策略模式、组合模式、装饰者模式

2019-12-29


Jessica


老师能不能加餐集中解答一周的问题，有些老师提问的刚好我们在项目中也思考过，就是没找到很好的解决方案

作者回复：可以的 等后面有时间了吧 年底比较忙

2019-12-29


ちよくん

针对下蛋会飞，完全相同的处理方式才可以用委托的方案解决，如果不同，还是需要每个不同种类自己去实现自己的处理方式，例如：麻雀下小蛋，鸵鸟下大蛋

2019-12-29


fomy


按属性多少排序：bo>entity>vo，bo 继承 entity 可以实现代码的复用。vo 的属性较少，所以单独写属性会合理一些。

2019-12-27


Tracyliu


委托不就是代理模式么？

2019-12-25


OperaX


看完七个理论 感觉自己平时完完全全是在面向过程编程。

2019-12-23


东流

1. 使用工具类解决重复性代码

2. 抽象出一个接口和接口实现类，通过组合和代理方式优化

2019-12-22


峰回路转

飞的时候如果需要飞的方法内部的处理改变自己的多个属性值，怎么使用委托呐？

2019-12-22


tong467


课堂讨论：

Entity、BO、VO 没有关系，都是独立存在的，但是一般在会进行转换封装。在 Service 层做。VO<->BO 和 Entity<->BO 的封装。我一般会用 BeanUtils.copyProperties 来处理。

2019-12-20


每天晒白牙

打卡《设计模式之美》之第 10 讲 《为何要多用组合少用继承？如何决定使用组合还是继承？》

设计原则：组合优于继承，多用组合少用继承

继承的优点：表示 is-a 关系，支持多态特性，代码复用

继承的不足：：继承层次过深、继承关系过于复杂会影响代码的可读性和可维护性

接口表示具有某种行为特性，但接口只能声明方法，不定义实现，所以会导致具有该功能（实现该接口）的类都要实现方法，导致代码重复。针对这种情况可以对接口再定义实现类，然后通过组合和委托技术来消除重复的代码。

继承的优点可以通过组合、接口、委托三个技术实现，并且还能解决继承的层次过深、过复杂的继承关系影响代码的可维护性的问题

即使鼓励使用组合，但并不是就拒绝使用继承，需要具体情况具体分析。如果类之间继承结构稳定，层次比较浅，关系不复杂，就可以使用继承。反之，就要尽量使用组合来替代继承

2019-12-19


charles


继承的 is a 关系可以用组合和接口的 has a 关系来替代，这个不是很明白。

2019-12-18


小飞

这个问题希望老师能够给出一个指导，开发过程中确实发生了对这个问题的争执。但是我还没有找到一个比较好的能够说服大家的办法。

2019-12-15


冬渐暖

组合就是把属性一个一个的明显的写出来，就像 DTO！=VO !=entity

少用继承多用组合的原因：

1. 继承会让程序变得更复杂。根据之前说的最小设计原则，不要在一个父类类定义子类不是通用的东西，这样如果类多的话会变得很多 (当然如果只有一两层就没事了)。比如用户分为卖家和买家，买卖家又有绑卡和没绑卡的，这样就要设计四个父类（绑卡买 / 卖家、没绑卡买卖家），这样下去会越来越多，定义的类也就越来越多。

2. 明明可以直接看父类有什么东西的，但是如果有了继承簇，还要去看父类有什么，祖宗类有什么，你的猪队友骂不死你

3. 对于方法，牵一发而动全身。父类变了，下面的都要变 (因为用的基本都是 super () 指定用父类的)

用继承和组合的场景

类结构稳定，层次清晰，关系不复杂就用继承

否则就用组合

2019-12-14


iLeGeND


很想知道老师对思考题的答案，困扰我很久了

2019-12-08


海绵薇薇

我觉得，相比较于继承，组合行为本身也是一种重复，咋解决呢？

作者回复：为啥是重复呢？能解释一下吗

2019-12-08


helloworld


适度就可以了…… 适当的代码重复可以忍受，业务的灵活性也得考虑进去

2019-12-05


1620


VO BO Entity 我最近在重写一个 mvc web 项目，（原有项目结构是 Bo extends Entity 在后台数据层 mybatis 和 controller 共用了 Bo） 我改的策略是废弃了 bo extends Bo 增加了 Vo 以及复杂查询的 Query ，query 与 Vo 不关心后续结构只关心定制化内容，前端小伙伴完全对照参数录入。Bo 层可能有一些特殊处理与定制。我没有完全去想集成或者组合，我的目标只是想把他们职责更清晰一点，干净一点。改完之后就是感觉许多出要 transform 比较多但可以借助一些 copy 技术的机制。我也不知道有没有更好的办法来处理这些，设计模式没怎么学过，DDD 只听说过...

2019-12-05


vince


讨论题：entity 对应数据库层，不应该改动，而 bo 和 vo 可用组合的方式解决，具体落地可参考 spring 的 group 注解实现

2019-12-05


东东科

大部分情况下 Bo 是 Po（entity）的扩展，所以一般可以 Bo 继承 Po 或者是 Bo 组合 Po。而现在的 web 开发很多是前后端分离，Vo 需要携带状态和提示信息，所以一般用 Vo 组合 Bo 和 Po

2019-12-02


靠人品去赢

这个关于 Entity，BO 和 VO，我是这么做的就是通常 BO，VO 要比 entity 多，所以干脆直接继承 Entity 就完了。当然涉及到一些敏感字段不想暴露出来，就有点麻烦了，可能要自己去除相关字段，或者只能弄一个一个大家通用的，上面都继承这个基础的。

2019-12-02


西兹兹

三个，都有用，不需要组合，也不需要继承。如果组合用得上就用，不必强求

2019-11-30


岁月如歌

业务开发常见问题，解决办法看具体场景而定。主要方式:

1 继承，适用在 VO ，BO 与 ENTITY 很接近，基本对应数据库字段，直接继承可以复用代码。但是需要能够容忍某些冗余的字段出现。

2 组合，使用 ENTITY 组合作为 VO BO 的成员属性，需要能容忍冗余字段

3 继承 + 组合，将 VO 和 BO 公共部分提取成为单独的类，再通过继承或组合完成复用。定义最为准确，业务和 ENTITY 分离，个人最推荐方式。

2019-11-29


刘岳

里氏替换明确了继承的原则

2019-11-28


