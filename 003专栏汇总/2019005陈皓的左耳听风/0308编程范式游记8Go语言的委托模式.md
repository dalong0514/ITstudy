# 0308 ç¼–ç¨‹èŒƒå¼æ¸¸è®° 8ï¼šGo è¯­è¨€çš„å§”æ‰˜æ¨¡å¼

é™ˆçš“ 2018-02-06

æˆ‘ä»¬å†æ¥çœ‹ Go è¯­è¨€è¿™ä¸ªæ¨¡å¼ï¼ŒGo è¯­è¨€çš„è¿™ä¸ªæ¨¡å¼æŒºå¥½ç©å„¿çš„ã€‚å£°æ˜ä¸€ä¸ª structï¼Œè·Ÿ C å¾ˆä¸€æ ·ï¼Œç„¶åç›´æ¥æŠŠè¿™ä¸ª struct ç±»å‹æ”¾åˆ°å¦ä¸€ä¸ª struct é‡Œã€‚

å§”æ‰˜çš„ç®€å•ç¤ºä¾‹

æˆ‘ä»¬æ¥çœ‹å‡ ä¸ªç¤ºä¾‹ï¼š

type Widget struct {

    X, Y int

}

type Label struct {

    Widget        // Embedding (delegation)

    Text   string // Aggregation

    X int         // Override 

}

func (label Label) Paint() {

  // [0xc4200141e0] - Label.Paint("State")

    fmt.Printf("[%p] - Label.Paint(%q)\n", 

      &label, label.Text)

}

ç”±ä¸Šé¢å¯çŸ¥ï¼š

æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ª Widgetï¼Œå…¶æœ‰ X å’Œ Yï¼›

ç„¶åç”¨å®ƒæ¥å£°æ˜ä¸€ä¸ª Labelï¼Œç›´æ¥æŠŠ Widget å§”æ‰˜è¿›å»ï¼›

ç„¶åå†ç»™ Label å£°æ˜å¹¶å®ç°äº†ä¸€ä¸ª Paint () æ–¹æ³•ã€‚

äºæ˜¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿™æ ·ç¼–ç¨‹äº†ï¼š

label := Label{Widget{10, 10}, "State", 100}

// X=100, Y=10, Text=State, Widget.X=10

fmt.Printf("X=%d, Y=%d, Text=%s Widget.X=%d\n", 

  label.X, label.Y, label.Text, 

  label.Widget.X)

fmt.Println()

// {Widget:{X:10 Y:10} Text:State X:100} 

// {{10 10} State 100}

fmt.Printf("%+v\n%v\n", label, label)

label.Paint()

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæœ‰æˆå‘˜å˜é‡é‡åï¼Œåˆ™éœ€è¦æ‰‹åŠ¨åœ°è§£å†³å†²çªã€‚

æˆ‘ä»¬ç»§ç»­æ‰©å±•ä»£ç ã€‚

å…ˆæ¥ä¸€ä¸ª Buttonï¼š

type Button struct {

    Label // Embedding (delegation)

}

 

func NewButton(x, y int, text string) Button {

    return Button{Label{Widget{x, y}, text, x}}

}

func (button Button) Paint() { // Override

    fmt.Printf("[%p] - Button.Paint(%q)\n", 

      &button, button.Text)

}

func (button Button) Click() {

    fmt.Printf("[%p] - Button.Click()\n", &button)

}

å†æ¥ä¸€ä¸ª ListBoxï¼š

type ListBox struct {

    Widget          // Embedding (delegation)

    Texts  []string // Aggregation

    Index  int      // Aggregation

}

func (listBox ListBox) Paint() {

    fmt.Printf("[%p] - ListBox.Paint(%q)\n", 

      &listBox, listBox.Texts)

}

func (listBox ListBox) Click() {

    fmt.Printf("[%p] - ListBox.Click()\n", &listBox)

}

ç„¶åï¼Œå£°æ˜ä¸¤ä¸ªæ¥å£ç”¨äºå¤šæ€ï¼š

type Painter interface {

    Paint()

}

type Clicker interface {

    Click()

}

äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥è¿™æ ·æ³›å‹åœ°ä½¿ç”¨ï¼ˆæ³¨æ„å…¶ä¸­çš„ä¸¤ä¸ª for å¾ªç¯ï¼‰ï¼š

button1 := Button{Label{Widget{10, 70}, "OK", 10}}

button2 := NewButton(50, 70, "Cancel")

listBox := ListBox{Widget{10, 40}, 

    []string{"AL", "AK", "AZ", "AR"}, 0}

fmt.Println()

//[0xc4200142d0] - Label.Paint("State")

//[0xc420014300] - ListBox.Paint(["AL" "AK" "AZ" "AR"])

//[0xc420014330] - Button.Paint("OK")

//[0xc420014360] - Button.Paint("Cancel")

for _, painter := range []Painter{label, listBox, button1, button2} {

  painter.Paint()

}

fmt.Println()

//[0xc420014450] - ListBox.Click()

//[0xc420014480] - Button.Click()

//[0xc4200144b0] - Button.Click()

for _, widget := range []interface{}{label, listBox, button1, button2} {

    if clicker, ok := widget.(Clicker); ok {

      clicker.Click()

    }

}

ä¸€ä¸ª Undo çš„å§”æ‰˜é‡æ„

ä¸Šé¢è¿™ä¸ªæ˜¯ Go è¯­ä¸­çš„å§”æ‰˜å’Œæ¥å£å¤šæ€çš„ç¼–ç¨‹æ–¹å¼ï¼Œå…¶å®æ˜¯é¢å‘å¯¹è±¡å’ŒåŸå‹ç¼–ç¨‹ç»¼åˆçš„ç©æ³•ã€‚è¿™ä¸ªç©æ³•å¯ä¸å¯ä»¥ç©å¾—æ›´æœ‰æ„æ€å‘¢ï¼Ÿè¿™æ˜¯å¯ä»¥çš„ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆå£°æ˜ä¸€ä¸ªæ•°æ®å®¹å™¨ï¼Œå…¶ä¸­æœ‰ Add ()ã€ Delete () å’Œ Contains () æ–¹æ³•ã€‚è¿˜æœ‰ä¸€ä¸ªè½¬å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚

type IntSet struct {

    data map[int]bool

}

func NewIntSet() IntSet {

    return IntSet{make(map[int]bool)}

}

func (set *IntSet) Add(x int) {

    set.data[x] = true

}

func (set *IntSet) Delete(x int) {

    delete(set.data, x)

}

func (set *IntSet) Contains(x int) bool {

    return set.data[x]

}

func (set *IntSet) String() string { // Satisfies fmt.Stringer interface

    if len(set.data) == 0 {

        return "{}"

    }

    ints := make([]int, 0, len(set.data))

    for i := range set.data {

        ints = append(ints, i)

    }

    sort.Ints(ints)

    parts := make([]string, 0, len(ints))

    for _, i := range ints {

        parts = append(parts, fmt.Sprint(i))

    }

    return "{" + strings.Join(parts, ",") + "}"

}

æˆ‘ä»¬å¦‚ä¸‹ä½¿ç”¨è¿™ä¸ªæ•°æ®å®¹å™¨ï¼š

ints := NewIntSet()

for _, i := range []int{1, 3, 5, 7} {

    ints.Add(i)

    fmt.Println(ints)

}

for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {

    fmt.Print(i, ints.Contains(i), " ")

    ints.Delete(i)

    fmt.Println(ints)

}

è¿™ä¸ªæ•°æ®å®¹å™¨å¹³æ·¡æ— å¥‡ï¼Œæˆ‘ä»¬æƒ³ç»™å®ƒåŠ ä¸€ä¸ª Undo çš„åŠŸèƒ½ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥ï¼š

type UndoableIntSet struct { // Poor style

    IntSet    // Embedding (delegation)

    functions []func()

}

func NewUndoableIntSet() UndoableIntSet {

    return UndoableIntSet{NewIntSet(), nil}

}

func (set *UndoableIntSet) Add(x int) { // Override

    if !set.Contains(x) {

        set.data[x] = true

        set.functions = append(set.functions, func() { set.Delete(x) })

    } else {

        set.functions = append(set.functions, nil)

    }

}

func (set *UndoableIntSet) Delete(x int) { // Override

    if set.Contains(x) {

        delete(set.data, x)

        set.functions = append(set.functions, func() { set.Add(x) })

    } else {

        set.functions = append(set.functions, nil)

    }

}

func (set *UndoableIntSet) Undo() error {

    if len(set.functions) == 0 {

        return errors.New("No functions to undo")

    }

    index := len(set.functions) - 1

    if function := set.functions[index]; function != nil {

        function()

        set.functions[index] = nil // Free closure for garbage collection

    }

    set.functions = set.functions[:index]

    return nil

}

äºæ˜¯å°±å¯ä»¥è¿™æ ·ä½¿ç”¨äº†ï¼š

ints := NewUndoableIntSet()

for _, i := range []int{1, 3, 5, 7} {

    ints.Add(i)

    fmt.Println(ints)

}

for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {

    fmt.Println(i, ints.Contains(i), " ")

    ints.Delete(i)

    fmt.Println(ints)

}

fmt.Println()

for {

    if err := ints.Undo(); err != nil {

        break

    }

    fmt.Println(ints)

}

ä½†æ˜¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ç”¨äº†ä¸€ä¸ªæ–°çš„ UndoableIntSet å‡ ä¹é‡å†™äº†æ‰€æœ‰çš„ IntSet å’Œã€Œå†™ã€ç›¸å…³çš„æ–¹æ³•ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠæ“ä½œè®°å½•ä¸‹æ¥ï¼Œç„¶å Undo äº†ã€‚

ä½†æ˜¯ï¼Œå¯èƒ½åˆ«çš„ç±»ä¹Ÿéœ€è¦ Undo çš„åŠŸèƒ½ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¦é‡å†™æ‰€æœ‰çš„éœ€è¦è¿™ä¸ªåŠŸèƒ½çš„ç±»å•Šï¼Ÿè¿™æ ·çš„ä»£ç ç±»ä¼¼ï¼Œå°±æ˜¯å› ä¸ºæ•°æ®å®¹å™¨ä¸ä¸€æ ·ï¼Œæˆ‘å°±è¦å»é‡å†™å®ƒä»¬ï¼Œè¿™å¤ªäºŒäº†ã€‚

æˆ‘ä»¬èƒ½ä¸èƒ½åˆ©ç”¨å‰é¢å­¦åˆ°çš„æ³›å‹ç¼–ç¨‹ã€å‡½æ•°å¼ç¼–ç¨‹ã€IoC ç­‰èŒƒå¼æ¥æŠŠè¿™ä¸ªäº‹å¹²å¾—å¥½ä¸€äº›å‘¢ï¼Ÿå½“ç„¶æ˜¯å¯ä»¥çš„ã€‚

å¦‚ä¸‹æ‰€ç¤ºï¼š

æˆ‘ä»¬å…ˆå£°æ˜ä¸€ä¸ª Undo [] çš„å‡½æ•°æ•°ç»„ï¼ˆå…¶å®æ˜¯ä¸€ä¸ªæ ˆï¼‰ï¼›

å¹¶å®ç°ä¸€ä¸ªé€šç”¨ Add ()ã€‚å…¶éœ€è¦ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå¹¶æŠŠè¿™ä¸ªå‡½æ•°æŒ‡é’ˆå­˜æ”¾åˆ° Undo [] å‡½æ•°æ•°ç»„ä¸­ã€‚

åœ¨ Undo () çš„å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¼šéå† Undo [] å‡½æ•°æ•°ç»„ï¼Œå¹¶æ‰§è¡Œä¹‹ï¼Œæ‰§è¡Œå®Œåå°±å¼¹æ ˆã€‚

type Undo []func()

func (undo *Undo) Add(function func()) {

    *undo = append(*undo, function)

}

func (undo *Undo) Undo() error {

    functions := *undo

    if len(functions) == 0 {

        return errors.New("No functions to undo")

    }

    index := len(functions) - 1

    if function := functions[index]; function != nil {

        function()

        functions[index] = nil // Free closure for garbage collection

    }

    *undo = functions[:index]

    return nil

}

é‚£ä¹ˆæˆ‘ä»¬çš„ IntSet å°±å¯ä»¥æ”¹å†™æˆå¦‚ä¸‹çš„å½¢å¼ï¼š

type IntSet struct {

    data map[int]bool

    undo Undo

}

func NewIntSet() IntSet {

    return IntSet{data: make(map[int]bool)}

}

ç„¶ååœ¨å…¶ä¸­çš„ Add å’Œ Delete ä¸­å®ç° Undo æ“ä½œã€‚

Add æ“ä½œæ—¶åŠ å…¥ Delete æ“ä½œçš„ Undoã€‚

Delete æ“ä½œæ—¶åŠ å…¥ Add æ“ä½œçš„ Undoã€‚

func (set *IntSet) Add(x int) {

    if !set.Contains(x) {

        set.data[x] = true

        set.undo.Add(func() { set.Delete(x) })

    } else {

        set.undo.Add(nil)

    }

}

func (set *IntSet) Delete(x int) {

    if set.Contains(x) {

        delete(set.data, x)

        set.undo.Add(func() { set.Add(x) })

    } else {

        set.undo.Add(nil)

    }

}

func (set *IntSet) Undo() error {

    return set.undo.Undo()

}

func (set *IntSet) Contains(x int) bool {

    return set.data[x]

}

æˆ‘ä»¬å†æ¬¡çœ‹åˆ°ï¼ŒGo è¯­è¨€çš„ Undo æ¥å£æŠŠ Undo çš„æµç¨‹ç»™æŠ½è±¡å‡ºæ¥ï¼Œè€Œè¦æ€ä¹ˆ Undo çš„äº‹äº¤ç»™äº†ä¸šåŠ¡ä»£ç æ¥ç»´æŠ¤ï¼ˆé€šè¿‡æ³¨å†Œä¸€ä¸ª Undo çš„æ–¹æ³•ï¼‰ã€‚è¿™æ ·åœ¨ Undo çš„æ—¶å€™ï¼Œå°±å¯ä»¥å›è°ƒè¿™ä¸ªæ–¹æ³•æ¥åšä¸ä¸šåŠ¡ç›¸å…³çš„ Undo æ“ä½œäº†ã€‚

å°ç»“

è¿™æ˜¯ä¸æ˜¯å’Œæœ€ä¸€å¼€å§‹çš„ C++ çš„æ³›å‹ç¼–ç¨‹å¾ˆåƒï¼Ÿä¹Ÿå’Œ mapã€reduceã€filter è¿™æ ·çš„åªå…³å¿ƒæ§åˆ¶æµç¨‹ï¼Œä¸å…³å¿ƒä¸šåŠ¡é€»è¾‘çš„åšæ³•å¾ˆåƒï¼Ÿè€Œä¸”ï¼Œä¸€å¼€å§‹ç”¨ä¸€ä¸ª UndoableIntSet æ¥åŒ…è£… IntSet ç±»ï¼Œåˆ°åè¿‡æ¥åœ¨ IntSet é‡Œä¾èµ– Undo ç±»ï¼Œè¿™å°±æ˜¯æ§åˆ¶åè½¬ IoCã€‚

ä»¥ä¸‹æ˜¯ã€Šç¼–ç¨‹èŒƒå¼æ¸¸è®°ã€‹ç³»åˆ—æ–‡ç« çš„ç›®å½•ï¼Œæ–¹ä¾¿ä½ äº†è§£è¿™ä¸€ç³»åˆ—å†…å®¹çš„å…¨è²Œã€‚è¿™ä¸€ç³»åˆ—æ–‡ç« ä¸­ä»£ç é‡å¾ˆå¤§ï¼Œå¾ˆéš¾ç”¨éŸ³é¢‘ä½“ç°å‡ºæ¥ï¼Œæ‰€ä»¥æ²¡æœ‰å½•åˆ¶éŸ³é¢‘ï¼Œè¿˜æœ›è°…è§£ã€‚

01 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šèµ·æº

02 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šæ³›å‹ç¼–ç¨‹

03 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç±»å‹ç³»ç»Ÿå’Œæ³›å‹çš„æœ¬è´¨

04 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šå‡½æ•°å¼ç¼–ç¨‹

05 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šä¿®é¥°å™¨æ¨¡å¼

06 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šé¢å‘å¯¹è±¡ç¼–ç¨‹

07 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šåŸºäºåŸå‹çš„ç¼–ç¨‹èŒƒå¼

08 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šGo è¯­è¨€çš„å§”æ‰˜æ¨¡å¼

09 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç¼–ç¨‹çš„æœ¬è´¨

10 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šé€»è¾‘ç¼–ç¨‹èŒƒå¼

11 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç¨‹åºä¸–ç•Œé‡Œçš„ç¼–ç¨‹èŒƒå¼

unpreview

Â© ç‰ˆæƒå½’æå®¢é‚¦ç§‘æŠ€æ‰€æœ‰ï¼Œæœªç»è®¸å¯ä¸å¾—ä¼ æ’­å”®å–ã€‚é¡µé¢å·²å¢åŠ é˜²ç›—è¿½è¸ªï¼Œå¦‚æœ‰ä¾µæƒæå®¢é‚¦å°†ä¾æ³•è¿½ç©¶å…¶æ³•å¾‹è´£ä»»ã€‚

å¤§é¾™

ç”±ä½œè€…ç­›é€‰åçš„ä¼˜è´¨ç•™è¨€å°†ä¼šå…¬å¼€æ˜¾ç¤ºï¼Œæ¬¢è¿è¸Šè·ƒç•™è¨€ã€‚

Command + Enter å‘è¡¨

0/2000 å­—

æäº¤ç•™è¨€

ç²¾é€‰ç•™è¨€ (9)

milley

è¿™æ ·çš„ä»£ç å’Œæ€ç»´åªèƒ½è¯´èµå¿ƒæ‚¦ç›®ï¼

2018-02-06

äº¢ï¼ˆçŸ¥è¡Œåˆä¸€çš„è·¯ä¸Šï¼‰

ä¾èµ–çš„ä¸œè¥¿è¦å¯é ã€ç¨³å®šï¼Œä¹Ÿå°±æ˜¯æ¥å£ã€‚

ä¸šåŠ¡ä¸æ§åˆ¶åˆ†ç¦»ï¼Œæ§åˆ¶å°±å¯ä»¥å¤ç”¨ã€‚

æŠŠå˜åŒ–é¢‘ç‡ä¸åŒçš„äº‹ç‰©åˆ†å¼€ã€‚

2019-02-26

Z3

sort.Ints(ints) parts := make([]string, 0, len(ints)) for _, i := range ints {

è¿™å—è¦ sort å—ï¼Ÿ èƒ½å¦ç›´æ¥ for ï¼ˆi=0ï¼›i<lenï¼‰print ints [i]

2018-02-06

å°ç ´

å‡ ä¸ªæœˆå‰å¬åˆ°ä»£ç æ—¶é—´åšèŠ‚ç›®ï¼Œé™ˆè€å¸ˆè®²çš„å†…å®¹è®©æˆ‘æ„Ÿè§‰å¾ˆå®åœ¨ï¼Œä»Šå¤©ç»ˆäºè·Ÿè¿‡æ¥äº†ğŸ˜ƒ

2018-02-06

whiledoing

æœ‰ç‚¹ä¸ç†è§£ï¼Œä¸ºä»€ä¹ˆ Undo çš„å‡½æ•°ä¸æ˜¯ç›´æ¥ delete (set.data, x)ï¼Œè€Œæ˜¯ set.Delete (x)ï¼Œè¿™æ ·å­ä¼šä¸ä¼šå¯¼è‡´ undo çš„é˜Ÿåˆ—ä¸€ç›´åœ¨é€’å½’

2020-02-23

æ‹‰æ¬§

go é‡Œé¢è¿™ä¸ª undo åŠŸèƒ½çš„å®ç°ç±»ä¼¼ scala é‡Œé¢çš„ trait, ä¹Ÿæ˜¯æŠŠä¸€äº›åŠŸèƒ½æ¨¡å—ï¼ˆä»¥åŠå®ç°ï¼‰å•ç‹¬å°è£…èµ·æ¥ï¼Œç„¶åä»¥å§”æ‰˜æˆ–è€…ç»§æ‰¿çš„å½¢å¼ç»„è£…åˆ°ç±»é‡Œé¢ï¼Œè¿™ç§çµæ´»ç»„è£…çš„æ–¹å¼ç¡®å®æ¯” java çš„ interface è¦æ›´æ–¹ä¾¿ä½¿ç”¨ï¼Œä¸åŒè¯­è¨€ä¹‹é—´æ˜¯æœ‰å…±åŒç‚¹çš„

2019-05-29

å¯»æ‰¾çš„äºº cs

web ç«¯åŠŸèƒ½å¤šä¸€ç‚¹å°±å¥½äº†ï¼Œæ¯”å¦‚æ˜¾ç¤ºæ–‡ç« åˆ—è¡¨çš„æ—¶å€™æ„Ÿè§‰ä¸å¦‚ app ç«¯é‚£ä¹ˆæ¸…çˆ½

2019-02-06

xiao è±ª

å£°æ˜ä¸º type Inset map [int] bool å°±ä¸ç”¨å†™æˆ set.data [x]=true è¿™æ ·äº†ï¼Œç›´æ¥ set [x]=true å°±å¯ä»¥äº†ã€‚

2018-02-08

