渲染函数 & JSX

文档视频教程帮助工具核心插件信息
          
          教程
          
            
          
        基础深入了解组件过渡 & 动画可复用性 & 组合工具规模化内在迁移更多基础Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。让我们深入一个简单的例子，这个例子里 render 函数很实用。假设我们要生成一些带锚点的标题：对于上面的 HTML，你决定这样定义组件接口：当开始写一个只能通过 level prop 动态生成标题（heading）的组件时，你可能很快想到这样实现：这里用模板并不是最好的选择：不但代码冗长，而且在每一个级别的标题中重复书写了 <slot></slot>，在要插入锚点元素时还要再次重复。虽然模板在大多数组件中都非常好用，但是显然在这里它就不合适了。那么，我们来尝试使用 render 函数重写上面的例子：看起来简单多了！这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道，向组件中传递不带 v-slot 指令的子节点时，比如 anchored-heading 中的 Hello world!，这些子节点被存储在组件实例中的 $slots.default 中。如果你还不了解，在深入渲染函数之前推荐阅读。节点、树以及虚拟 DOM在深入渲染函数之前，了解一些浏览器的工作原理是很重要的。以下面这段 HTML 为例：当浏览器读到这些代码时，它会建立一个「DOM 节点」树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。上述 HTML 对应的 DOM 节点树如下图所示：每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点（也就是说每个部分可以包含其它的一些部分)。高效地更新所有这些节点会是比较困难的，不过所幸你不必手动完成这个工作。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：或者一个渲染函数里：在这两种情况下，Vue 都会自动保持页面的更新，即便 blogTitle 发生了改变。虚拟 DOMVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：createElement 到底会返回什么呢？其实不是一个 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为「虚拟节点（virtual node)」，也常简写它为「VNode」。「虚拟 DOM」是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。参数接下来你需要熟悉的是如何在 createElement 函数中使用模板中的那些功能。这里是 createElement 接受的参数：深入数据对象有一点要注意：正如 v-bind:class 和 v-bind:style 在模板语法中会被特别对待一样，它们在 VNode 数据对象中也有对应的顶层字段。该对象也允许你绑定普通的 HTML attribute，也允许绑定如 innerHTML 这样的 DOM 属性（这会覆盖 v-html 指令)。完整示例有了这些知识，我们现在可以完成我们最开始想实现的组件：约束VNode 必须唯一组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这渲染函数用完全合法的方式渲染了 20 个相同的段落：使用 JavaScript 代替模板功能 和 只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。比如，在模板中使用的 v-if 和 v-for：这些都可以在渲染函数中用 JavaScript 的 if/else 和 map 来重写：渲染函数中没有与 v-model 的直接对应——你必须自己实现相应的逻辑：这就是深入底层的代价，但与 v-model 相比，这可以让你更好地控制交互细节。事件 & 按键修饰符对于 .passive、.capture 和 .once 这些事件修饰符，Vue 提供了相应的前缀可以用于 on：例如：对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：这里是一个使用所有修饰符的例子：插槽你可以通过  访问静态插槽的内容，每个插槽都是一个 VNode 数组：也可以通过  访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数：如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据对象中的 scopedSlots 字段：JSX如果你写了很多 render 函数，可能会觉得下面这样的代码写起来很痛苦：特别是对应的模板如此简单的情况下：这就是为什么会有一个 Babel 插件，用于在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上。将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的。从 Vue 的 Babel 插件的 3.4.0 版本开始，我们会在以 ES2015 语法声明的含有 JSX 的任何方法和 getter 中（不是函数或箭头函数中）自动注入 const h = this.$createElement，这样你就可以去掉（h）参数了。对于更早版本的插件，如果 h 在当前作用域中不可用，应用会抛错。要了解更多关于 JSX 如何映射到 JavaScript，请阅读使用文档。函数式组件之前创建的锚点标题组件是比较简单，没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法。实际上，它只是一个接受一些 prop 的函数。在这样的场景下，我们可以将组件标记为 functional，这意味它无状态（没有响应式数据)，也没有实例（没有 this 上下文)。一个函数式组件就像这样：注意：在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 props 选项是必须的。在 2.3.0 或以上的版本中，你可以省略 props 选项，所有组件上的 attribute 都会被自动隐式解析为 prop。当使用函数式组件时，该引用将会是 HTMLElement，因为他们是无状态的也是无实例的。在 2.5.0 及以上版本中，如果你使用了单文件组件，那么基于模板的函数式组件可以这样声明：组件需要的一切都是通过 context 参数传递，它是一个包括如下字段的对象：在添加 functional: true 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 context 参数，并将 this.$slots.default 更新为 context.children，然后将 this.level 更新为 context.props.level。因为函数式组件只是函数，所以渲染开销也低很多。在作为包装组件时它们也同样非常有用。比如，当你需要做这些时：下面是一个 smart-list 组件的例子，它能根据传入 prop 的值来代为渲染更具体的组件：向子元素或子组件传递 attribute 和事件在普通组件中，没有被定义为 prop 的 attribute 会自动添加到组件的根元素上，将已有的同名 attribute 进行替换或与其进行智能合并。然而函数式组件要求你显式定义该行为：通过向 createElement 传入 context.data 作为第二个参数，我们就把 my-functional-button 上面所有的 attribute 和事件监听器都传递下去了。事实上这是非常透明的，以至于那些事件甚至并不要求 .native 修饰符。如果你使用基于模板的函数式组件，那么你还需要手动添加 attribute 和监听器。因为我们可以访问到其独立的上下文内容，所以我们可以使用 data.attrs 传递任何 HTML attribute，也可以使用 listeners  传递任何事件监听器。和  对比你可能想知道为什么同时需要 slots(）和 children。slots().default 不是和 children 类似的吗？在一些场景中，是这样——但如果是如下的带有子节点的函数式组件呢？对于这个组件，children 会给你两个段落标签，而 slots().default 只会传递第二个匿名段落标签，slots().foo 会传递第一个具名段落标签。同时拥有 children 和 slots()，因此你可以选择让组件感知某个插槽机制，还是简单地通过传递 children，移交给其它组件去处理。模板编译你可能会有兴趣知道，Vue 的模板实际上被编译成了渲染函数。这是一个实现细节，通常不需要关心。但如果你想看看模板的功能具体是怎样被编译的，可能会发现会非常有意思。下面是一个使用 Vue.compile 来实时编译模板字符串的简单示例：