# 0102. 架构设计的历史背景

李运华 2018-05-01

理解了架构的有关概念和定义之后，今天，我会给你讲讲架构设计的历史背景。我认为，如果想要深入理解一个事物的本质，最好的方式就是去追寻这个事物出现的历史背景和推动因素。我们先来简单梳理一下软件开发进化的历史，探索一下软件架构出现的历史背景。

机器语言（1940 年之前）

最早的软件开发使用的是「机器语言」，直接使用二进制码 0 和 1 来表示机器可以识别的指令和数据。例如，在 8086 机器上完成「s=768+12288-1280」的数学运算，机器码如下：

101100000000000000000011


000001010000000000110000


001011010000000000000101


不用多说，不管是当时的程序员，还是现在的程序员，第一眼看到这样一串东西时，肯定是一头雾水，因为这实在是太难看懂了，这还只是一行运算，如果要输出一个「hello world」，面对几十上百行这样的 0/1 串，眼睛都要花了！

看都没法看，更何况去写这样的程序，如果不小心哪个地方敲错了，将 1 敲成了 0，例如：

101100000000000000000011


000001010000000000110000


001011000000000000000101


如果要找出这个程序中的错误，程序员的心里阴影面积有多大？

归纳一下，机器语言的主要问题是三难：太难写、太难读、太难改！

汇编语言（20 世纪 40 年代）

为了解决机器语言编写、阅读、修改复杂的问题，汇编语言应运而生。汇编语言又叫「符号语言」，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。

例如，为了完成「将寄存器 BX 的内容送到 AX 中」的简单操作，汇编语言和机器语言分别如下。

机器语言：1000100111011000

汇编语言：mov ax,bx

相比机器语言来说，汇编语言就清晰得多了。mov 是操作，ax 和 bx 是寄存器代号，mov ax,bx 语句基本上就是「将寄存器 BX 的内容送到 AX」的简化版的翻译，即使不懂汇编，单纯看到这样一串语言，至少也能明白大概意思。

汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是面向机器的，因为写汇编语言需要我们精确了解计算机底层的知识。例如，CPU 指令、寄存器、段地址等底层的细节。这对于程序员来说同样很复杂，因为程序员需要将现实世界中的问题和需求按照机器的逻辑进行翻译。例如，对于程序员来说，在现实世界中面对的问题是 4 + 6 = ？。而要用汇编语言实现一个简单的加法运算，代码如下：

.section .data


  a: .int 10


  b: .int 20


  format: .asciz "%d\n"


.section .text


.global _start


_start:


  movl a, %edx　　


  addl b, %edx　　


  pushl %edx


  pushl $format


  call printf


  movl $0, (%esp)


  call exit


这还只是实现一个简单的加法运算所需要的汇编程序，可以想象一下，实现一个四则运算的程序会更加复杂，更不用说用汇编写一个操作系统了！

除了编写本身复杂，还有另外一个复杂的地方在于：不同 CPU 的汇编指令和结构是不同的。例如，Intel 的 CPU 和 Motorola 的 CPU 指令不同，同样一个程序，为 Intel 的 CPU 写一次，还要为 Motorola 的 CPU 再写一次，而且指令完全不同。

高级语言（20 世纪 50 年代）

为了解决汇编语言的问题，计算机前辈们从 20 世纪 50 年代开始又设计了多个高级语言，最初的高级语言有下面几个，并且这些语言至今还在特定的领域继续使用。

Fortran：1955 年，名称取自」FORmula TRANslator」，即公式翻译器，由约翰·巴科斯（John Backus）等人发明。

LISP：1958 年，名称取自」LISt Processor」，即枚举处理器，由约翰·麦卡锡（John McCarthy）等人发明。

Cobol：1959 年，名称取自」Common Business Oriented Language」，即通用商业导向语言，由葛丽丝·霍普（Grace Hopper）发明。

为什么称这些语言为「高级语言」呢？原因在于这些语言让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。

还是以 4 + 6=？这个加法为例，如果用 LISP 语言实现，只需要简单一行代码即可：

(+ 4 6)


除此以外，通过编译程序的处理，高级语言可以被编译为适合不同 CPU 指令的机器语言。程序员只要写一次程序，就可以在多个不同的机器上编译运行，无须根据不同的机器指令重写整个程序。

第一次软件危机与结构化程序设计（20 世纪 60 年代～20 世纪 70 年代）

高级语言的出现，解放了程序员，但好景不长，随着软件的规模和复杂度的大大增加，20 世纪 60 年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。例如，1963 年美国（http://en.wikipedia.org/wiki/Mariner_1）的水手一号火箭发射失败事故，就是因为一行 FORTRAN 代码错误导致的。

软件危机最典型的例子莫过于 IBM 的 System/360 的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领 2000 多个程序员夜以继日地工作，共计花费了 5000 人一年的工作量，写出将近 100 万行的源码，总共投入 5 亿美元，是美国的「曼哈顿」原子弹计划投入的 1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了畅销的软件工程书籍。

为了解决问题，在 1968、1969 年连续召开两次著名的 NATO 会议，会议正式创造了「软件危机」一词，并提出了针对性的解决方法「软件工程」。虽然「软件工程」提出之后也曾被视为软件领域的银弹，但后来事实证明，软件工程同样无法根除软件危机，只能在一定程度上缓解软件危机。

差不多同一时间，「结构化程序设计」作为另外一种解决软件危机的方案被提了出来。艾兹赫尔·戴克斯特拉（Edsger Dijkstra）于 1968 年发表了著名的《GOTO 有害论》论文，引起了长达数年的论战，并由此产生了结构化程序设计方法。同时，第一个结构化的程序语言 Pascal 也在此时诞生，并迅速流行起来。

结构化程序设计的主要特点是抛弃 goto 语句，采取「自顶向下、逐步细化、模块化」的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过「自顶向下、逐步细化、模块化」的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了 20 世纪 70 年代软件开发的潮流。

第二次软件危机与面向对象（20 世纪 80 年代）

结构化编程的风靡在一定程度上缓解了软件危机，然而随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就到来了。

第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的「逻辑」变得非常复杂，而第二次软件危机主要体现在软件的「扩展」变得非常复杂。结构化程序设计虽然能够解决（也许用「缓解」更合适）软件逻辑的复杂性，但是对于业务变化带来的软件扩展却无能为力，软件领域迫切希望找到新的银弹来解决软件危机，在这种背景下，面向对象的思想开始流行起来。

面向对象的思想并不是在第二次软件危机后才出现的，早在 1967 年的 Simula 语言中就开始提出来了，但第二次软件危机促进了面向对象的发展。面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。

虽然面向对象开始也被当作解决软件危机的银弹，但事实证明，和软件工程一样，面向对象也不是银弹，而只是一种新的软件方法而已。

软件架构的历史背景

虽然早在 20 世纪 60 年代，戴克斯特拉这位上古大神就已经涉及软件架构这个概念了，但软件架构真正流行却是从 20 世纪 90 年代开始的，由于在 Rational 和 Microsoft 内部的相关活动，软件架构的概念开始越来越流行了。

与之前的各种新方法或者新理念不同的是，「软件架构」出现的背景并不是整个行业都面临类似相同的问题，「软件架构」也不是为了解决新的软件危机而产生的，这是怎么回事呢？

卡内基·梅隆大学的玛丽·肖（Mary Shaw）和戴维·加兰（David Garlan）对软件架构做了很多研究，他们在 1994 年的一篇文章《软件架构介绍》（An Introduction to Software Architecture）中写到：

「When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.」


简单翻译一下：随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的「软件架构」，导致了一系列新的设计问题。

这段话很好地解释了「软件架构」为何先在 Rational 或者 Microsoft 这样的大公司开始逐步流行起来。因为只有大公司开发的软件系统才具备较大规模，而只有规模较大的软件系统才会面临软件架构相关的问题，例如：

系统规模庞大，内部耦合严重，开发效率低；

系统耦合严重，牵一发动全身，后续修改和扩展困难；

系统逻辑复杂，容易出问题，出问题后很难排查和修复。

软件架构的出现有其历史必然性。20 世纪 60 年代第一次软件危机引出了「结构化编程」，创造了「模块」概念；20 世纪 80 年代第二次软件危机引出了「面向对象编程」，创造了「对象」概念；到了 20 世纪 90 年代「软件架构」开始流行，创造了「组件」概念。我们可以看到，「模块」「对象」「组件」本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。

《人月神话》中提到的 IBM 360 大型系统，开发时间是 1964 年，那个时候结构化编程都还没有提出来，更不用说软件架构了。如果 IBM 360 系统放在 20 世纪 90 年代开发，不管是质量还是效率、成本，都会比 1964 年开始做要好得多，当然，这样的话我们可能就看不到《人月神话》了。

小结

今天我为你回顾了软件开发进化的历史，以及软件架构出现的历史背景，从历史发展的角度，希望对你深入了解架构设计的本质有所帮助。

这就是今天的全部内容，留一道思考题给你吧。为何结构化编程、面向对象编程、软件工程、架构设计最后都没有成为软件领域的银弹？

欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）

将学到的知识总结成笔记，方便日后快速查找及复习

unpreview


© 版权归极客邦科技所有，未经许可不得传播售卖。页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。

大龙

由作者筛选后的优质留言将会公开显示，欢迎踊跃留言。

Command + Enter 发表

0/2000 字

提交留言

精选留言 (187)

公号 - 技术夜未眠

2018 年 5 月 1 日心得

在古代的狼人传说中，只有用银质子弹（银弹）才能制服这些异常凶残的怪兽。在软件开发活动中，「银弹」特指人们渴望找到用于制服软件项目这头难缠的「怪兽」的「万能钥匙」。

软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从 IT 技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近「银弹」，但很遗憾，软件活动中没有「银弹」。

布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和 IT 技术中寻找到一个平衡点。个人觉得，对这个平衡点的把握，就是架构设计中的取舍问题。而这种决策大部分是靠技术，但是一定程度上也依赖于架构师的「艺术」，技术可以依靠新工具、方法论、管理模式去提升，但是「艺术」无法量化 ，是一种权衡。

软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的「拆分」方法论，软件架构是一种对软件的「组织」方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制。但是，一个成功的软件设计是要适应并满足业务需求，同时不断「演化」的。设计需要根据业务的变化、技术的发展不断进行「演进」，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的「一招鲜」。

以上只是针对设计领域的银弹讨论，放眼到软件全生命周期，银弹问题会更加突出。

小到一个软件开发团队，大到一个行业，没有银弹，但是「行业最佳实践」可以作为指路明灯，这个可以有。

作者回复：赞，666，你已经提前帮我做了后面相关内容的预热了👍👍

2018-05-01


narry


软件开发最本质的挑战有两个：复杂和变更，而软件的价值是保证业务的响应力，而与之相对的是开发资源的有限，而各种的软件开发方法论，也都是在研究有限的资源下，如何应对着两个挑战，寻找平衡点，实现业务目标，因为是在寻找平衡点，就说明是有取舍的，所以就没有所谓的银弹的存在

作者回复：回答的很好，作者也受到了启发，谢谢👍👍

2018-05-02


cruise


从哲学角度来说，是不存在银弹的。任何技术或方法都不是独立来看的，要综合其它各种相关因素来考虑的。因此对别人来说可能是银弹的，对你来说可能是个炸弹了。架构设计也是一样的，不能脱离业务、公司实际情况、人员配置、经费预算、时间投入等等与技术本身无关的因素，但却又是影响，甚至决定架构设计方向的因素。因此说没有最好，只有更合适。

2018-05-01


felix


变化才是唯一的不变，所以银弹不会存在

作者回复：言简意赅，抓住了核心本质，「银弹」产生于一定的历史背景和大环境，而历史和环境总是会变化的

2018-05-02


合民

作者这个问题是否在考验，读者认真看了这篇文章没有？我认为文章的软件发展历史正是答案，软件工程归根结底是为各行各业的需求服务的，而随着需求的复杂度越来越高，用户的要求越来越高，软件也越复杂，形态也在不断变化，所以没有一种方法论能称得上是银弹，只能说某一种方法论适合某一种需求。这也正是架构师存在的意义，去选择合适的技术，如果有银弹，还要架构师干嘛！以上只是个人见解！

作者回复：你已经看穿一切👍👍

确实是想通过介绍历史来启发大家思考

2018-05-01


李志博

软件开发的结果在于人，而不在于方法论，面向对象，设计模式，架构，这些概念的推出距离现在，好几十年了吧，可真正理解透彻的能有多少呢，就算有像作者这样理解透彻的，还在一线开发的能有多少…… 阿里的 p9 难道还在一线写代码嘛…… 最终写代码的人还是理解不到位的我们，技术强的，写的项目能多撑两年，但是复杂到一定程度，没有良好关系架构指导，都是坑

作者回复：其实不一定要 P9 才要理解到位呢，我 2014 年就写了《面向对象葵花宝典》，那时我还在写代码的哦，其实我现在也写代码，不写代码很多技术没法确切理解，我现在写 demo 代码比较多，例如用 golang 写个简单的区块链，用 java 写个 reactor 等

2018-05-01


Alspadger


因为设计者都是站在当时的业务瓶颈下考虑问题的，因为你不可预测当业务发展的一定程度后，又会遇到怎么样的技术瓶颈。也就是所谓的技术支撑业务发展，业务推动技术发展。

2018-05-01


xuan


「No Silver Bullet」的原文是：「没有任何技术或管理上的进展，能够独立地许诺十年内使生产率、可靠性或简洁性获得数量级上的进步。」之所以这样说，是因为软件的根本困难（Essence，包括复杂度、一致性、可变性、不可见性)

复杂度：规模上，软件实体可能比任何由人类创造的其他实体更复杂，因为没有任何两个软 件部分是相同的

一致性：软件的变化必须遵循一系列接口标准规范，有些情况下它的变化就是要兼容；

可变性：一般有如下几种情况:

1. 当客户喜欢用某个功能或者某个功能能解决他的某些问题时，他会针对这方面提出很多优化该功能的需求点

2. 硬件或者其他配件的升级变化 必须升级现有软件平台

不可见性：软件不存在一种空间形态 可以通过一张图

或者其他载体来可视化展示，不能通过地图 电路设计图等来全面展示.

由于这几个点的变化，导致系统越来越臃肿，从而导致管理成本上升，沟通困难，可靠性逐年下降等等；而结构化 面向对象等主要是来提高生产率 可靠性和简洁性

作者回复：没有看过《人月神话》的程序员不能成为好的架构师😃😃👍👍

2018-05-02


crazyone


感觉像是看大佬们在华山论剑般，评论相当精彩

2018-05-06


Mark Yao


软件本身的复杂度难以度量，随时间和规模发展，原有的解决方案很快难适应，人们就不断总结经验模式和设计解决新困难的办法，但是不管什么样的架构设计都是在尽量满足适应我们可能遇到的问题的解决方案，不是解决问题方案。生活中我们的应用从单体到主备再到集群、分布式、微服务最后到最新的 Service Mesh，这些其实都是解决和改善、完善、优化我们在软件开发遇到的问题。There is no silver bullet.

作者回复：回答正确👍

2018-05-02


淡云天

解空间是建立在问题空间之上的，问题空间的扩展速度远超解空间时，就会架空解空间。而这时就需要新的、适应问题空间扩展速度的解空间来担当这个阶段的银弹。这一点类似于宏观物理学和量子物理学，只不过物理学几百年的进化之路，计算机只用了二十年就走完了。。。

2018-05-02


yoummg


作者的用心令人敬佩。

为什么现在我们在谈「架构」，他不是平白无故产生的，他是在一定的背景下产生的。更好地理解他产生的原因，会在具体解决问题的时候做到有的放矢。

直到现在才看明白，what，why，how。这真是一个认清事物最本质的三步。👍👍👍

作者回复：你已经洞悉天机👍👍😄整个专栏思路就是这样的

2018-07-08


KingPoker


推荐一本书「伟大的计算原理」，把计算机的本质问题描述的很透彻，也给我有一些全新的认知。

2018-05-01


带刺的温柔

软件架构是为了解决大规模开发时遇到的效率、复杂及扩展性问题。听老师所说让我对架构认知又更加清晰落地。但是对拆分粒度越来越粗，层次越来越高理解的还是不够，其实与我的一些开发习惯是相悖的，一般我会尽可能拆分细来保证后期的扩展性。不知道老师我是哪里理解偏差了

2018-05-01


阿罗

超赞👍🏻，

饱含认识论和系统论的理论知识与软件实践知识。太难得了，非大集成者无以为之。我买过最值的课程！

2018-05-01


候鸟归来的季节

技术在不断发展，新的业务需求催生新的技术，没有银弹

2018-05-01


强

关于银弹，我想从另外一个角度聊聊。上学时候，老师 (c++ 标准编写者) 跟我们分享的一思考题：软件究竟属于工程行业还是偏艺术 (或工艺) 行业。前几十年，软件从业者基本是努力将其往工程化发展，像硬件制造一样可控，高度复用，流水生产。经过这些年的发展，工程化基本未实现 (否则码农就和生产线工人一样，工资不会越来越高)，现在越来越多人思考，也行软件更多是艺术行业。既然是艺术类，自然就无银弹的说法

2018-05-02


闭嘴

感觉作者对整个软件行业有比较深入的了解。就是内容太少。还没看就没了。希望后面的文章多来一点干货。让我这种小白能够学习到一点实质的东西。能够解决项目问题的一些东西。希望大神能够把自己的功力展现 60% 就行。

作者回复：这是提炼出来的，为了写这一篇，我写了 2~3 周，如果觉得意犹未尽，可以在这个基础上继续去探索

2018-05-02


老甘

所有的解决方案都是为了解决某一类问题，既然是某一类问题势必是术业有专攻，从辩证的角度也很好理解，事物都有两面性，不存在某种方案可以解决所有问题而没有任何弊端，有弊端自然会出现针对某个场景更好的解决方案。而且，世界在变化，针对现实世界解决问题的软件业务逻辑也势必不断变化，所以只有针对多数场景暂时的银弹，而没有永久的。未来还有更好的

2018-05-01


Welton


技术在不断发展和更新，没有一劳永逸的事物能够代替不断变化的大千世界需求！

2018-05-01


Will


怎么可能出现一套方法能解决一万年后出现的问题呢？

可能时间是「银弹」吧。

2018-05-05


军秋

为什么软件架构还不是银弹，因为还有更加高级的等着我们去开发挖掘。究其原因，我个人认为主要是人在进步，当下看可能是最好的方法，过十年人类经验的积累，可能会发现更好的理论，这可能是个死循环，所以没有银弹。

作者回复：唯一不变的是变化本身

2018-05-01


成功

硬件发展速率和软件设计发展不均衡，形成的矛盾

作者回复：那硬件会不会是银弹呢？例如量子计算机出现，假如性能比现在的计算机提升 1 亿倍，会不会导致软件领域出现革命性变化？如果有可能，那可能会是什么？会是人工智能么？

2018-05-01


laolinshi


每一种开发方法都是应对当时出现的危机而发展出来的，有一定的局限性。随着软件技术的发展，新的问题会层出不穷的出现，必然会催生新的开发方法来解决对应的问题。

2018-05-01


VC


大道至简，治大国，如烹小鲜，软件开发也是如此，所有复杂事情都一样，最难把控的是度。微服务盛行的当下，有多少架构师能把握好度呢？

作者回复：微服务被用烂了

2018-07-27


白马

同意布鲁克斯的观点，没有银弹的一个原因是由于软件本身具有复杂性，一致性，可变性，不可见性。复杂性主要是指软件的复杂程度可以看成代码数量的函数，但是这个函数究竟是什么类型的，不确定，和具体面对的业务领域也有关系。一致性指软件需要和硬件保持一致，而硬件种类繁多，也一直在发展。

2018-05-01


Jaime


应该说都有自己的缺点和优点。看具体场合使用具体的方法，在软件领域就没有银弹的说法。因为业务场景不同，需要用不同的方法去解决业务上的问题。技术是为业务服务的。有些业务可能需要代码简单清晰，此时结构化编程就够了，业务规模加大时，发现耦合过于严重，面向对象就要拿出来解决耦合问题，提高软件可维护性。当规模继续加大，就可能要拆分系统，使用到了微服务的技术，那么此时架构设计就需要解决各个服务之间调用的问题。而在各个微服务里面又可能是用了结构化编程或者面向对象的方法 (要看各个服务自己的业务需求)。软件工程我是不太了解😅😅😅

2018-05-01


顿晓

一个猜测：软件是人造物，理论上是存在银弹的。

从情感上讲：从业者也需要 ta 的存在😄

这样的话，结构化编程、面向对象编程、软件工程、架构设计都是银弹的组成部分。

作者回复：这是说我们一直在完善，从来没达成😃

2018-05-01


时光之刃

知识量好大，循序渐进，读来挺顺畅

2018-05-01


南友力 max 先森🌈

软件系统是为业务服务的，随着业务的变化，软件系统面临的问题也会不断变化，要想得出所有业务问题（包括系统自身的维护问题）的通用解解决方案必须先知道所有的问题域，但现在谁又能说所有的业务和系统问题都已经浮现呢

2018-05-01


kx163


各种软件开发方法都有各自的利弊点，能提高开发效率和降低开发维护成本，但很难降低软件系统本身的复杂性和易变性的特点

2018-05-01


弓土

软件领域没有银弹我理解根因是需求的不断的变化包括底层软件每隔一段时间都会面对上层支撑业务的变化，而当初的制定的策论及方法都没有预料到未来的变化

2018-05-01


Geek_92f9aa


一个答案解决所有问题：「因为熵增定律」。

而熵增的表现其实就是变化。

那如何克服这一变化？

同样是一句话概括：「生命以负熵为食」。

即在生物界，生命通过已知的信息完成外界能量到自身的转移，这个过程虽然逃不过熵增定律，但通过加速外界的熵增实现了生命自身熵的不变，生物因此得以维持自身状态不变 (即活着，没死)

文章说到的架构的历史，其实就是一个对抗熵增的生命演化史。软件本身没有生命，所以要依靠人来实现自身状态维持。

即如果我们将软件和人看成一个整体，那么其状态即是可维持的，所以这就是银弹。而如果将人从这个整体中剥离出去，软件就失去了生命力，无法永远维持自身状态，再牛逼的设计也不可能成为银弹，除非让其拥有对抗熵增的能力，那样的话软件也是有生命的。从这点来看，人工智能极有可能成为一个新生物，届时再也不需要程序员了，恩，人也不需要了，哈哈，细思极恐。

作者回复：别担心，你我有生之年应该还不会被人工智能干掉������

2020-10-29


一飞冲天

古往今来，许多科学家想要找一个万能公式来真正解开世界的真相也就是银弹，但是迄今为止，也没有人能找到，一种世界的物理真理可能在某种世界就失效了，这和软件设计情景很类似，一种很好软件设计思想可能只适合特定的业务场景，它是不可能适用于所有的业务场景的，所以一定要根据现有的业务进行软件设计，并且要适应业务的变化！

2020-06-26


Geek_kevin


这节课收获很大，了解历史，才知道真正的结构化编程，面向对象编程，以及现在的 DDD, 特定时代解决特定问题

作者回复：永远没有银弹

2020-03-22


钱

课后思考及问题

1：我认为，如果想要深入理解一个事物的本质，最好的方式就是去追寻这个事物出现的历史背景和推动因素。

这个观点极其认同，那问题是怎么快速的去追寻某个事物的出现的历史背景和推动因素？历史书 + 积累？

2：无中生有 (万物之始)—— 机器语言 (面相机器，0/1 指令)—— 汇编语言 (面相机器，命令助记符)—— 各种高级语言 (面相具体问题和业务，函数式编程)—— 编译器加持 (屏蔽底层硬件结构的差异，支持各种语言的执行)—— 结构化编程 (面相过程)—— 面相对象编程 (逼近人类思考的过程)。

事物的发展规律，无中生有 —— 由小及大 —— 由简入繁 —— 达到人类思维的带宽极限时，又会被分而治之，在不断复杂化和人类可理解的范围内达到平衡。从上层看人越来越容易操控，但由上往下探索下去，你会发现个人越来越难以独自掌控和理解，问题也在对人类分而治之。你觉得你在扩大你的认知边界，你会发现你的未知边界在更加迅猛的在扩张着，因为世间唯一不变的就是变化。所知是有限的，未知却是无限的，以有限的知识来解决无限的问题，很明显有些问题是无法解决的，那么银弹就只能无限逼近但是总也达不到。

2019-08-24


yiwei.zhou


因为复杂度所以有了模块，因为扩展性所以有了面向对象，因为系统变大所以架构设计变得关键。我们总是因为什么而有了什么。后者是前者的银弹。但新的问题还会出现。没有银弹的观点是站在变化的角度来看。其实银弹早就有了，只是过时了。

2019-04-24


NEO


system360，一场 50 亿美元的豪赌..... 不是 5 亿美元！

2019-04-09


Monday


正文相当精彩，一定得多看几遍。

评论依然精彩，同样不可错过！

2019-02-20


Leon📷


留言区的都是人才，说话声音又好听，留言又有精辟见解，我超喜欢在这里逛了

作者回复：睡觉是不可能的，这辈子都不可能睡觉了😂😂

2018-12-08


水月洞天

软件架构是在特定的环境下，对于特定业务复杂度的系统做出的设计和应对。硬件效率在变，网络资源在变，业务扩张水平在变，互联网的应用体量在变，导致复杂性在变，架构的设计是为了保证软件的稳定和顺利交付，而每次的人力投入水平和资源不同，所以没有万能的银弹。但不同的复杂度情况下，通用的设计能保证稳定性，但不能保证顺利交付

2018-06-08


万历十五年

没有一劳永逸的银弹，只有阶段性的银弹。因为软件开发是有生命的。随着时间的推移，软件开发的规模和业务复杂度会远远超出最初的预判，对应的银弹自然也就失效。

2018-05-19


王旭东

银弹只能是某个历史时间点上存在，但时代在变化，业务在变化（比如用户量剧增），所有以前的银弹并不可能满足现在。故而更多问题的出现也在催生那个时间点的最佳解决方案。大数据、分布式、人工智能等等

2018-05-10


QuincySx


感觉架构实际上是在思想上进行引领与指导，而且与业务逻辑有强耦合，所以每个公司具体业务不同，架构也不太一样，只能说相同的功能去借鉴一下架构设计，并不是那种一针见血的大招，通用性很强

2018-05-07


ciciywg


Jeff Atwood 对《人月神话》的推荐：毫无疑问，这是我们领域里惟一的一本经典图书。如果你还没读过，你应该觉得丢脸！—— 我终于在 2014 年 7 月系统的读完了一遍……

2018-05-07


波波安

软件是用来满足业务的。随着时代的变化，人们思想的变化，软件需要满足和支撑的业务也在变化，所以软件结构也需要不断的演进来满足这种变化的需求。就像在数据爆炸的现在，要利用好这些数据，我们就要有分布式的架构方案来满足大数据存储，大数据的分析。

2018-05-04


路易斯陈凯瑞

银弹的出现是否意味着这个行业已经到头了

2018-05-04


守拙

「没有银弹」直接说是没有意义。在特定的上下文，银弹是存在的。这是模块，对象，组件等概念。来解决特定的通常会碰到的问题。但会存在更多的地方还没有银弹。所以单独的「没有银弹」这句话是没有意义的，而比起这句话，更重要的是不上下文弄懂。

2018-05-01


阿斌

我理解的架构设计，是职责划分的过程，但是对于架构师来说，怎么划分职责一直是一个难题。

作者回复：架构设计的本质和目的，后续章节会详细展开

2018-05-01


🔰夏天的味道

现在组件级别的粒度都已经不够了，所以提出以服务划分的微服务😄

2018-05-01


华林

解决问题的办法绝对不是依赖于越来越高的抽象层次，人类的弱点决定了这样的结果，无论抽象层次有多高，人都会把它变得更复杂，于是导致了更高级别的抽象，然后递归 / 死循环

2018-05-01


华林

解决问题的办法绝对不是依赖于越来越高的抽象层次，人类的弱点决定了这样的结果，无论抽象层次有多高，人都会把它变得更复杂，于是导致了更高级别的抽象，然后递归 / 死循环

2018-05-01


一马行千里

不会有一劳永逸的「银弹」。一个方法可能只能够解决目前的问题，但是基于这个方法会衍生出新的需求，超出了这个方法的能力，我们就需要寻找新的银弹。

2020-11-14


老艮额

都在寻找银弹，如果软件工程找到了银弹，说明这个行业已经进入夕阳期了，不会再有任何发展了。

2020-11-08


ugrg


没有银弹。软件开发是在一种动态的平衡上开展的，当我们能高效的解决现有问题后，新的需求便会应运而生。

2020-10-26


天草二十六

总是听大佬们说银弹，原来出自狼人传说，还是打怪兽用的 。阔以啊～

没有银弹，难怪那么多自称为码农，而非架构师。

2020-10-14


idea


在软件发展的过程中，可以看到内部的程序总是会不断地发生迭代改变，随着业务需求的不断演变，很多原有的设计都会发生变动。设计本质上是一种选择比较适用于当前场景的技术手段，场景在变动也就意味着没有完美的设计，所以这些所谓的「银弹」也就并不会成为最终的「银弹」。

作者回复：到位������

2020-10-11


MClink


因为没有一种方案可以适应所有的情况，时间是流动的，我们在三维角度所思考的方案，并不适用于四维的角度，最好的方案都是基于当前情况的最优解，而不是未来的最优解

2020-10-07


龙猫

世界上没有完美的解决方案，新的技术解决方案出来必然会引来新的问题，我们要做的就是 trade-off

2020-10-04


杨丽南

因为事物是在矛盾中发展的，解决了一个问题肯定会产生新的问题，所以又得有新的解决方案，如此循环往复，螺旋上升。

2020-09-08


escray


第一次软件危机是因为软件的逻辑变得复杂，第二次软件危机是为了软件的扩展，那么现在还继会有软件危机么？（为了隐私保护，上区块链，脑洞）

只有规模庞大、逻辑复杂的系统，才需要更多的考虑软件架构的问题。我以前写过一些小的应用，简单的应用一些框架，使用默认的架构，就够用了。我觉的其实好的架构是慢慢「长」出来的，根据用户需求和系统规模的变化，不断的解决所面临的各种问题，最终形成各种「高大上」的架构。

在什么情况下会出现那种一开始就要求高可用、高性能、可扩展的软件架构？

我能想到的类似于 IBM 360 那样的大型系统有，航天工程、政府项目（例如 12306 网站，或者医保系统之类）、金融管理……

其实很多现在的互联网大厂，当初起家的时候也没有想太多。

作者回复：你的感悟就是后面要讲的内容������������������

2020-09-01


沈聪

「银弹」，体现了人类不满与现状的精神，是对「极简」的追求，从而展现出极大的创造力。生生不息，欲望不止。这就是生命的乐趣吧������������

作者回复：生命不息，折腾不止������

2020-08-28


林毅鑫

评论台精彩了。

银弹被比喻为具有极端有效性的解决方法，作为杀手锏、最强杀招、王牌等的代称。

市场不断变化，环境不断变化，想成为银弹太难。

2020-07-15


TIGEREI


时代在发展，业务在发展，业务对软件的要求也越来越高，势必要求软件方法的进步。

2020-06-25


阿飞

为何结构化编程、面向对象编程、软件工程、架构设计最后都没有成为软件领域的银弹？

-- 上述方法论都是通过提高抽象层次来「缓解」庞大软件项目所带来的的复杂度问题。但随着科技的发展，业务会逐渐复杂，导致软件项目愈加复杂，当该层级的抽象层次无法帮助人们拆分整个系统时，便会产生更高层级的抽象。

也即随着软件复杂度激增，总有一天，「架构」层面的抽象也无法理解系统，此时便需要使用更高级别的抽象理解问题

作者回复：分析到位

2020-06-14


程序员小岑

因为软件的需求不断在变化，每一种方法都有自己适用的场景，没有一种方法可以能够完美解决任何一种场景。

2020-05-14


李乐平

不同领域软件的差异化很大，方法论也很多，而且在不断地变化，想要一个大一统的解决方案复杂度可想而知，只能针对不同阶段一些核心的，普适的问题，提供一些解决方案或模板，以此来缓解问题

2020-04-16


jeri


「人月神话」：如果十个人干一个月，等同于一个人干十个月，那就是神话了，架构设计的目的就是 limit 趋向于这种神话

2020-03-31


哼歌儿李

start with why！👍


2020-03-29


Geek_201908


在软件行业干了有 10 年，第一次系统的了解了软件开发的背景和软件架构设计出现的背景。

软件开发： 机器语言 -> 汇编语言 -> 高级语言 (lisp,cobol 等，后面有 C/C++/Java/Python/GO 等等)

软件架构设计背景： 结构化编程 （可能是我接触时间最长的编程思想。。。C 语言） 、 面向对象编程（目前刚刚入门）、软件工程 、 架构设计

作者回复：这种历史整理还是挺麻烦的

2020-03-28


长街

打卡

2020-03-22


杨小松

打个卡，加深一下理解

2020-03-21


业余爱好者

数据结构和算法退居二线，架构成了软件系统关注的焦点。这是不是一个逃避学习算法的借口。。

架构是为了解决软件工程的危机？

软件工程提出了软件声明周期的概念。而解决危机的办法应该关照软件声明周期的各个阶段。

这样看来，开发时期选用何种语言，如何管理源码，如何测试，也应该算是架构的一部分。而不是以前以为的那样，架构就是一个软件是如何部署的。

对架构概念的理解拓宽了。

作者回复：哈哈，不要逃避，两者应用场景不同

2020-02-28


谭方敏

抛开软件架构不讲，从同构性出发，在大尺度范围内看人类进化演进的历史就知道了，没有万能的原则或者方法论可以解释一切的，并且自然界无飞跃，这就决定演化过程是漫长的，极其复杂的过程，这这个过程中的解都是子问题的解，不是终极解。

再回到软件架构来讲，软件架构出现是为了解决各种情况下出现的问题，在封闭组织中容易出现熵增，熵增则会带来混乱。别忘记了，软件架构解决问题的主体是人，是为了解决人的问题，而人的需求是一直在变化的，所以软件架构本身和人需求不断变化，这是没有银弹的两个核心原因。

2020-02-26


日拱一卒

为何结构化编程、面向对象编程、软件工程、架构设计最后都没有成为软件领域的银弹？

1. 软件设计是在质量、范围、时间、资源之间不停权衡之后的产物，没有任何一种方法可以同时满足上面所有需求。可以说软件开发的过程是带着脚镣跳舞的过程，所以没有银弹。

2. 对于一个已经发布的成熟的产品或者解决方案，随着时间的推移，硬件、软件、行业都在快速发生变化，也不可能有一劳永逸的办法，只能是随着变化而变化，不断的进行演进。

2019-12-20


码农 Kevin 亮

之前准备软考时老是看到结构化方法，心想为啥平时工作都没用过呢。如今读了本文的历史发展才明白，原来那套早过时了，天啊这软考的考点也太跟不上时代了

作者回复：软考跟不上实际的技术发展很正常😂

2019-11-21


JackFish


从汇编、高级语言、面向过程直到架构设计。这些知识人类在计算机科学上的不断尝试而已。或许某一天会出现计算机领域的牛顿来解决某一场景下的所有问题。但人类总会发现新的问题又有新的方法来解决。这些都是人类从第维度到高维度进化的过程。

2019-10-21


梅西

因为世上不存在完美。每个人看待的问题角度也不同。

2019-10-14


卓不凡

开发效率和业务复杂度是矛盾的综合体。业务的不断变化和复杂，需要技术上找到新的银弹。从单机到云原生开发这个过程中就可见一般。

2019-08-07


fomy


老师，为什么后端语言层出不穷，而前端语言或者 sql 语言却一种就够了呢？

作者回复：前端是用户交互的一种方式，用户交互也是经历了很多代技术迭代，前端本身语言也有几种，只是相比来说少一些

2019-08-04


Tang


按照每个十年出现一个难题的规律，从二十世纪九十年代提出软件架构设计后，我们真正在解决的是什么问题？系统多样性的选择

分别有哪些有代表性的解决方案？微服务，设计模式，各类框架

在二十一世纪，有可能面临什么挑战？网络传输速度的加快，磁盘读写的加快，业务复杂度增加，变化的加快；

也许需要计算机来完成这些低难度的业务变更，释放低级工作。

2019-07-28


Geek_88604f


无论是结构化还是面向对象主要解决的是代码如何组织的问题。软件架构解决的是代码组织的组织问题。软件工程则需要规范架构设计，模块设计，编码等研发过程。随着业务的发展，最要命的是一些紧急需求的开发，这些需求往往没有经过良好的设计导致架构逐渐腐化，结构化被打破，最终变成一个焦油坑。因此也就没有银弹了。世间唯一不变的是变化，不断重构既有代码持续做熵减，才是银弹。

作者回复：解析到位👍👍

2019-07-13


AndyLee


从发展的眼光看这个问题。

1 从架构本身的演变来说，架构是为了解决已经出现的问题。有其固有的局限性。

2 从要解决的领悟来说，领域不是一成不变的，新的领域你无法预期。

2019-06-20


l_j_dota_1111


我是做 webgis，其实大部分的精力都是放在前端和数据库存储上，后端的作用就是给前段提供查询接口，向前端提供数据。由于数据库需要支持空间数据，所以用了 postgis。目前遇到的最主要问题就是前端对数据的渲染能力，百万级一起显示，需要大约 5 秒钟，目前还没有很好的解决方案。

作者回复：这个场景有点疑问呀，百万级数据如果全部展示，屏幕肯定放不下，会显得密密麻麻，用户没法看吧，应该用分页或者分层，目前地图都是这样做的

2019-06-03


超

从机器语言到汇编语言到结构化语言到高级语言，从模块到组件到对象，穿过历史的层层迷雾，都是一步一步随着硬件的速度提升以及软件复杂度的提升的 "当时背景下的" 项目的复杂程度逐渐产生的，都是为了解决 "当时最大的痛点" 而推动产生的，时代在发展和变化，前人的积累为后续做了一定的基础，但后人总是会遇到新的问题，因为人们的需求在变化，从而遇到一次又一次的软件危机，从而总结出一个又一个的方法论，但时间的车轮仍然在前进，只要在前进，就没有一蹴而就的方法，就没有一成不变的框架，就没有万能的架构设计，因此，就没有银弹。

作者回复：说的很好👍

2019-05-22


cossea


历史就是借鉴，留给后人就是宝贵经验！

2019-04-24


缘由

感觉就是一个天平，只有一端的加重砝码，另一端才能加砝码，不然肯定不平。所谓的银弹就是直接一端压死，这样不能是天平

2019-04-22


Illiya


软件大多为实现业务逻辑而存在，最终面向的是人类，为人服务。妄想通过某个架构，某种软件解决人的需求，实在强人所难，这里的是软件～毕竟它们只是执行人类的命令，由人创造，无法完全媲美变化多端、思维广拓的人脑

2019-04-19


逍觉迷遥

上古编程时期，使用简单粗暴的机器码 (二进制串)，写个 "hello world" 需要几十甚至达到上百行！

远古编程时期，汇编语言应运而生。采用指令 (mov 等) 代表操作来对数和寄存器做操作，可读性得到了很大的提升！但是计算两个数相加同样需要 14 行代码，现在看来这个着实不少。

古代编程时期，第一代高级语言横空出世。Fortran ，Lisp 等为代表的语言极大程度提高了程序猿的编程效率！但是很快，第一次软件危机爆发 (最具代表性的事件是美国水手一号火箭因为一行代码发射失败)

近代编程时期，结构化编程语言带着解决第一次软件危机的使命从天而降！我最爱的 C 语言也是这个节点诞生的。然而，好景不长，第二次软件危机正悄然降临，它挥一挥衣袖，就让你的项目无所适从！

现代编程时期，程序猿最喜欢的开发模式 —— 面向对象编程浮出水面，它驱走第二次软件危机的阴霾。始于 cpp，得益于 Java，c# 等迅速火遍全球。现在面向对象的语言种类更是层出不穷。话说面向对象编程问世四十余载，面向对象的程序猿真的有对象吗 [捂脸][捂脸][捂脸]

讲架构的课生生被我读成了编程语言进化论 [奸笑][奸笑][奸笑]

那么问题来了，什么时候会迎来第三次软件危机？[疑问][疑问][疑问]

2019-04-12


ZhiQ.Jiang


软件为现实服务，现实结构多复杂，软件就要有多复杂，所以不存在万能的一个银弹来解决所有问题，但有一些方法论可以指导解决问题，比如架构设计上的 "因地制宜"，"可扩展性"，"模块解耦" 等。

2019-03-26


小胖

听了前几节，感觉又像回到了大学专业课堂，组成原理、软件工程，但可能是时长篇幅问题作者只是点到为止，希望后面的课程能够更多一点架构设计方面的干货！

另外，希望平台可以更换此课程的讲述人，用有课程专业背景的人来读书，因为听到各种专业词汇被读错感觉真的是很尴尬😅（比如本课 LISP,FORTRAN 的发音）

作者回复：很多读者说声音很好听😂

2019-03-25


小小杨

软件是不断变化和发展的，所以没有任何方法能完全控制这种变化带来的复杂度，只能缓解，不存在银弹之说。

2019-03-20


行者

结构化编程 面向对象编程 软件架构，都是针对当时面对的情况所提出的解决方案，所以对于未来遇到的问题，并不具有通用性。

软件行业之所以没有银弹，是因为编程需要协调各方面的资源，是一件复杂的工作，任何改进的点都只能改善局部而已。

2019-02-27


HungerW


为什么它们没有成为软件领域的银弹？

因为软件需求场景各异，需求复杂且多变。不可能像工业品一样，制造一个模具，然后批量化生产就好。

2019-02-21


卓不凡

架构设计其实是为了解决大系统耦合问题，系统过大时需要内部各模块相互协调和配合，只有设计合理的架构才能支撑其高性能，高并发，高扩展。

架构设计产生的背景有其历史原因：语言的进化 (机器语言 - 汇编语言 - 高级语言) 释放了程序猿的生产力，软件危机的产生提高了复杂性及扩展性。

从模块 - 对象 - 组件是架构的基本拆分单元和手段，从结构性编程 - 面向对象编程是提高应对复杂性，扩展性的基础。

软件领域没有银弹，银弹只是相对于现在问题的解决方案，随着新问题的出现银弹也会失效。唯一不变的是变化是最好的证明。

2019-01-25


付志波

耦合严重，代码复杂是很多软件设计思想无法成为银弹原因。

2019-01-23


刘滨涛 (陆逾)

设计的本质是为了解决变化问题，不同的环境，不同的需求急需解决的问题也不尽相同，所以没有最好的架构设计，只有合适的架构设计。

2018-12-21


杰之 7

通过这节的阅读学习，了解了程序语言的发展历程，从机器到汇编和第一个高级 Fortran, 然后结构化编程 Pascal 及现在主流的面向对象，在这个发展的过程中，由于软件系统规模的增加，90 时代出现的软件架构的概念。

软件架构主要最先出现在大厂，因为里面的系统规模庞大，耦合严重，逻辑复杂。这样通过阅读知道了编程语言的发展和软件架构的来源，对之后的学习同样会起到重要的帮助。

2018-12-18


小狮子辛巴

看评论发现自己身上一个缺点：对问题的解决没有清晰的脉络。

作者回复：方法论，系统思维，说起来比较虚，但你领悟了后会知道其作用很大

2018-11-08


小 Z

评论已经说的很好了 架构没有银蛋的根本原因就是在于变化。但是对于变化到极致的点来说 银蛋已经存在了。

2018-10-16


Bravery168


从历史的角度可以看出，随着软件解决问题的背景在不断变化，解决问题的工具和方法论也在不断演进和变化。从模块，到组件，到框架，再到架构，前面提出的方法论并没有过时，是一个不断积累和沉淀的过程。最终的目的，我觉得还是要解决软件系统应对外部复杂变化的能力，降低复杂度，降低成本，提高技术的适应力。

2018-10-13


wenjianping


1. 软件的复杂性：

a. 机器交互的复杂性

b. 不可见：运行期不易观察导致的复杂性

c. 需求的复杂性

d. 协作交流的复杂性

e. 要长期维护 (变更) 导致的复杂性

f. 为性能、可用、可靠等而带来的额外的复杂性

g. 为抽象到实现带来的复杂性

2. 对变化的支持

a. 因需要对变化支持，导致不存在不可变的东西

b. 变化导致原有复杂性持续产生影响

c. 变化加剧了原有的复杂性

2018-10-11


lucoffee


比较深刻的是第一次软件危机，火箭发射失败。

2018-10-10


leisure cat


真有银弹的那一天，就不需要架构师了。

2018-10-07


a 煤炭

看评论的有点激动

作者回复：看内容更激动😄

2018-10-06


小胖

任何事都没有银弹

2018-09-28


PiedPiper


我觉得，这个跟人类进化一样，得走到那一步才会遇到那样的问题，然后才会寻求相应的解决方案。没有什么东西是一蹴而就的。都要有一个发展的过程。

作者回复：你已经参透架构设计的其中一个原则👍

2018-09-25


self-discipline


个人认为软件编程的代码组织，业务的复杂度，乃至于现在的数据复杂度数据量来说，都没有唯一的模式加以处理的，计算机领域说不准将来哪个时刻又需要从量产达到质变的

2018-09-21


落雨无声

感觉以前一些一知半解的知识要穿成串了。继续学习。人类的发展史就是不断的发现问题和解决问题，伴随着一个问题的解决，又会产生新的问题，所以所有知识体系的形成，都是一个个不断探索解决方案的过程。

作者回复：第一句话非常关键，知识要串起来才成为系统

2018-08-25


petit_kayak


在管理上有一个说法：每个人最终会被升职到不适合的岗位。软件设计上也有类似的规律，结构化设计、软件工程、面向对象、软件架构，这些出现的时候都起到了改善软件质量、促进软件设计的作用，结果就是软件在这些助推器的帮助下变得更加强大也更加复杂，最终软件的复杂度肯定会超越之前架构的管理能力，引起后者的失败

2018-08-21


各个诗坤

结构化编程，面向对象，软件架构之所以没有成为银弹，是因为系统复杂性的演变，系统的复杂性就像有生命一样，会不断成长。当今的软件的复杂度已经不是一个方法或一个规范能够应对的。它更多需要多种方法的融合，针对不同的细节点，使用不同的方法。也许随着业务或者科技的进步，还会出现新的问题，还会出现新的概念。

2018-08-16


文竹

解决一个特定场景的方法很多，真不敢说某种方法就是银弹，说不定会有更好的方法未被挖掘出来。扩大一点看，就更没有某种方法能适应所有场景，也有新的场景在不断涌现。

2018-08-13


beiler


世上本无银弹，只是大家幻想出来的，要不也不会出现领域驱动，没有任何一个思想可以适用于所有需求，但是反过来说，银弹也是存在的，因为不断的学习不断的深入，核心思想与不断的变通结合才是真正的银弹！

作者回复：唯一不变的是变化👍

2018-08-13


Sky


个人觉得，架构是理论，框架是架构的实现。

作者回复：理解不正确，再看一遍文章😄

2018-08-12


liyue326


要是有银蛋。那也是万能的程序员吧

作者回复：没有这样的程序员，Jeff Dean 也不行😄

2018-07-22


绿豆先生

软件的出现就是为了满足需求，需求的变化是永无止境的，不断的适应新变化才是软件的生命力所在，因此上银弹不存在。

2018-07-16


黄大仙

随着芯片物理极限的不断提升，限制软件运行的主要矛盾，从计算能力和计算成本，加速过渡到想象力上来，而想象力不可能有通用方案。虽然方案不是万能的，但是方案的基本要素是相通的，谁在什么条件下，通过哪些方法，解决哪些人的什么问题。

作者回复：我表示我还没有达到这个境地😄

2018-07-16


yyl


录音工作是主播擅长的，理论知识的讲解是知识专业人擅长的，这样搞有点儿照本宣科啦！

课程内容我感兴趣，但是如此做实在理解不了

作者回复：很多人说录音效果不错呢，如果我去读，这嗓子估计你更不想听😂😂

2018-07-07


varotene


由于接触的大部分都是面向对象的项目，能举几个现代软件业，不使用面向对象的例子吗？

作者回复: redis, nginx 都不是面向对象的，虽然里面用了函数指针来实现了类似面向对象的功能

2018-07-05


哼

现在所做的所有方案都是针对目前发生的问题、所显现或认知到的问题，而并非针对未来在实践过程中产生的新问题，并不存在一个万能的方法一劳永逸解决所有问题。所以并不存在银弹。

2018-06-26


林步蜓

银弹，作为直线子弹，是用来对付明确的一个小目标靶的。

而软件工程或者说一个大产品项目，不是一个目标靶，也不是战术目标，而是未知的战役。

2018-06-26


钢

设计模式是处于架构设计与面向对象之间？

作者回复：设计模式就是面向对象的类和接口设计方法

2018-06-24


念一

时间不会停，问题一直会存在！

2018-06-24


wj


历史的发展已经说明了答案，软件开发演进从机器语言，汇编语言，高级语言，第一次软件危机产生的结构化理论，第二次软件危机的面向对象理论，演进过程中，技术的发展，需求的复杂变化，硬件的改进都会带来与当前的开发模式不协调的地方，例如多核带来的并发并行模型，区块链的发展，cpu 的 numa 和 smp 架构，甚至未来量子理论的发展，都可能改变现在的研发思维..

2018-06-16


Cola


1. 技术是一个渐进式的发展过程，任何设计思想都是针对当下环境的解决方案 2. 架构设计是图纸，最后真正添砖加瓦的是执行人，架构设计的目的是让让系统接近业务处理的极限，这个上限始终是由业务层决定，如果业务代码混乱，到最后再好的架构设计都会无用武之地

作者回复：好的架构能够降低业务代码混乱的影响范围

2018-06-14


火山飘雪

我认为软件是为业务需求服务的，只要业务服务不断的变化，复杂度不断得增加，软件开发就会跟着变更

2018-05-29


巫

个人理解，从某些角度来说，银弹还是存在的。不同问题、不同时期会有不同的银弹。银弹可以杀死狼人，但可能杀不死进化的狼人。

正像大家说的，软件有多方面的复杂性，银弹也就不止一种。

2018-05-29


Adun Ton


没有银弹，需求的发展使问题总是超前于有效的方法。

2018-05-29


mkmonkey


银弹：终极大招！没有一个软件是靠大招来上线的，是靠着前后端的配合，测试的严谨来完成项目的，没有哪个环节代替所有

2018-05-28


sensitivemix


需求总是变化～没有银弹，老师说的很好

2018-05-27


雨林霖

架构终究是为了实现业务，没有大一统的架构支撑千变万化的业务

2018-05-27


清晨之风

架构不只是技术的堆砌，更是一种艺术的权衡，和美学的体现。

作者回复：是的，就像是梵高的画，很多时候看不懂😃😃

2018-05-27


小小鸟

总是有问题 总是要解决 不断演化

作者回复：学到老，写到老，赚到老😃😃😃

2018-05-25


howie6879


简简单单的发展历程，道出了编程语言的进化史，老师很厉害，茅塞顿开，在解决问题中进化，问题无止尽，也就看不到所谓的银弹了

2018-05-22


Forrest Li


架构设计的历史背景：从机器语言、汇编语言到高级语言，程序员们终于可以开始施展拳脚，但面对现实世界中各种各样的复杂场景，这些初出茅庐、不经世事的年轻人、年轻技术还需要继续发展。

计算机硬件技术的发展、业务场景的复杂多变使得软件技术也需要不断更新适配，因此没有一种彻底的解决思路。

2018-05-21


missa


软件领域，复杂性随意技术的发展，不断的变得复杂，多样化。架构也需要不断去优化，每个发展阶段可能都有不同的解决方案，但是从头到尾不能靠一种方案解决一切

2018-05-16


孙振超

从唯物主义哲学来讲，任何时候都会存在主要矛盾和次要矛盾，利用一种方法解决了主要矛盾，之前的次要矛盾现在就变成了主要矛盾。换一个通用的说法，没有包治百病的药。

学习架构的目的也是为找到一些应对常见问题的通用方法套路，这些方法套路不能保证一定可以解决问题，但可以确保不出现重要的遗漏，出现重大的风险和问题，如同学中医的人不会把两个相冲的药放到一起。

2018-05-13


海滨

因为软件领域不断在发展，业务越来越复杂、规模越来越大，这几种方案都只能解决当时特定环境下的问题。

2018-05-13


阿飞

结构化编程、面向对象编程、架构设计、软件工程这些解决当前时代问题而产生的方法，没有哪个方法是一劳永逸的

2018-05-12


周偲

作者的 github 地址是哪里呀？还有博客，方便说一下吗？

作者回复：没有参与真正的开源项目，博客好久没更新了，目前偶尔在知乎和 infoq 冒个泡😃

2018-05-11


Storm


所谓的银弹就是在当时历史环境下平衡各种条件的最佳实践。但历史在进步，所以没有一劳永逸的银弹。

2018-05-09


blue


用反过来思考，什么样才能称之为银弹，我的理解是「能解决问题」，任何的技术都是为了需求为了业务场景服务，时代再变，需求在变，当原有的技术无法满足新的需求场景时，就会衍生出新的「银弹」。

2018-05-08


CHaNniNG


结构化编程、面向对象编程、软件工程、架构设计这一些列演变都是在追求「更好」的解决方案，而银弹的本质是一种「最好」的解决办法，我们在历史的局限环境下无法对一个时刻在演变的领域做出最优的解，而只能对现有的问题进行合适处理，让它在未来短暂的一段时间内不至于爆发出来，表面是我们人类的历史局限性导致的，根本还是我们对更复杂更大型更强大系统追求的欲望产物。

2018-05-08


周彬

无论什么样的语言，最终都将面对业务逻辑复杂度的增加裙带来的开发效率低下的问题，需求的变化和人们对业务理解的增加，都会使得软件复杂度不断增加，如何从设计上解决未来一定时间内的复杂度上升的方法，才是解决软件危机的方法，至少在这一段时间内是的，所以架构设计的重要性可见一斑，因为这就是架构设计的作用，这是我的一点理解，不知道有没有跑偏，额。

2018-05-08


小河

发展历史：架构设计的历史背景和推动因素。

机器语言，汇编语言 40，高级语言 50 + 编译。

第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的「逻辑」变得非常复杂，而第二次软件危机主要体现在软件的「扩展」变得非常复杂。

为了解决软件危机：（缓解方法）6070

软件工程，

结构化程序设计：自顶向下，逐步细化，模块化。

面向对象，

面向过程 c 语言和面向对象 c++,c#,java 等 80。

软件架构：组件 90。

「模块」「对象」「组件」本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。

2018-05-08


Enjoystudy


这是个变化的世界，没有什么方法能一成不变地去解决软件开发中遇到的所有问题，唯有拥抱变化不断变革才能更好的拥抱这个时代

2018-05-07


余红松 - 北京

# 读书笔记

- 从一个事物的历史开始引入，对理解事物，是个很好的方式。

- 计算机语言发展的历史：计算机软件语言的发展历史，是一个从底层向上层，逐层封装面向人类更加友好的方式，一步步建立从 01 这种机器友好方式，到贴近于人类业务和语言和图形化的人类友好方式，的人机交互的接口进化的历史。

- 软件危机之魔咒，在现实生活中，通过观察发现计算机硬件一直没能跟上软件业务和需求的压力，不管技术如何进步，技术的发展并没有带来人类工作量下降，人类的劳动量一直处于极限状态下，无法跟上对文明的追求速度，而软件开发语言的进化程度，也将无法跟上实际人类在计算机上附加的业务的开发量，软件开发语言和工具的进化程度，也将永远处于人类文明业务量压力之下的危机之中。

- 软件危机将会再次来袭，下次将会是人工智能相关。

2018-05-06


孙晓明

社会在发展，人们对软件的需要也在不断变化，同时，软件运行的载体～硬件、网络等也不断更新换代，这都促使软件领域也要不断变化才能跟上时代，而软件工程、架构设计等技能都是为适应当时的软件需求而产生，当软件领域变化时，它所对应的解决方案和方法论也不可避免的要发生变化。只有一时的银弹，没有永远的银弹。

2018-05-06


loveluckystar


世界上就不存在针对某项事物的万金油或者银弹，只存在某种情况下的局部较优解。这也正是架构设计的价值，针对不同场景，不同阶段，进行架构设计，因地制宜，找到最佳实践。

2018-05-05


OnE


「模块」「对象」「组件」本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。

2018-05-05


Jacob 周

感觉这个系列在这个平台会成为 IT 行业的一代经典，别的课程已经很难超越。理由很简单，别的地方没有的东西，这里有，而且这么好。

作者回复：谢谢你的夸奖，相信还会有更多厉害的专栏出现，我希望成为第一个，但绝对不是最后一个😃

2018-05-05


赵小 R

结构化变成不是银弹，面向对象也没有成为银弹，同样软件架构也不会是银弹。这是一个哲学问题。

2018-05-05


波波安

软件是用来满足业务的。随着时代的变化，人们思想的变化，软件需要满足和支撑的业务也在变化，所以软件结构也需要不断的演进来满足这种变化的需求。就像在数据爆炸的现在，要利用好这些数据，我们就要有分布式的架构方案来满足大数据存储，大数据的分析。

2018-05-04


KingPoker


比较好奇 面向对象设计和软件架构是一个层面的事情吗？

作者回复：不是一个层面，但产生的历史背景都是为了应对某个复杂度

2018-05-04


jack


倒觉得是通过软件架构和软件工程结合，共同解决人员分工、进度管理、质量控制的问题。

2018-05-03


杨宏志

个人认为，没有银弹是因为好的架构永远不存在，架构没有好坏只有合适与否。特定的业务变化会演进特定的架构方式。过度设计肯定不好，但适当的臃肿不一定就是坏的

2018-05-03


aaa 于海威

因为复杂度和并发量在一次次突破想象

2018-05-03


三军

结构化编程，面向对象编程，软件工程，软件架构之所以不是银弹，是因为它们是软件设计发展史上不同阶段的开发方式，它们是可行的，可实践的，在一定的阶段内起到各自的优势，不断发展必定存在它们的瓶颈，未来可能有 "软件生态"，"软件宇宙" 之称。

2018-05-03


十七

除了软件规模增长，复杂度增加，业务需求变化之外，软件工程对降低成本，提升效率的要求也倒逼着「银单」的升级

2018-05-03


ZYCHD (子玉)

从机器语言到高级语言的改变是本质上的改变它是银弹就像是从绳子打结记忆到到笔墨纸砚的出现是保存信息的银弹。面向过程编程面向对象编程组件模块的概念更像是从篆书到楷书行书的发展，这种发展更趋向在一个平面内的横向探索研究缺少纵向上的突破，所以它不是银弹。

2018-05-03


Forrest Li


业务为王，软件应用场景多有差别，即使确定场景下，需求变化也很频繁，很难说一种思路解决所有问题。

2018-05-03


碧海蓝天

架构本质就是对某一具体问题的具体解决方法。一万个问题可能有一万个架构。没有一成不变的问题，当然就没有一成不变的架构。业务在变，问题变了，架构也需跟着变，只是大变与小变的区别。

2018-05-03


丶 Zero 灬

个人观点：原因在于业务的发展还在继续，当你解决一个问题之后还会有新的问题出现。也就是发展。如果存在「银弹」反而说明技术停滞了。

2018-05-03


呆呆很爱你

软件架构不可能「以不变应万变」，必须与时俱进，不同时代的新问题需要不同的技术应对策略

2018-05-03


张驰

因为软件的发展永远跟随着硬件的发展而发展，软件是跟着硬件后面跑的，随着硬件设备的发展会不断的有新问题出现，软件也要不断迭代更新，所以说没有一颗有效的银弹。

2018-05-03


itperson


任何架构或者开发方法 只是部分适合某个团队 在团队磨合中逐渐找到适合团队自身的方法 而不是照搬某种模式 软件开发领域向来没有绝对的真理 只有不断迭代才能精进

2018-05-02


小柒 2012

就像程序员总是抱怨需求老是在变一样，架构设计所谓的银弹也总是暂时的而已。

2018-05-02


YunliangChen


没有一个方法能解决所有问题

2018-05-02


Will


（1）软件领域的问题不光是技术问题，还有业务，资源，人等各种不同的问题交织在一起，而且随着时间的推进，这些问题的轻重缓急等等还在不断的发生变化，因此如果想要光从技术层面来解决社会问题，这本来就不太可能。

（2）设计层面的改进，包括基于结构化，基于对象，基于架构本身都是要解决系统的复杂性，但是在这期间包括项目管理，系统测试，需求分析自己的方向上取得了很多进步，我想需要系统各个层面全方位的推进，并保持各个部分的均衡，才能更好的解决问题。

2018-05-02


井红军

模块，对象，组件可以说是程序员组织代码的演变.... 这可以解决数据上离散问题，当今软件业务发展属于软件外的东西。设计模式也只不过解决特定领域的问题…… 通过软件架构能够解决业务复杂问题属于痴人说梦

2018-05-02


少年

银弹是个愿景，就像 PHP 是世界上最好的语言一样，是个美好的梦想。

现实中来说，我们不需要银弹，我们需要的是能解决问题的又合适的。

2018-05-02


Jason


我想开发个 SAAS 云平台，做人事系统，想用 Java 开发，哪个框架比较好 Spring Boot, Spring Clould?

2018-05-02


SMTCode


软件的复杂性和需求的多变，使得没有哪一种方案能解决所有的问题。而且一种方案解决了部分问题后，还会引入其他问题或发现其他问题。充满不确定性的问题不可能有确定的解。

作者回复：你已经上升到哲学高度了😃不过确实是这个道理

2018-05-02


衡

软件的发展过程也是人类虚拟化世界的过程。人在变 世界在变 人对世界的认知也在变，没有银弹

2018-05-02


大兵

就像人们都在追求幸福，但是却没有幸福的统一标准，大家都在以各自的公式走在追求幸福的路上

2018-05-02


老王

先需求，后架构。架构设计是为了满足需求的，软件需求在不同的历史阶段，呈现不同的特点，未来也是不断变化的，软件开发方法也需要不断更新。

2018-05-02


琴扬枫

生产力和生产关系是相互影响的，就像从蒸汽时代进入电器时代再进入信息时代，blablabla。如果银弹存在，那文明可能就止步不前了。

2018-05-02


Jzw


模块、对象和组件都是解决代码的组织和结构问题，而真正复杂的是业务。譬如我们懂得诗词的平仄和押韵技法，但不代表你能填出一阙好词。

2018-05-02


不记年

在时间成本存在的前提下，语言的发展，编程思想的发展，软件工程的发展都是不得不的，都是在解决有限认知带宽下削减软件复杂度

2018-05-01


caiyun


事物是不断发展变化的，我们的系统也是一样，不断变化，错综复杂，面向过程或者面向对象或者架构都是不断发展过程中解决问题的方法和思想的产物，但也不能适用于所有的事物

2018-05-01


江明

软件开发在不断的快速发展，不同的发展阶段会遇到不同的问题，不同的问题又会催生不同的解决办法。用发展的眼光看待的话，没有一个方案或是方法能解决所有问题。

2018-05-01


fish007


个人以为目前的技术发展，脱离了「解决问题」这个根本，距离和机器语言最接近的汇编语言也太远。多样化的问题解决方案，本身就制造了无穷无尽的复杂性。整个行业缺乏大道至简的战略部署，也不可能产生全球一体化的技术发展规划，怎么可能产生银弹。

2018-05-01


还是我

世界是个开放的不确定的进化的系统，软件开发一直在描述这个真实的系统，当然也会相应出现新的问题和困难。

2018-05-01


Mike Wang


人类的欲望无止境，渴望的是无所不能，至死不休，现有的事物包含计算机相关只是资源技术受限的一种妥协方案，架构模式也只是曲折中前进时总结的经验而已，银弹只是对未知恐惧的一种自欺欺人的想法，当然，因为未知，所以以银弹为寄托继续前进也挺好。

2018-05-01


Greeny


既定设计赶不上随时代变化的需求

2018-05-01


正弋

不同的软件有不同的功能侧重及非功能需求，注定了没有银弹能照顾到所有类型的软件

2018-05-01


AJIE


只要软件上线一直在服务于市场，那么对于软件需求的跟变就是不可预测的。任何应对未来变化的计划都不能确保百分百的 hold 住。

2018-05-01


