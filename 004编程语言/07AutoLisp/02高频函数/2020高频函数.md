## 01. 替换字符串

This subfunction will substitute all occurrences of a string for another string within a string. The functionality is similar to the Visual LISP vl-string-subst (and indeed uses this function), however, this subfunction performs a global replacement, hence all occurrences of the pattern string are replaced.

```c
;;--------------------=={ String Subst }==--------------------;;
;;                                                            ;;
;;  Substitutes a string for all occurrences of another       ;;
;;  string within a string.                                   ;;
;;------------------------------------------------------------;;
;;  Author: Lee Mac, Copyright © 2011 - www.lee-mac.com       ;;
;;------------------------------------------------------------;;
;;  Arguments:                                                ;;
;;  new - string to be substituted for 'old'                  ;;
;;  old - string to be replaced                               ;;
;;  str - the string to be searched                           ;;
;;------------------------------------------------------------;;
;;  Returns:  String with 'old' replaced with 'new'           ;;
;;------------------------------------------------------------;;

(defun StringSubst (new old str / inc len)
    (setq len (strlen new)
          inc 0
    )
    (while (setq inc (vl-string-search old str inc))
        (setq str (vl-string-subst new old str inc)
              inc (+ inc len)
        )
    )
    str
)
```

1『代码里 `inc (+ inc len)` 是有讲究的，替换一次后，往后移动一个步长 `strlen new` 是明智的。哈哈。（2020-10-12）』

## 02. 按正则表达式提取字符串

详见数据流源码。

## 03. 数组去重

[Unique & Duplicate List Functions | Lee Mac Programming](http://lee-mac.com/uniqueduplicate.html)

Here are various subfunctions for manipulating lists in which items appear more than once. The list may be tested for or irradicated of all duplicate items, with a set of functions offering optional tolerances below which items are considered duplicate; or such duplicate items may instead be returned by the function. Alternatively, the number of occurrences of each item in a list may be displayed. Information about the purpose of each function is detailed in the comments above each function, and the required arguments and returns are demonstrated in the examples.

详见数据流源码。

## 04. 判断某个元素是否在该数据内

2020-12-22

使用内置函数 `member` 实现：[member (AutoLISP)](http://help.autodesk.com/view/OARX/2018/CHS/?guid=GUID-A2B08751-D966-44F5-9B02-1AAC4DA6AF59)。

Searches a list for an occurrence of an expression and returns the remainder of the list, starting with the first occurrence of the expression.

Signature:

```c
(member expr lst)
```

expr. Type: Integer, Real, String, List, Ename (entity name), T, or nil. The expression to be searched for.

lst. Type: List. The list in which to search for expr.

Return Values. Type: List or nil. A list; otherwise nil, if there is no occurrence of expr in lst.

Examples:

```c
(member 'c '(a b c d e))
(C D E)

(member 'q '(a b c d e))
nil
```

基本思路是通过函数 `member` 返回的是否为 nil 来判断是否在该数组里。一个使用场景是在开发接图图号块自动更新功能是，接图块绑定的数据 id 有可能不存在（设计人员把之前绑定的那个管子删掉了），所需必须考虑这种情况。

```c
; repair bug - JoinDrawArrow's relatedid may be not in the allPipeHandleList - 2020.12.22(defun GetRelatedPipeDataByJoinDrawArrowData (JoinDrawArrowData allPipeHandleList /)   (if (/= (member (cdr (assoc "relatedid" JoinDrawArrowData)) allPipeHandleList) nil)     (GetAllPropertyValueByEntityName (handent (cdr (assoc "relatedid" JoinDrawArrowData))))    (alert (strcat (cdr (assoc "fromto" JoinDrawArrowData)) "（" (cdr (assoc "drawnum" JoinDrawArrowData)) "）" "关联的管道数据id是不存在的！"))  ))
```

## 05. 选择集按坐标排序

[Sort Selectionset by X coord](https://forums.augi.com/showthread.php?137837-Sort-Selectionset-by-X-coord)

[Selection Set Processing | Lee Mac Programming](http://www.lee-mac.com/selsetprocessing.html)

1 Create list of enames.

2 (vl-sort lst (function (lambda (a b) (> (cadr (assoc 10 (entget a))) (cadr (assoc 10 (entget b)))))))

3 Create new selection set with ssadd.

4 Step (foreach) through sorted (#2) list and ssadd enames to newly created selection set.

Thanks for the direction, I'm still having issues though. Perhaps I'm not building my list properly, but for some reason the lambda function grabs the first item, then tries to grab the entire rest of the list as the second item, That obviously doesnt work, as it cant grab the entdata from a list of entities. How do you suggest creating the list, I know that there are multiple ways of doing it, I'm using (setq lst (list ss lst)) which based on my results isnt the proper way to do it.
here is the error I'm receiving

```c
; error: bad argument type: lentityp (nil)
```

Nevermind, I figured it out. I had to set each item as a list, then append my lists together. Works great!

```c
(setq ss (ssget '((0 . "TEXT") (8 . "C-ROAD-STAN-OFFS")))) ;_ select all objects
  (setvar "osmode" 64)
  (setq stp (getpoint "\nSelect insert point of first text obj")) ;_ select start point
  (setq    count1 (sslength ss)
    count  1
    xcoord (- (car stp) 0.135)
    ss1    (ssadd)
    ss4    (list (ssname ss (1- count)))
    ss6    (ssadd)
  ) ;_ end of setq
  (while (<= (1+ count) count1)        ;SORT LIST BY X COORD LOW TO HIGH
    (setq ss3 (list (ssname ss count)))
    (setq ss4 (append ss4 ss3))
    (setq count (1+ count))
  ) ;_ end of while
  (vl-sort ss4
       (function (lambda (a b) (> (cadr (assoc 11 (entget a))) (cadr (assoc 11 (entget b))))))
  ) ;_ end of vl-sort
  (setq    count 0
    counta 1
  ) ;_ end of setq
  (foreach ss5 (reverse ss4)
    (setq ss6 (ssadd ss5 ss6))
  )
```

I like to segregate the functionality of each step of the function so that I can build very general toolbox functions that allow me to make changes. Like here I convert a selection set to a list, change the list into a list of sublists ivgncluding the xyz coordinates of the entities, sort by the x y and z coordinates (either up or down), convert the list of sublists back to a list of entities and then into a selection set. I like the list of sublists structure and use this sort function all the time.I also like storing selections sets as lists of entities or objects.

```c
(defun sortListofSublistsbyItemX (lstOfSublists intItem intDirection)
 (if (> intDirection 0)
  (vl-sort lstOfSublists '(lambda (X Y) (< (nth intItem X) (nth intItem Y))))
  (vl-sort lstOfSublists '(lambda (X Y) (> (nth intItem X) (nth intItem Y))))
 )
)

(defun SelectionSetToList (ssSelections / intCount lstReturn)
 (if (and ssSelections 
          (= (type ssSelections) 'PICKSET)
     )
  (repeat (setq intCount (sslength ssSelections))
   (setq intCount  (1- intCount)
         lstReturn (cons (ssname ssSelections intCount) lstReturn)
   )
  )
 )
 (reverse lstReturn)
)

(defun ListToSelectionSet (lstOfEntities / ssReturn)
 (if lstOfEntities      
  (foreach entItem lstOfEntities
   (if (= (type entItem) 'ENAME)
    (if ssReturn 
     (setq ssReturn (ssadd entItem ssReturn))
     (setq ssReturn (ssadd entItem))
    )
   )
  )
 )
 ssReturn
)

(defun SortSelectionSetByXYZ (ssSelections /  lstOfSelections lstOfSublists lstSelections)
 (if
  (and 
   (setq lstSelections (SelectionSetToList ssSelections))
   (setq lstOfSublists (mapcar '(lambda (X)(cons X (cdr (assoc 10 (entget X))))) lstSelections))
   (setq lstOfSublists (sortlistofsublistsbyitemX lstOfSublists 3 1))
   (setq lstOfSublists (sortlistofsublistsbyitemX lstOfSublists 2 1))
   (setq lstOfSublists (sortlistofsublistsbyitemX lstOfSublists 1 1))
   (setq ssSelections  (listtoselectionset (mapcar 'car lstOfSublists)))
  )
  ssSelections
 )
)
```