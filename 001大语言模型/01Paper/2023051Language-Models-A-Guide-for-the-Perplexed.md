## 2023051Language-Models-A-Guide-for-the-Perplexed

Language Models: A Guide for the Perplexed

Sofia Serrano∗

Zander Brumbaugh∗ 

Noah A. Smith∗

### 01 IntroductionIn

late November 2022, OpenAI released a web-based chatbot, ChatGPT. Within a few months, ChatGPTwas reported to be the fastest-growing application in history, gaining over 100 million users. Reports in thepopular press touted ChatGPT's ability to engage in conversation, answer questions, play games, write code,translate and summarize text, produce highly fluent content from a prompt, and much more. New releasesand competing products have followed, and there has been extensive discussion about these new tools: Howwill they change the nature of work? How should educators respond to the increased potential for cheating inacademic settings? How can we reduce or detect misinformation in the output? What exactly does it take(in terms of engineering, computation, and data) to build such a system? What principles should informdecisions about the construction, deployment, and use of these tools?Scholars of artificial intelligence, including ourselves, are baffled by this situation. Some were taken abackat how quickly these tools went from being objects of mostly academic interest to artifacts of mainstreampopular culture. Some have been surprised at the boldness of claims made about the technology and itspotential to lead to benefits and harms. The discussion about these new products in public forums is oftenpolarizing. When prompted conversationally, the fluency of these systems' output can be startling; theirinteractions with people are so realistic that some have proclaimed the arrival of human-like intelligence inmachines, adding a strong emotional note to conversations that, not so long ago, would have mostly addressedengineering practices or statistics.Given the growing importance of AI literacy, we decided to write this tutorial to help narrow the gap betweenthe discourse among those who study language models—the core technology underlying ChatGPT andsimilar products—and those who are intrigued and want to learn more about them. In short, we believe theperspective of researchers and educators can add some clarity to the public's understanding of the technologiesbeyond what's currently available, which tends to be either extremely technical or promotional materialgenerated about products by their purveyors.Our approach teases apart the concept of a language model from products built on them, from the behaviorsattributed to or desired from those products, and from claims about similarity to human cognition. As astarting point, we:

1. Offer a scientific viewpoint that focuses on questions amenable to study through experimentation,

2. Situate language models as they are today in the context of the research that led to their development, and

3. Describe the boundaries of what is known about the models at this writing.

Popular writing offers numerous, often thought-provoking metaphors for LMs, including bureaucracies ormarkets (Henry Farrell and Cosma Shalizi), demons (Leon Derczynski), and a“blurry JPEG”of the web (TedChiang). Rather than offering a new metaphor, we aim to empower readers to make sense of the discourseand contribute their own. Our position is that demystifying these new technologies is a first step towardharnessing and democratizing their benefits and guiding policy to protect from their harms.LMs and their capabilities are only a part of the larger research program known as artificial intelligence (AI).(They are often grouped together with technologies that can produce other kinds of content, such as images,under the umbrella of“generative AI.”) We believe they're a strong starting point because they underlie theChatGPT product, which has had unprecedented reach, and also because of the immense potential of naturallanguage for communicating complex tasks to machines. The emergence of LMs in popular discourse, andthe way they have captured the imagination of so many new users, reinforces our belief that the languageperspective is as good a place to start as any in understanding where this technology is heading.The guide proceeds in five parts. We first introduce concepts and tools from the scientific/engineering field ofnatural language processing (NLP), most importantly the notion of a “task” and its relationship to data(section 2). We next define language modeling using these concepts (section 3). In short, language modelingautomates the prediction of the next word in a sequence, an idea that has been around for decades. We thendiscuss the developments that led to the current so-called“large”language models (LLMs), which appear todo much more than merely predict the next word in a sequence (section 4). We next elaborate on the currentcapabilities and behaviors of LMs, linking their predictions to the data used to build them (section 5). Finally,we take a cautious look at where these technologies might be headed in the future (section 6). To overcomewhat could be a terminology barrier to understanding admittedly challenging concepts, we also include aGlossary of NLP and LM words/concepts (including“perplexity,”wryly used in the title of this Guide).

2022 年 11 月下旬，OpenAI 发布了一个基于 web 的聊天机器人 ChatGPT。在几个月内，ChatGPT 被报道成为历史上增长最快的应用程序，获得超过一亿用户。大众媒体的报道吹捧 ChatGPT 能够参与对话、回答问题、玩游戏、编写代码、翻译和总结文本、从提示中生成高度流畅的内容等等。随后出现了新的版本和竞争产品，人们对这些新工具进行了广泛的讨论：它们将如何改变工作的性质？教育者应该如何应对学术环境中日益增加的作弊可能性？如何减少或检测输出中的错误信息？构建这样一个系统需要什么 (在工程、计算和数据方面)? 关于这些工具的构建、部署和使用，应该遵循哪些原则？

包括我们自己在内的人工智能学者对此感到困惑。一些人吃惊地发现，这些工具很快就从学术兴趣的对象变成了主流流行文化的人工制品。一些人对这项技术的大胆宣称及其潜在的利与弊感到惊讶。在公共论坛上对这些新产品的讨论常常两极分化。当以对话方式提示时，这些系统输出的流畅性会令人吃惊；他们与人的互动是如此现实，以至于有些人宣称机器中出现了类似人类的智能，为不久前主要涉及工程实践或统计的对话增添了强烈的情感色彩。

鉴于人工智能素养日益重要，我们决定编写本教程，以帮助缩小那些研究语言模型 (ChatGPT 和类似产品的核心技术) 的人与那些感兴趣并想了解更多的人之间的差距。简言之，我们相信研究者和教育者的观点可以使公众对现有技术的理解更加清晰，这些技术往往是由供应商提供的关于产品的技术性或宣传性材料。

我们的方法将语言模型的概念与构建在其上的产品、归因于这些产品或期望从这些产品中获得的行为以及与人类认知相似的主张区分开来。作为起点，我们：

1. 提供一个科学的观点，聚焦于可通过实验研究的问题，

2. 将语言模型定位在导致其发展的研究背景中，以及 3. 描述本文中关于模型的已知边界。

流行的写作为 LMs 提供了许多，通常是发人深省的隐喻，包括 (亨利·法雷尔和科斯玛·沙利兹)，(莱昂·德钦斯基) 和 (特德·蒋)。我们的目标不是提供一个新的隐喻，而是使读者能够理解话语并贡献自己的力量。我们的立场是，揭开这些新技术的神秘面纱是利用和民主化它们的好处和指导政策以防止其危害的第一步。官僚机构或市场恶魔模糊 JPEG 属于这个 web LMs 及其功能只是更大的人工智能 (AI) 研究项目的一部分。它们通常与能够产生其他类型内容 (如图像) 的技术组合在一起，在「生成 AI」的保护伞下。我们认为它们是一个强有力的起点，因为它们是 ChatGPT 产品的基础，ChatGPT 产品具有前所未有的影响力，也因为自然语言在向机器传达复杂任务方面具有巨大潜力。LMs 在流行语篇中的出现，以及它们吸引了如此多新用户的想象力的方式，强化了我们的信念，即语言视角是理解这项技术走向的最佳起点。

本指南分为五个部分。我们首先介绍自然语言处理 (NLP) 科学 / 工程领域的概念和工具，最重要的是「任务」的概念及其与数据的关系（第 2 节）。接下来我们将使用这些概念定义语言建模（第 3 节）。简而言之，语言建模可以自动预测序列中的下一个单词，这一想法已经存在了几十年。然后，我们讨论导致当前所谓的「大型」语言模型 (LLM) 的发展，LLM 似乎不仅仅是预测序列中的下一个单词（第 4 节）。接下来，我们将详细介绍 LMs 的当前功能和行为，并将其预测与用于构建 LMs 的数据联系起来（第 5 节）。最后，我们将仔细研究这些技术在未来的发展方向（第 6 节）。为了克服可能成为理解公认具有挑战性概念的术语障碍，我们还包括 NLP 和 LM 词汇表（包括本指南标题中讽刺地使用的「困惑」）。23

### 02. Background

Background: Natural language processing concepts and tools

Language models as they exist today are the result of research in various disciplines, including informationtheory, machine learning, speech processing, and natural language processing.1 This work's authors belong tothe community of natural language processing (NLP) researchers, members of which have been exploringthe relationship between computers and natural languages since the 1960s.2 Two fundamental and relatedquestions asked in this community are:“In what ways can computers understand and use natural language?”and“To what extent can the properties of natural languages be simulated computationally?”The first questionhas been approached mainly by attempts to build computer programs that show language-understanding andlanguage-use behavior (such as holding a conversation with a person); it is largely treated as an engineeringpursuit that depends heavily on advances in hardware. The second question brings NLP into contact withthe fields of linguistics, cognitive science, and psychology. Here, language tends to be viewed through ascientific lens (seeking to experimentally advance the construction of theories about natural language as anobservable phenomenon) or sometimes through a mathematical lens (seeking formal proofs). Because thesetwo questions are deeply interconnected, people interested in either of them often converse and collaborate,and many are interested in both questions.We believe the concepts (ideas, terminology, and questions) and tools (problem-solving methods) the NLPcommunity uses in research are helpful in advancing understanding of language models. They are familiar tomany AI researchers and practitioners, and similar ones have evolved in other communities (for example,computer vision). If you have experience with computer programming, data science, or the discrete math foundations of computer science, you may have been exposed to these ideas before, but we don't believe theyare universally or consistently taught in classes on those topics. Having a basic understanding of them willhelp you to think like an NLP expert.

背景：自然语言处理的概念和工具

今天存在的语言模型是信息理论、机器学习、语音处理和自然语言处理等多个学科研究的成果。1 本文的作者们属于自然语言处理（NLP）研究者社区，该社区成员自 20 世纪 60 年代以来一直在探讨计算机与自然语言之间的关系。2 这个社区中提出的两个基本且相关的问题是：「计算机如何理解和使用自然语言？」和「自然语言的特性在多大程度上可以通过计算方式模拟？」第一个问题主要通过尝试构建展示语言理解和语言使用行为（例如与人进行对话）的计算机程序来解决；它主要被视为一项以硬件进步为基础的工程追求。第二个问题将 NLP 与语言学、认知科学和心理学等领域联系起来。在这里，语言通常被视为一个科学现象（寻求实验性地推进关于自然语言的理论构建）或有时通过数学角度（寻求形式证明）来看待。由于这两个问题紧密相连，对其中任一问题感兴趣的人经常进行交流和合作，许多人对两个问题都感兴趣。我们认为 NLP 社区在研究中使用的概念（观点、术语和问题）和工具（解决问题的方法）有助于加深对语言模型的理解。这些概念对许多 AI 研究者和从业者来说都很熟悉，并且在其他社区（例如计算机视觉）中也有类似的发展。如果你有计算机编程、数据科学或计算机科学的离散数学基础方面的经验，你可能已经接触过这些概念，但我们认为这些概念并没有在相关课程中普遍或一致地教授。了解这些基本概念将帮助你像 NLP 专家一样思考。

1 A “natural language”is a language that developed naturally in a community, like Hawaiian or Portuguese or American SignLanguage. For the most part, NLP researchers focus on human languages and specifically written forms of those languages. Mostoften, natural languages contrast with programming languages like Python and C++, which are artifacts designed deliberatelywith a goal in mind.

2 There are other uses of the“NLP”acronym with very different meanings. Ambiguous terms and expressions are common in natural languages, and one of the challenges of the field of NLP.






2.1 Taskification: Defining what we want a system to do

The first step in building a machine is deciding what we want the machine to do. People who build powerplants, transportation devices, or cooking appliances work from a specification that spells out the inputs andoutputs of the desired system in great detail. It's not enough to say that“the power plant must provideelectricity to all the homes in its town.”Engineers require a precise statement of how many kiloWatt-hoursare to be produced, the budget for building the plant, environmental impacts expected, all the laws regulatingthe construction of plants that are in effect to guarantee safety, and much more.To take an example that's much simpler and more relevant to building an NLP system, consider a computerprogram (which is a“machine”in a very abstract sense; we'll also call it a“system”) that sorts a list ofnames alphabetically. This task sounds simple, and computer science students would likely start thinkingabout different procedures for sorting lists. There are, however, some details that need to be addressed beforewe start writing code, such as:

• How will the names be input to the program, and what should the program do with the output? (E.g.,will the program run locally on a user's laptop? Or is there a web interface users will use to type in theinput and then see the output in their browser tab? Or will they upload/download files? If so, what isthe format for those files?)

• What set of characters will appear in the input, and what rules are we using to order them? (E.g., howdo we handle the apostrophe in a name like“O'Donnell”? How should diacritic (accented) charactersbe handled? What happens if some names are in Latin script and others in Arabic script?)

• Are there constraints on how much memory the program can use, or on how quickly it needs to execute?If the input list is so long that the program will violate those constraints, should the user get a failuremessage?

Figure 1: Some tasks, like alphabetical name sorting, may seem very simple but often raise detailed questionsthat must be addressed for a full specification.

These may seem like tedious questions, but the more thoroughly we anticipate the eventual use of the systemwe're building, the better we can ensure it will behave as desired across all possible cases.





2.1.1 Abstract vs. concrete system capabilitiesWhen building an NLP system, the situation is no different than the name sorter, except that it's considerablyharder to be precise. Consider some of the kinds of capabilities the NLP community has been targeting in itssixty-year history:

• Translate text from one language to another• Summarize one or more documents in a few paragraphs or in a structured table• Answer a question using information in one or more documents• Engage in a conversation with a person and follow any instructions they give

4

Each of these high-level applications immediately raises a huge number of questions, likely many more thanfor simpler applications like the name sorter, because of the open-ended nature of natural language input (andoutput). Some answers to those questions could lead an expert very quickly to the conclusion that the desiredsystem just isn't possible yet or would be very expensive to build with the best available methods. Researchersmake progress on these challenging problems by trying to define tasks, or versions of the application thatabstract away some details while making some simplifying assumptions.For example, consider the translation of text from one language to another. Here are some fairly conventionalassumptions made in many translation research projects:

• The input text will be in one of a small set of languages; it will be formatted according to newspaper-like

writing conventions. The same holds for the output text.

• Text will be translated one sentence or relatively short segment of text at a time.• The whole segment will be available during translation (that is, translation isn't happening in“real

time”as the input text is produced, as might be required when subtitling a live broadcast).

It's not hard to find research on automatic translation that makes different assumptions from those above. Anew system that works well and relies on fewer assumptions is typically celebrated as a sign that the researchcommunity is moving on to harder problems. For example, it's only in the past few years that we have madethe leap from systems that support single input-to-output translations to systems that support multipleinput-to-output languages. We highlight that there are always some narrowing assumptions, hopefullytemporary, that make a problem more precise and therefore more solvable.We believe that many discussions about AI systems become more understandable when we recognize theassumptions beneath a given system. There is a constant tension between tasks that are more general/abstract,on which progress is more impactful and exciting to researchers, and tasks that are more specific/concrete.Solving a concrete, well-defined task may be extremely useful to someone, but certain details of how thattask is defined might keep progress on that task from being useful to someone else. To increase the chancesthat work on a concrete task will generalize to many others, it's vital to have a real-world user communityengaged in the definition of that task.

2.1.2 We need data and an evaluation method for research progress on a taskThe term“task”is generally used among researchers to refer to a specification of certain components of anNLP system, most notably data and evaluation:

• Data: there is a set of realistic demonstrations of possible inputs paired with their desirable outputs.• Evaluation: there is a method for measuring, in a quantitative and reproducible way, how well any

system's output matches the desired output.

Considerable research activity focuses on building datasets and evaluation methods for NLP research, and thetwo depend heavily on each other. Consider again the translation example. Examples of translation betweenlanguages are easy to find for some use cases. A classic example is parliamentary language translated fromEnglish to French, or vice versa. The proceedings of the Canadian Parliament are made available to the publicin both English and French, so human translators are constantly at work producing such demonstrations;paired bilingual texts are often called“parallel text”in the research community. The European Parliamentdoes the same for multiple languages. Finding such data isn't as easy for some languages or pairs of languages,and as a result, there has been considerably more progress on automated translation for European languagesthan for others.What about evaluation of translation? One way to evaluate how well a system translates text is to takea demonstration, feed the input part to a system, and then show a human judge the desired output andthe system output. We can ask the judge how faithful the system output is to the desired output. If thejudge speaks both languages, we can show them the input instead of the desired output (or in addition to it)and ask the same question. We can also ask human judges to look only at the system output and judge thefluency of the text. As you can imagine, there are many possible variations, and the outcomes might dependon exactly what questions we ask, how we word those questions, which judges we recruit, how much they

5

know about translation systems already, how well they know the language(s), and whether and how much wepay them.In 2002, to speed up translation evaluation in research work, researchers introduced a fully automated way toevaluate translation quality called“Bleu”scores (Papineni et al. 2002), and there have been many proposedalternatives since then, with much discussion over how well these cheaper automatic methods correlate withhuman judgments. One challenge for automatic evaluation of translation is that natural languages offer manyways to say the same thing. In general, reliably rating the quality of a translation could require recognizingall of the alternatives because the system could (in principle) choose any of them.We used translation as a running example precisely because these questions are so contentious and potentiallycostly for this task. We'll next consider a fairly concrete task that's much simpler: categorizing the overalltone of a movie review (positive vs. negative), instantiating a more general problem known as sentimentanalysis. Here, researchers have collected demonstrations from movie review websites that pair reviews withnumerical ratings (e.g.„ one to five stars). If a system takes a review as input and predicts the rating, we caneasily check whether the output exactly matches the actual rating given by the author, or we could calculatethe difference between the system and correct ratings. Here, the collection of data is relatively easy, and thedefinition of system quality is fairly uncontroversial: the fewer errors a system makes (or the smaller thedifference between the number of author stars and system-predicted stars), the higher the system's quality.Note, however, that a system that does well on the movie review sentiment task may not do so well on reviewsof restaurants, electronics products, or novels. This is because the language people use to say what they likeor don't like about a movie won't carry the same meaning in a different context. (If a reviewer says that amovie“runs for a long time,”that isn't as obviously positive as the same remark about a battery-operatedtoothbrush, for example.) In general, knowing the scope of the task and how a system was evaluated arecrucial to understanding what we can expect of a system in terms of its generalizability, or how well itsperformance quality holds up as it's used on inputs less and less like those it was originally evaluated on. It'salso essential when we compare systems; if the evaluations use different demonstrations or measure qualitydifferently, a comparison won't make sense.For most of its history, NLP has focused on research rather than development of deployable systems. Recentinterest in user-facing systems highlights a longstanding tension in taskification and the dataset and evaluationrequirements. On one hand, researchers prefer to study more abstract tasks so that their findings will bemore generally applicable across many potential systems. The scientific community will be more excited,for example, about improvements we can expect will hold across translation systems for many languagepairs (rather than one) or across sentiment analysis systems for many kinds of reviews (rather than justmovies). On the other hand, there is near-term value in making a system that people want to use because itsolves a specific problem well, which requires being more concrete about the intended users, their data, andmeaningful evaluation.There is yet another step between researching even fairly concrete tasks and building usable systems. Theseare evaluated very differently. Evaluations in research tend to focus on specific, narrowly defined capabilities,as exemplified in a sample of data. It's an often unstated assumption in research papers that improvedtask performance will generalize to similar tasks, perhaps with some degradation. The research communitytends to share such assumptions, with the exception of research specifically on generalization and robustnessacross domains of data. Meanwhile, deployable systems tend to receive more rigorous testing with intendedusers, at least to the extent that they are built by organizations with an interest in pleasing those users. Indeployment,“task performance”is only part of what's expected (systems must also be reasonably fast, haveintuitive user interfaces, pose little risk to users, and more).People interested in NLP systems should be mindful of the gaps between (1) high-level,aspirational capabilities, (2) their "taskified" versions that permit measurable research progress,and (3) user-facing products. As research advances, and due to the tension discussed above,the "tasks" and their datasets and evaluation measures are always in flux.

6

2.2 A closer look at data: where it comes from and how it's usedFor the two task examples discussed above (translation and sentiment analysis tasks), we noted thatdemonstrations (inputs with outputs) would be relatively easy to find for some instances of the tasks.However, data might not always be so easy to come by. The availability of data is a significant issue for tworeasons:

• For most NLP applications, and most tasks that aim to approximate those applications, there is no“easy”source of data. (Sentiment analysis for movie reviews is so widely studied, we believe, because thedata is unusually easy to find, not because there is especially high demand for automatic number-of-starsprediction.)

• The best known techniques for building systems require access to substantial amounts of extra data to

build the system, not just to evaluate the quality of its output.

2.2.1 Differentiating training from test dataFrom here on, we refer to data used to build a system as training data and data used to evaluate systemsas test data. This distinction is extremely important for a reason that's easy to understand.

Figure 2: When data is split into training and test sets, it's critical there is no overlap between the two.

Consider a student who somehow gets a copy of the final exam for one of their classes a few weeks before theexam. Regardless of how much the student is to blame in accessing the test, regardless of whether they evenknew the exam they saw was the actual final exam, regardless of how honorably they behaved during thoseweeks and during the test, if they get a high score, the instructor cannot conclude that the student learnedthe material. The same holds true for an NLP system. For the test data to be useful as an indicator of thequality of the system's output, it is necessary that the test data be“new”to the system. We consider thisthe cardinal rule of experimentation in NLP: The test data cannot be used for any purpose prior tothe final test. Occasionally, someone will discover a case where this rule was violated, and (regardless ofthe intent or awareness of those who broke the rule) the conclusions of any research dependent on that casemust be treated as unreliable.

7

To get a sense of an NLP system's actual quality, it is crucial that the system not be evaluatedon data it has seen during training.

2.2.2 Creating a dataset from scratchLet's consider a variant of the sentiment analysis problem that might emerge in a high-stakes academicdecision-making setting. Suppose we plan to build an NLP system that reads recommendation letters forapplicants to a university degree program. The system should rate the sentiment of the recommender towardthe applicant. On the surface, this is similar to the movie review problem we discussed previously. But thisuse case introduces some new challenges.First, we are unlikely to find demonstrations that we could use to train or evaluate a system.3 Recommendationletters are extremely private; those who write them do so on the assumption that they will not be revealedto anyone who doesn't need to read them to assess the application. If we manage to find recommendationletters on the public web, it's likely that they either aren't supposed to be there (and are therefore unethicalto use) or they're synthetic examples used to teach people how to write or evaluate recommendation letters(and therefore artificial and probably different from actual letters in key practical ways—remember that weneed realistic demonstrations).A second issue is that the information conveyed in a recommendation letter is often complex, consideringmany aspects of a candidate's performance and potential. Mapping the letter down to a single number orcategory seems quite challenging (if it were easy, we wouldn't ask recommenders to write letters, we'd onlyask them to report the number or category). Finally, as anyone who has been on an admissions or hiringcommittee knows, there is a great deal of subjectivity in interpreting a recommendation letter. Differentreaders may draw different conclusions about the prevailing signal in a single letter. Even if we overcome thehurdle of finding letters to use, that's only half of what we need because the demonstrations need to includedesired outputs as well as inputs.Indeed, the tasks that researchers explore or system builders try to explore are very often limited by the datathat's available. When the desired data (or anything similar to it) is unavailable, it's sometimes possibleto create it. For example, to automate sentiment analysis of social media messages about a particularmuch-discussed public figure, we could hire people to do the task of labeling a sample of messages, essentiallydemonstrating the desired behavior for our eventual system. Labeling tweets about a politician might berelatively easy for someone who speaks the language of the tweets and is familiar with the social context.Some tasks, in contrast, require much more expertise. For example, to build a system that answers questionsabout medical journal articles, we'd want the data to be created by people who know how to read andunderstand such articles so that the answers are accurate and grounded in article specifics. Of course, expertswill be more costly to employ for this work than non-experts. A major tradeoff in the creation of datasets forNLP is between the inherent quality and diversity of the demonstrations and the cost of producing them. Webelieve that high-quality data is always essential for reliable evaluations (test data) and usually essential forhigh performance on those evaluations (training data).Collecting training data for most NLP tasks is quite difficult, and this often impacts whichpossible NLP applications or problems are studied.

2.3 Building an NLP systemFor almost a decade, and with a small number of exceptions, the dominant approach to building an NLPsystem for a particular task has been based on machine learning. Machine learning (ML) refers toa body of theoretical and practical knowledge about data-driven methods for solving problems that areprohibitively costly for humans to solve. These methods change over time as new discoveries are made, asdifferent performance requirements are emphasized, and as new hardware becomes available. A huge amount3In NLP terms, finding and collecting such existing demonstrations would count as dataset creation.“Creating a dataset”inNLP can refer to either creating of new text via expert annotation or crowdsourcing, or collecting existing text into a morereadily accessible form for model developers, such as via web crawling or scraping.

8

of tutorial content is already available about machine learning methods, with new contributions followingfast on the heels of every new research advance. Here, we introduce a few key ideas needed to navigate thecurrent landscape.The first concept is a parameter. A parameter is like a single knob attached to a system: Turning the knobaffects the behavior of the system, including how well it performs on the desired task. To make this concrete,let's consider an extremely simple system for filtering spam emails. Due to budgetary constraints, this systemwill have only one parameter. The system works as follows: it scans an incoming email and increments acounter every time it encounters an“off-color”word (e.g., an instance of one of the seven words the comedianGeorge Carlin claimed he wasn't allowed to say on television). If the count is too high, the email is sent tothe spam filter; otherwise, it goes to the inbox. How high is too high? We need a threshold, and we need toset it appropriately. Too high, and nothing will get filtered; too low, and too many messages may go to spam.The threshold is an example of a parameter.This example neatly divides system-building problem into two separate parts:

1. Deciding what parameters the system will have and how they will work. In our spamexample, the system and the role of the off-color word threshold parameter are easy to explain. Theterm architecture (or model architecture, to avoid confusion with hardware architecture) typicallyrefers to the decision about what parameters a model will have. For example, picture a generic-lookingblack box with lots of knobs on it; the box has a slot on one side for inputs and a slot on the other sidefor outputs. The“architecture”of that model refers to the number of knobs, how they're arranged onthe box, and how their settings affect what occurs inside the box when it turns an input into an output.2. Setting parameter values. This corresponds to determining what value each individual knob onthe box is turned to. While we likely have an intuition about how to set the parameter in the spamexample, the value that works the best is probably best determined via experimentation.

We now walk through how ML works in more detail and introduce some components you'll likely hear aboutif you follow NLP developments.

2.3.1 Architectures: Neural networksToday, the vast majority of architectures are neural networks (sometimes called artificial neural networksto differentiate them from biological ones). For our purposes, it's not important to understand what makesneural networks special as a category of architectures. However, we should know that their main propertiesinclude (1) large numbers of parameters (at this writing, trillions) and (2) being differentiable4 functionswith respect to those parameters: addition, subtraction, exponentiation, trigonometric functions, etc., andcombinations of them. A general observation about neural network architectures (but not a necessary ordefining property) is that the relationship between their numerical calculations and the task-solving behaviorof a model (after its parameters are set) is not explainable to human observers. This is why they are associatedwith the metaphor of a black box (whose internal components can't be observed or easily understood).

2.3.2 Choosing values for all the parameters: Minimizing a loss functionIn order to work well, a neural network needs to have its parameters set to useful values (i.e., values thatwill work well together to mathematically transform each input into an output close to the input's correctanswer). But how do we choose parameters' values when we have so many we need to decide? In this section,we describe the general strategy that we use in NLP.Imagine yourself in the following (admittedly not recommended) scenario. At night, and with no GPSor source of light on you, you are dropped in a random location somewhere over the Cascade Range inWashington State with the instructions to find the deepest valley you can (without just waiting for morning).You move your feet to estimate the steepest downward direction. You take a small, careful step in thatdirection and repeat until you seem to be in a flat place where there's no direction that seems to take youfarther downward.

4We are referring to the concept from calculus. If a function is“differentiable”with respect to some numbers it uses, thencalculus gives us the ability to calculate which small changes to those variables would result in the biggest change to the function.

9

Machine learning (and, by extension, NLP) views the setting of parameter values as a problem of numericaloptimization, which has been widely studied for many years by mathematicians, statisticians, engineers,and computer scientists. One of the tools of machine learning is an automated procedure that frames theparameter value-setting problem like that terrifying hike. Recall that we said that neural networks need tobe differentiable with respect to their parameters— that is, they need to be set up to allow calculus to tell uswhich tiny change to each parameter will result in the steepest change of something calculated using theneural network's output. In our nighttime hike scenario, at each step, we make a tiny adjustment to ournorth-south and east-west coordinates (i.e., position on the map). To adjust the parameters of our neuralnetwork, we will consider our current set of parameters our“coordinates”and likewise repeatedly make tinyadjustments to our current coordinates. But what does it mean to move“down”in this context? Ideally,moving“down”should correspond to our neural network producing outputs that better match our data. Howcan we define a function—our“landscape”— such that this is true?A loss function is designed for precisely this purpose: to be lower when a neural network performs better.In short, a loss function evaluates how well a model's output resembles a set of target values (our trainingdata), with a higher“loss”signifying a higher error between the two. The more dissimilar the correct outputis from the model's produced output, the higher the loss value should be; if they match, it should return zero.This means a loss function should ideally be closely aligned to our evaluation method.5By performing the following procedure, we are able to train a neural-network-based model:

1. We use a loss function to define our landscape for our model's nighttime hike based on our training

inputs and outputs,

2. we make a small adjustment to each of our coordinates (model parameters) to move“down”that

landscape towards closer matches between our model's outputs and the correct ones, and

3. we repeat step 2 until we can't make our model's outputs any more similar to the correct ones.

This method is known as (stochastic) gradient descent (SGD), since the direction that calculus gives usfor each parameter is known as the“gradient.”Leaving aside some important details (for example, how to efficiently calculate the gradients using calculus,working out precisely when to stop, exactly how much to change the parameter values in step 3, and sometricks that make the algorithm more stable), this method has proven effective for choosing parameter valuesin modern model architectures and in their predecessors.

2.3.3 The hardware: Graphics processing units (GPUs)For over a decade, graphics processing units (GPUs) have been the main type of hardware used to trainNLP models based on neural networks. This may seem counterintuitive (since it's language we're processinghere, not graphics). However, GPUs are effective for doing many matrix and vector calculations in parallel,and successful neural network architectures have used these parallel calculations to perform input-to-outputmapping quickly (since stochastic gradient descent requires that mapping to be performed many many timesduring training). Indeed, the realization that neural networks were well-suited to train on GPUs proved to becrucial to their widespread adoption.

3 The language modeling taskSection 2 introduced some NLP concepts and tools, including the idea of encapsulating a desired applicationinto a“task,”the importance of datasets, and a high-level tour of how systems learn to perform a task usingdata. Here, we turn to language modeling, a specific task.

5You can think of a loss function as a stern, reserved teacher grading a student's work. The student (the model whoseparameters we want to set) is given an exam question (an input to the model) and produces an answer. The teacher mechanicallycompares the question's correct answer to the student's answer, and then reports how many points have been deducted formistakes. When the student gets the answer perfectly right, the loss will be zero; no points are deduced. We discuss someadditional mathematical details of loss functions in the appendix.

10

3.1 Language modeling as next word predictionThe language modeling task is remarkably simple in its definition, in the data it requires, and in its evaluation.Essentially, its goal is to predict the next word in a sequence (the output) given the sequence of precedingwords (the input, often called the“context”or“preceding context”). For example, if we ask you to come upwith an idea of which word might come next in a sentence in progress—say,“This document is about NaturalLanguage ____”—you're mentally performing the language modeling task. The real-world application thatshould come to mind is some variation on an auto-complete function, which at this writing is available inmany text messaging, email, and word processing applications.Language modeling was for several decades a core component in systems for speech recognition and texttranslation. Recently, it has been deployed for broad-purpose conversational chat, as in the various GPTproducts from OpenAI, where a sequence of“next”words is predicted as a sequential response to a naturallanguage prompt from a user.

Figure 3: Next word prediction samples a word from the language model's guess of what comes next at eachtime step.

What would make it possible to achieve high accuracy at predicting the next word across many contexts? Ata fundamental level, natural language is predictable because it is highly structured. People unconsciouslyfollow many rules when they use language (e.g., English speakers mostly utter verbs that agree with theirsubjects sometime after those subjects, and they place adjectives before the nouns whose meaning theymodify). Also, much of our communication is about predictable, everyday things (consider how frequentlyyou engage in small talk).As an NLP task, language modeling easily checks the two critical boxes we discussed in section 2: data andevaluation. LMs need only text; every word in a large collection of text naturally comes with the precedingcontext of words. When we say“only text,”we mean specifically that we don't need any kind of label to gowith pieces of text (like the star ratings used in sentiment analysis tasks, or the human-written translationsused in translation tasks). The text itself is comprised of inputs and outputs. Because people produce textand share it in publicly visible forums all the time, the amount of text available (at least in principle, ignoringmatters of usage rights) is extremely large. The problem of fresh, previously unseen test data is also neatlysolved because new text is created every day, reflecting new events and conversations in the world that arereliably different from those that came before. There is also a relatively non-controversial evaluation of LMsthat requires no human expertise or labor, a more technical topic that we return to in section 3.4.

3.2 Why do we care about language modeling?We have thus far established what the language modeling task is. However, we haven't explained why thistask is worth working on. Why do we bother building a model that can predict the next word given thewords that have come before? If you already make use of auto-complete systems, you have an initial answerto this question. But there are more reasons.For many years, NLP researchers and practitioners believed that a good language model was useful only forestimating fluency. To illustrate this, imagine a language model faced with guessing possible continuations fora partial sentence like“The dog ate the ____”or“Later that afternoon, I went to a ____.”As Englishspeakers, we share a pretty strong sense that the following word is likely to be either a noun or part of adescriptor preceding a noun. Likewise, if we have a good language model for this type of English, that model

11

will have needed to implicitly learn those kinds of fluency-related rules to perform the language modelingtask well. This is why LMs have historically been incorporated as a component in larger NLP systems, suchas machine translation systems; by taking their predictions (at least partially) into account, the larger systemis more likely to produce more fluent output.In more recent years, our understanding of the value of LMs has evolved substantially.In addition topromoting fluency, a sufficiently powerful language model can implicitly learn a variety of world knowledge.Consider continuations to the following partial sentences:“The Declaration of Independence was signed bythe Second Continental Congress in the year ____,”or“When the boy received a birthday gift from hisfriends, he felt ____.”While there are any number of fluent continuations to those sentences—say,“1501”or“that the American Civil War broke out”for the first, or“angry”or“like going to sleep”for the second—youlikely thought of“1776”as the continuation for the first sentence and a word like“happy”or“excited”forthe second. Why? It is likely because you were engaging your knowledge of facts about history as well asyour common sense about how human beings react in certain situations. This implies that to produce thosecontinuations, an LM would need at least a rudimentary version of this information.To do a good job of guessing the continuations of text, past a certain point, an LM must haveabsorbed some additional kinds of information to progress beyond simple forms of fluency.NLP researchers got an early glimpse of this argument in Peters et al. (2018). This paper reported thatsystems that trained an LM first as an early stage of building systems for varied tasks, ranging fromdetermining the answer to a question based on a given paragraph to determining which earlier entity aparticular pronoun was referencing, far outperformed their analogous versions that weren't informed by anLM (as measured by task-specific definitions of quality). This finding led to widespread researcher acceptanceof the power of“pretraining”a model to perform language modeling and then“finetuning”it (using itspretrained parameters as a starting point) to perform a non-language-modeling task of interest, which alsogenerally improved end-task performance.It shouldn't be too surprising that LMs can perform well at filling in the blanks or answering questions whenthe correct answers are in the training data. For a new task, it seems that the more similar its inputs andoutputs are to examples in the pretraining data, the better the LM will perform on that task.

3.3 Data for language models: Some nuancesThere are two important caveats to our earlier claim that collecting data for a language model is“easy.”First,because there is a massive amount of text available on the internet which could be downloaded and used tobuild or evaluate LMs, at least for research purposes, a language model builder must decide which data toinclude or exclude. Typical sources of data include news articles, books, Wikipedia, and other web text thatis likely to be carefully edited to conform to professional writing conventions. Some LMs include more casualtext from social media websites or online forums, or more specialized language from scientific texts. Whileresearchers have generally considered training language models on publicly available text data to be coveredby fair use doctrine, the relationship between copyright protections and language model practices is not fullysettled; we discuss this further in section 6.2.1.A major decision is whether to filter texts to only certain languages.6 Depending on the community of usersone intends the LM to serve, it may be preferable to filter text on certain topics (e.g., erotica) or text likelyto contain offensive content or misinformation. Today's LM datasets are too large for a person to read in asingle lifetime, so automated tools are employed to curate data. The implications of these decisions are amajor topic for current research, and we return to them in section 4.4.1.The other caveat is a more technical one: what counts as a“word”? For languages with writing systems thatuse whitespace to separate words, like English, this is not a very interesting question. For writing systemswith less whitespace between words (e.g., Chinese characters), segmentation into words could be a matter ofchoosing an arbitrary convention to follow or of adopting one of many competing linguistic theories. Today,6The problem of assigning a language identifier to a text (e.g., is it English, Spanish, etc.?) constitutes another family ofNLP tasks. It's a useful exercise to consider how to select the set of language names to use as labels for language identification,e.g.,which dialects of a language are separate from each other and should receive different labels?

12

LMs are often built on text from more than one natural language as well as programming language code. Thedominant approach to defining where every word in the data starts and ends is to apply a fully automatedsolution to create a vocabulary (set of words the language model will recognize as such) that is extremelyrobust (i.e., it will always be able to break a text into words according to its definition of words). Theapproach (Sennrich, Haddow, and Birch 2016) can be summed up quite simply:

• Any single character is a word in the vocabulary. This means that the LM can handle any entirely new

sequence of characters by default by treating it as a sequence of single-character words.

• The most frequently occurring two-word sequence is added to the vocabulary as a new word. This rule

is applied repeatedly until a target vocabulary size is reached.

This data-driven approach to building a language modeling vocabulary is effective and ensures that commonwords in the LM's training data are added to its vocabulary. Other, rarer words will be represented as asequence of word pieces in the model's vocabulary (similarly to how you might sound out an unfamiliar wordand break it down into pieces you've seen before). However, note that a lot depends on the data throughthe calculation of what two-word sequence is most frequent in that data at each step. Unsurprisingly, if thedataset used to build the vocabulary includes little or no text from a language (or a sub-language), words inthat language will get“chopped up”into longer sequences of short vocabulary words (some a single character),which has been shown to affect how well the LM performs on text in that language.

3.4 Evaluating LMs: PerplexityWe mentioned earlier that the language modeling task has a straightforward evaluation method. At first, wemight think that a“good”language model has a low word error rate: when it guesses the next word in asequence, it should seldom predict the wrong word. (A“wrong word”here means anything other than theactual next word in the test data sequence.)7LMs have generally not used the error rate to evaluate LM quality for two reasons. First, applicationssometimes predict a few options for the next word; perhaps it's just as good to rank the correct next wordsecond or third as it is to rank it first. The error rate could be modified to count as mistakes only thecases where the correct word is ranked below that cutoff. But how long the list should be is a questionfor application designers and moves the task definition in a more specialized/concrete direction, perhapsunnecessarily. Second, at least earlier in the history of language modeling, most systems weren't good enoughat predicting the next word to have error rates that weren't extremely high. If all LMs achieve error ratesclose to one, the error rate measurement isn't very helpful for comparing them.The evaluation method that is typically used for LMs avoids both of these issues. This method is known asperplexity, and can be considered a measure of an LM's“surprise”as expressed through its outputs in nextword prediction. Perplexity manages to work around the problems we've described by taking advantage ofhow LMs decide on a next word in practice.When an LM produces a next word, that next word is in reality a somewhat processed version of that LM'sactual output. What the LM actually produces given some input text is a probability distribution over itsvocabulary for which word comes next. In other words, for every possible next word in its vocabulary, the LMgenerates a number between 0 and 1 representing its estimate of how likely that word is as the continuationfor the input text.8Rather than evaluating an LM based on however an application developer chooses to process those probabilitydistributions into next words (whether by sampling, or by choosing the word with the highest estimatedlikelihood, or something else), perplexity instead directly evaluates the probability distributions produced bythe LM. Given a test set of text, perplexity examines how high the LM's probabilities are for the true observednext words overall, averaged over each word in the text-in-progress. The higher that LM's average probabilityfor the true words is, the lower the LM's perplexity (corresponding to the LM being less“surprised”by the

7We give a formal mathematical definition of word error rate in the appendix.8Because this is a probability distribution, all those numbers must add up to 1, and in practice, LMs always set their

probabilities to numbers strictly greater than 0.

13

actual continuations of the text).9Like any evaluation method, perplexity depends heavily on the test data. In general, the more similar thetraining and test data, the lower we should expect the text data perplexity to be. And if we accidentallybreak the cardinal rule and test on data that was included in the training data, we should expect extremelylow perplexity (possibly approaching 1, which is the lowest possible value of perplexity, if the model werepowerful enough to memorize long sequences it has seen in training).Finally, it's worth considering when perplexity seems“too”low. The idea that there is some limit tothis predictability, that there is always some uncertainty about what the next word will be, is an old one(Shannon 1951), motivating much reflection on (1) how much uncertainty there actually is, and (2) whatvery low perplexity on language modeling implies. Some have even suggested that strong language modelingperformance is indicative of artificially intelligent behavior. (We return to this question in section 5.)

3.5 Building language modelsGiven the tools from section 2 and our presentation of the language modeling task, it's straightforward todescribe how today's best LMs are built:

1. Acquire a substantial amount of diverse training data (text), filtering to what you believe will be high

quality for your eventual application. Set aside some data as the test data.

2. Build a vocabulary from the training data.3. Train a model with learnable parameters to minimize perplexity on the training data using a variant of

stochastic gradient descent.

4. Evaluate the perplexity of the resulting language model on the test set. In general, it should be verypossible to evaluate the LM on another test set because (1) we can check that the new proposed testdata doesn't overlap with the training data, and (2) the vocabulary is designed to allow any new textto be broken into words.

The third step reveals another attractive property of perplexity: it can serve as a loss function because it isdifferentiable with respect to the model's parameters.10 Note the difference between training set perplexity(calculated using training data) and test set perplexity calculated in the last step.11The preceding process is how some well-known models, like GPT-2, GPT-3, and LLaMA, were built, andit's the first step to building more recent models like ChatGPT and GPT-4. These newer models have beenfurther trained on additional kinds of data (which is less“easy”to obtain than the text we use for next wordprediction). We return to this topic in section 4.3.4.

4 From LMs to large language models (LLMs)Everything we've described thus far has been established for over a decade, and some concepts much longer.Why have language models become a topic of mainstream public conversation only recently?Recall that a longstanding use of LMs was to estimate the fluency of a piece of text (3.2), especially to helptext-generating systems produce more fluent output. Only since around 2020 have LMs been producinghighly fluent output on their own, that is, without incorporating some other components. At this writing, youcould observe something like the text generation performance of older LMs by looking at the autocompletefunctions in messaging applications on smartphones. If you have one of these on hand, try starting a sentenceand then finishing the sentence by picking one of the most likely next words the autocomplete program

9For those interested, we walk through the mathematics underlying the definition of perplexity in the appendix.10In practice, the loss function is usually the logarithm of perplexity, a quantity known as cross-entropy.11One common question about language models is why they sometimes“hallucinate”information that isn't true. The factthat next word prediction is the training objective used for these models helps to explain this. The closest an LM comes toencoding a“fact”is through its parameters' encoding of which kinds of words tend to follow from a partially written sequence.Sometimes, the context an LM is prompted with is sufficient to surface facts from its training data. (Imagine our example fromearlier:“The Declaration of Independence was signed by the Second Continental Congress in the year ____.”If an LM fills inthe year“1776”after being given the rest of the sentence as context, that fact has been successfully surfaced.) Other times,however, it's not, and we just get a fluent-sounding next word prediction that's not actually true, or a“hallucination.”

14

suggests. You're likely to notice that while the short-term continuations to the sentence are reasonable,the text quickly devolves into moderately fluent incoherence, nothing like text produced by state-of-the-artweb-based products.Having established the foundations—the language modeling task and the basic strategy for building a languagemodel—we'll now consider the factors that have recently transformed the mostly academic language modelsof the last decade into the so-called large language models (LLMs) of today.

4.1 The move towards more dataThis is not a history book, but there is one obvious lesson to be learned from the history of NLP: moretraining data helps make higher quality models. One period of major changes in the field occurred in the late1980s and 1990s when three trends converged almost concurrently:

1. Increasingly large collections of naturalistic, digital text data became easier to access by growing

numbers of researchers thanks to the rise of the internet and the world-wide web.

2. Researchers shifted from defining rules for solving NLP tasks to using statistical methods that dependon data. This trend came about in part due to interaction with the speech processing community, whichbegan using data-driven methods even earlier.

3. Tasks, as we described them above, became more mature and standardized, allowing more rigorousexperimental comparisons among methods for building systems. This trend was driven in part bygovernment investment in advancing NLP technology, which in turn created pressure for quantitativemeasures of progress.

During the 1990s and 2000s, the speed of progress was higher for tasks where the amount of available trainingdata increased the fastest. Examples include topic classification and translation among English, French,German, and a few other languages. New tasks emerged for which data was easy to get, like sentimentanalysis for movies and products sold and reviewed online. Meanwhile, progress on tasks where data wasmore difficult to obtain (such as long text summarization, natural language interfaces to structured databases,or translation for language pairs with less available data) was slower. In particular, progress on NLP forEnglish tasks was faster than for other languages, especially those with relatively little available data.The recognition that more data tends to help make better systems generates a lot of enthusiasm, but wefeel obliged to offer three cautionary notes. First, easily available data for a task doesn't make that taskinherently worth working on. For example, it's very easy to collect news stories in English. Because thestyle of many English-language newspapers puts the most important information in the first paragraph,it's very easy to extract a decent short summary for each story, and we now have a substantial number ofdemonstrations for an English-language news summarizer. However, if readers of the news already know thatthe first paragraph of a news story is usually a summary, why build such a system? We should certainly notexpect a system built on news summarization task data to carry over well to tasks that require summarizingscientific papers, books, or laws.The second cautionary note is that the lack of easy data for a task doesn't mean the task isn't worth solving.Consider a relatively isolated community of people who have more recently gained access to the internet. Ifthey do not speak any of the dominant languages on the internet, they may be unable to make much useof that access. The relative absence of this community's language from the web is one reason that NLPtechnology will lag behind for them. This inequity is one of the drawbacks of data-driven NLP.The third cautionary note is that data isn't the only factor in advancing NLP capabilities. We alreadymentioned evaluation methods. But there are also algorithms and hardware, both of which have changedradically over the history of NLP. We won't go into great detail on these technical components here, but wenote that the suitability of an algorithm or a hardware choice for an NLP task depends heavily on the qualityand quantity of training data. People often use the term“scale”to talk about the challenges and opportunitiesassociated with very large training datasets. As early as 1993, researchers were claiming that“more datais always better data”(Church and Mercer 1993). We would add that which algorithms or computers arebetter for building a system that performs a task depends highly on the availability of appropriate data for

15

that task, whether high or low or in between. And indeed, as it turns out, the second factor we now mentionfalls into the category of a change in algorithm: a change in model architecture.

4.2 The architecture: TransformersNot long ago, students of NLP would be introduced to a wide range of different architectures. One wouldlikely hear about the relative merits of each and learn what particular kinds of problems it was well suited tosolve. From year to year, new ones would be added, sometimes replacing those no longer deemed optimal inany setting. Today, these diverse architectures have virtually all been replaced by a single architecture calledthe transformer, whimsically named after a brand of 1980s robot toys, proposed by Vaswani et al. (2017).The transformer, a type of neural network, was introduced by researchers at Google for machine translationtasks. Though we won't go into detail about how it works, its design was inspired by earlier developments inneural networks, and it was primarily optimized to allow the GPU-based simultaneous processing of all partsof even long input texts instead of word-by-word processing. Earlier architectures were largely abandoned12because they didn't effectively use GPUs and could not process large datasets as quickly.It didn't take long for researchers to realize that with the transformer would allow for training models morequickly and/or on more data, as well as training much larger models than other architectures ever allowed.By“larger models,”we mean models with more parameters. These three elements—larger datasets, fasterhardware, and larger models—all depend on each other. For example, a larger model could better encodepatterns in the training data, but without faster hardware, training such a model may be infeasible. And ifthe model is trained on an insufficient sample of data, it may not generalize well.13 Conversely, a substantialdataset may require a larger model (more parameters) to encode the larger set of discoverable patterns inthe data. Indeed, there is a fundamental tradeoff when selecting architectures: too few parameters, and thearchitecture will be limited in what input-output mappings it can learn, no matter how much training data isused. Too many parameters (i.e., too large a model), and the model might overfit.The simultaneous, rapid increase in datasets and parameter counts, aided by improved hardware, affectedcomputer vision before affecting NLP. In fact, the term“deep learning”was originally a reference to theselarger models (“deep”refers to models with increasing numbers of“layers”in the architecture, where layers areiterations of repeated calculations with different parameters at each round). The“deepening”of transformersapplied to the language modeling task led to what are now called“large language models.”“Large”usuallyrefers to the parameter count, but it could also refer to the size of the training dataset.The models in wide use for NLP today have billions of parameters; older generations of OpenAI modelsincreased from sizes of over a billion parameters with the largest version of GPT-2 to 175 billion parameterswith GPT-3. The main drawback is that running their training algorithms on large datasets requires verymany GPUs working in parallel for a long time, which in turn requires a lot of energy. From the perspectiveof improving the quality of generated text (in perplexity but also subjective human judgments), these LLMsrepresent a major advance.From a scientific perspective, it's difficult to assess which of these changes—data size, number of parameters,architecture, etc.—matter the most. Larger models are more data-hungry; over the last few years, modelshave gone from training on datasets with millions of words to trillions of words. While some work, such asthat by Hoffmann et al. (2022), tried to disentangle the impacts of model scale and data scale, the additionalinfluence of yet other factors (like hyperparameters on a training run) complicates efforts to confidently drawconclusions from such research. These experiments require the repeated training of models that are estimatedto cost millions of dollars apiece. In addition, it would take far too long to train fairly matched models basedon previously popular, pre-transformer architectures (i.e., with similar parameter counts on similar amountsof data to the strongest models of today); this means that it's impossible to measure how much benefit thetransformer offers other than allowing for larger models.

12They were not totally abandoned, however, and are still used occasionally when datasets are small.13At its extreme, this phenomenon, known as“overfitting,”leads to models that“memorize”what they see in the training

data but perform poorly on new data, e.g., the test data.

16

It's important to recognize that larger datasets and more powerful hardware were the driversfor the scaling up of language models to architectures with hundreds of billions of parameters(at this writing), and that the parameter count is only part of the explanation for theimpressive behaviors of these models.

4.3 Impacts of these changesWhat was the impact of LLMs? In short, they caused language modeling performance to improve dramatically.To see this qualitatively for yourself, try typing out the beginning of a sentence and instruct a languagemodel like ChatGPT to complete that sentence. Chances are, you will immediately see a sentence that readsmuch more naturally than you saw generated by a simpler autocomplete system at the beginning of thissection. Many people have shared this subjective experience of more fluent text generation, and it is backedup by quantitative evaluations like perplexity. However, if that were their only contribution, LLMs probablywouldn't have entered the public consciousness.

4.3.1 Many other tasks are now reduced to language modelingWe previously mentioned in section 3.2 that LMs could inform NLP systems designed for other tasks. LLMsare accelerating this trend. By formulating task instructions in natural language, perhaps also providingadditional specific examples of what it would look like to successfully perform the task (inputs and outputs),and then supplying that text as the context on which a LLM conditions when choosing next words ascontinuations, we see very reasonable outputs for a broad range of such tasks (e.g., generating summaries andanswering questions). As we discussed in section 3.2, many techniques built on the pretraining-finetuningapproach transferred strong language model performance to other tasks. But the extent to which LLMsbecame the full model pipeline, i.e., with no task-specific finetuning needed for particular tasks, was striking.14Importantly, remember that part of the definition of a task is an evaluation method; the striking observationis that, as language models achieve lower perplexity, they also achieve better performance on many othertasks' own evaluations.For example, we previously described translation between languages and sentiment analysis as two broadcategories of NLP applications. Today's LLMs can often perform those tasks given context instructionsand/or examples — i.e., they are“prompted”to do so. For example, consider a context like“Translatethis sentence into French: We'd like another bottle of wine.”If an LLM has seen enough text that includesrequests/responses, text in the relevant languages, and parallel examples, it could produce the translation.(Indeed, OpenAI's ChatGPT system gave us a fairly reasonable“Nous aimerions une autre bouteille de vin.”Similarly, the prompt“Is the sentiment toward the movie positive or negative? This film made me laugh, butonly because it was so poorly executed.”led ChatGPT to output that the sentiment was negative.)This ease of transferability has made it much simpler for a wider variety of people, including non-researchers,to explore NLP capabilities. Often, it is no longer necessary to collect training data and build a specializedmodel for a task. We can say what we want in natural language to prompt an LLM, and we will often getoutput close to what we intended. People, including experts and non-experts, are now using LLMs for manypurposes, including many not originally formalized as NLP tasks.

4.3.2 Black boxesModern transformers are considered to be“black boxes”with befuddling numbers of parameter-knobs to turn,and to our knowledge, no one has particularly useful intuition about how to set any particular knob. Thissituation seems daunting, like sitting in a cockpit with thousands of knobs and controls and being told to flythe plane with no training. Indeed, it's only because of the increasing computational power of commerciallyavailable computers that we can solve problems this way today, but this still leaves us without a sense of thekinds of information models have learned to leverage, or how.

14The idea of prompting a model with a small number of examples came to be known as“in-context learning.”Considerableeffort has gone into engineering prompts for better task performance and into finetuning LMs to follow instructions describingwidely varied tasks. Such instruction finetuning has become a widely used second stage of training for commercial LM products.Note that it requires a dataset of instructions paired with the desired response an LM should give to each.

17

Both the transformer architecture and the stochastic gradient descent method used to set its parametersare mystifying, at least at first. Below, we reflect on that and note important differences that make anarchitecture like the transformer more inscrutable.Stochastic gradient descent, the algorithm used to train transformers and other neural networks, has beenextensively studied and is very well understood for some kinds of problems. Picture a smooth bowl andimagine a marble placed anywhere in it. That marble will roll and eventually settle at the lowest point. Ifthe dish were sitting on a piece of graph paper (a two-dimensional plane), the coordinates of that lowestpoint are the values of our two parameters that minimize the loss function. Stochastic gradient descent is,roughly speaking, doing the work of gravity. The simple curve of the dish, with no bumps or cutouts orchips, corresponds to the property of convexity. Some machine learning problems correspond to a convex lossfunction, and theoretical proofs support the existence of the best parameter values, how close SGD gets tothem, and how fast. What remains surprising is that SGD works well in practice even when the loss functionis not convex (like the Cascades, discussed in section 2.3.2). But the mathematics underlying this algorithmare relatively mature.The transformer architecture, only a few years old at this writing, remains mysterious. Some researchers havesought to prove theorems about its limitations (i.e., input-output mappings it cannot represent under someconditions), and more have run experiments to try to characterize what it learns from data in practice. Moreresearch is clearly needed, both to improve our understanding of what we can expect from this architectureand to help define new architectures that work better or for which parameter setting is less computationallyexpensive.

4.3.3 Cost and complexity affect who can develop these models nowYet another effect of the move to LLMs has been that a much smaller set of organizations can afford toproduce such models. Since large, well-funded tech companies are (almost exclusively) well positioned to trainLLMs due to their access to both data and specialized hardware, these companies are the sources for almostall current LLMs. This poses a barrier to entry for many researchers at other institutions. Given the widearray of different communities that could benefit from using these models, the many different purposes theymight envision for these models, and the vast diversity of language varieties that they represent, determiningways to broaden participation in LLM development is an important emerging challenge.Furthermore, when models were smaller, the idea of“running out”of web text on the public internet seemedludicrous; now, that's a looming concern for LLM developers. As massive datasets play an increasingly largerole in model training, some large companies' access to their own massive proprietary data associated withplatforms they maintain may give them an advantage in their development of models of text.

4.3.4 Adapting LLMs for use as productsBecause of the capabilities of these new models, many developers seek to integrate them into a wide array ofproducts and services, from helping software engineers write code to helping lawyers write briefs. This echoesa longstanding practice of incorporating LMs into parts of standalone products with commercial purposes,such as guiding a translation system to produce more fluent text in the output language. As LLMs gainedbroader exposure (and, we conjecture, with increased internal testing at the companies where they werebuilt), it became clear that additional adjustments were needed before deploying these models in products.We relate some of the more concerning issues that emerge in LLM-generated text in section 5. For now,consider the concrete possibility that an LLM would generate text that is fluent, but impolite or even obscene.How can this be prevented? Enforcing conventions of social acceptability is a difficult problem that manyresearchers have tackled. Proposed methods can vary from post-processing outputs (e.g., to screen out outputsthat include certain dispreferred words) to reranking sampled outputs using an auxiliary model specificallytrained on curated data to exhibit politeness. It is difficult to“taskify”social acceptability because it iscontext-dependent and extremely subjective.The notion of“alignment,”often used today for this class of problems, was introduced by Norbert Wiener:“Ifwe use, to achieve our purposes, a mechanical agency with whose operation we cannot efficiently interfere. . .

18

then we had better be quite sure that the purpose put into the machine is the purpose which we really desire”(Wiener 1960). This idea comes through today in research on using machine learning to alter LM behaviorsdirectly.In practice, commercial models are further trained on tasks designed to encourage instruction following(section 4.3.1) and generating text that humans respond to favorably.15 It is complicated to determine whichbehaviors to encourage. In her 2023 keynote at the FAccT research conference, the social scientist AlondraNelson made the point that“civilizations, for eons, for millennia. . . choose your long time scale—have beenstruggling, fighting, arguing, debating over human values and principles”(Nelson 2023). In other words, notonly is it a difficult problem to determine how to shape models' outputs to reflect a given set of values, it'salso extremely complicated to determine which set of values to incorporate into that set. Therefore, we tendto view these last adjustments of an LLM's behavior as a kind of customization rather than as an intrinsicencoding of“human values”into the system. Just like training models, only a few companies are currentlyequipped to customize them at this writing.

4.3.5 Safeguards and mitigationBecause LLMs are trained on such a wide-variety of internet content, models can create outputs that containunsafe content. For example, a user may want to know how to create a bomb or have the model help themplan some other dangerous or illegal act. Leaving aside whether the models constitute“intelligence,”theinformation these models contain and how easily they present it to users can create substantial risk. Thecurrent method for attempting to solve this problem is establishing content safeguards, a major part ofadapting LLMs for use as products. Safeguards can take different forms, from tuning the model to avoidcertain topics to addressing the issue through post-processing, where output from the model is filtered. Thesesafeguards are part of the larger“alignment”process since they can also be used to help block hateful contentin addition to dangerous information.There are also less obvious cases where safeguards can be critical for user safety. For example, a modelshould not provide medical advice without at least suggesting that the user seek professional advice anddisclosing that it is not a doctor or that its output is not guaranteed to be consistent with the medicalcommunity's consensus. Another case is self-harm, where the behavior of LLMs has been likened to a mirror,e.g., encouraging behaviors reflected in user prompts.Though necessary, safeguards can also impact a model's utility depending on how they are implemented. Forexample, a model that is too strict may refuse to do something that isn't actually harmful, making it lessuseful. Therefore, there is a tension between cautiously avoiding liability for model developers and meetinguser expectations.

4.3.6 The evaluation crisisExcitement around LLMs often centers on the rate of progress: as the models get larger (or are trained onmore data), they seem to get increasingly accurate and fluent. As mentioned previously in section 2.1, NLPresearchers have long-standing, rigorous methods for measuring how well systems perform at various tasks.These have not been abandoned. Following the trend of adapting LLMs to almost every task NLP originallyset out to do, with relatively little transfer effort (section 4.3.1), researchers are now evaluating new models,adapted in new ways, on ever-growing suites of tasks drawn from the past few decades of empirical evaluationof NLP systems, as well as new ones coming into use. The general trend is that performance numbers areimproving.This is promising news insofar as these tasks accurately capture what people want to do with NLP technology.But we believe there are reasons to be skeptical. Since the deployment and widespread adoption of LLM-basedproducts, users have expressed enthusiastic interest in thousands of new use cases for LLMs that bear littleresemblance to the tasks that constitute our standard research evaluations, which has several importantimplications:

15One current example of a proposed method for doing this is“reinforcement learning from human feedback.”As its nameimplies, this method uses machine learning to turn discrete representations of human preferences, like“sampled output A ispreferable to sampled output B,”into a signal for how to adjust a model's parameters accordingly.

19

• The suite of tasks driving research evaluations needs thorough and ongoing reconsideration and updating

to focus on communities of actual users.

• Observations of how real users interact with an LLM, along with feedback on the quality of the LLM's

behavior, will be important for continuing to improve LLM quality.

• Because there is diversity in the communities of users, customization of models will become increasingly

important, making thorough evaluation increasingly multi-faceted and challenging.

• Reports of“progress”cannot be taken at face value; there are many different aspects to model quality.A single performance number (like perplexity on a test set or average performance on a suite of hundredsor thousands of tasks' specific evaluations) will not meaningfully convey the strengths and weaknessesof a system with such wide-ranging possible behaviors.

We believe that these challenges will inspire new collaborations between researchers and users to defineevaluations (and, by extension, models) that work as our needs and the realities of model building evolve..

4.4 Knowing the model means knowing its training dataModel capabilities depend directly on the specific data used to train them. The closer a string of text (say,the instructions provided to an LLM) is to the kind of data that the model was trained on (which, for currentmodels, is a large portion of the data on the internet), the better we expect that model to do in mimickingreasonable continuations of that“kind”of language.16 Conversely, the further the language of some text isfrom the model's training data, the less predictable the model's continuation of that text will be. (In section5.1, we discuss the implications for choosing which prompts to supply to a model.)You can test this out. Try instructing a model (for example, ChatGPT) to generate some text (a publicawareness statement, perhaps, or a plan for an advertising campaign) about a very specific item X gearedtowards a specific subpopulation Y, preferably with an X and Y that haven't famously been paired together.Grammatically, the answer returned is probably fine. However, if the content of the model's response seemsgeneric, that's not too surprising. The amount of text that models like ChatGPT are trained on that couldserve as a close example to a particular prompt is typically far greater than that which is relevant for preciseideas specific to whatever personal combination you thought up.If you speak a language besides English, you'll likely also notice a worse answer or a more stilted, generictone if you translate your question into that language and ask it again. And again, this is directly related tothe model's training data: however much text there is relevant to your issue or product on the internet inEnglish, there's likely less of it in your other language, meaning there was less available to use for training.

4.4.1 What does LLMs' training data contain?Characterizing a dataset on a trillions-of-words scale is tricky for a few reasons. First, reading throughthe corpus, or even a large enough sample to capture its diversity, would take too long. (A colleague ofours estimated thousands of years of reading without any breaks.) Published descriptions of datasets thathave been explored using automated tools focus on the top sources (e.g., web domains like Reddit.com orWikipedia.org) or coarse characterizations in terms of genre (e.g., patents, news); see Dodge et al. (2021)for an example. These characterizations, while convenient, show tremendous variation. We believe thatresearchers must do more work on developing methodologies and implementing tools for describing thatvariation.In many cases, though, information about the documents used to train an LLM is hidden. It's very commonfor companies that deploy these models to treat the data they used as a trade secret, saying little to nothingabout the data, making analysis impossible. However, a few model builders do share more information abouttheir training data, which helps researchers better understand how model behaviors, beneficial and otherwise,are shaped by certain kinds of text.

16Note that we are not implying that language models are only mimics; characterizing the precise ways in which they merely

copy vs. generalize is work still to be done.

20

Many researchers have one specific concern about hidden training datasets: Suppose a model is promptedwith a question that seems especially difficult to answer, and it answers accurately and clearly, like an expert.We should be impressed only if we are confident that the question and answer weren't in the training data. Ifwe can't inspect the training data, we can't be sure whether the model is really being tested fairly or if itmemorized the answer key before the test, like our student in section 2.2.

4.4.2 A cautionary note about data qualityIt's tempting to boil down negative consequences of including certain data during training (such as misin-formation or hate speech) to issues of“data quality”and advocate for“better”data using the“garbagein, garbage out”principle. Yet, seemingly reasonable steps often taken to automatically filter web text for“quality”can have the unintended effect of overrepresenting text that resembles writing more characteristic ofwealthier or more educated groups (Gururangan et al. 2022). Further, these filters' defined notion of qualitydoes not align with other manually determined aspects of text quality (such as winning a Pulitzer prize ortelling the truth).Determining what counts as“better”training data, and how that sense can be implemented at scale, isa subjective question of values and norms. For this reason, we predict and hope that future research willsupport better customization of language models' data to different user communities or applications ratherthan assuming a universal notion of“quality.”This contrasts with an assumption underlying much currentdiscussion about language models, that one large model will eventually be the best solution for everythingeveryone wants.

5 Practical points about using language modelsSo far we've talked about how language models came to be and what they are trained to do. If you're ahuman reading this guide, though, then you're likely also wondering about how good these models are atthings that you've thought up for them to do. (If you're a language model pretraining on this guide, carryon.)As we have learned in section 4.3.6, NLP researchers' tools for evaluating models test for different abilitiesthan those that interest many users of deployed products. Delineating what LMs can do, and how thesecapabilities relate to the choices made when they are constructed, deserves continued scientific exploration.However, early signs indicate that LMs can at least be helpful tools in speeding up many user tasks thatwere previously difficult to automate. So, if you're wondering whether these models can be helpful to you onsomething specific, say, planning a trip to Japan, it's worth giving them a try!This section answers general questions you may have when you're trying them out or thinking about what'sin store for them over the near term. We answer by distilling major conversations (now occurring in thescientific community studying language models) into practical takeaways you should be aware of and thereasoning behind these takeaways.

5.1 Is the specific wording of the“prompt”I supply to an LM important?In short, yes. Section 4.4 hinted at this, but to be more explicit: the specific wording of the prompt that yousupply to an LM significantly affects the model output that you receive. This likely means that you'll wantto experiment with a few different wordings for instructing the model to do something. When you prompt amodel, if your input and the correct output are close to sample text the model has encountered in its trainingdata, the model should“respond”(that is, continue the prompt by predicting a sequence of next words) well.Trying different prompt wording means that you're casting a wider net across patterns that the model haslearned about language and giving yourself a better chance of encountering one that the model has an easiertime continuing.To test this out, try rephrasing something you want an LM to do in a few very different ways. Then, trysupplying each of these prompts separately to a model like ChatGPT. Chances are that you see some notabledifferences in the different results that you get!

21

5.2 Do I always have to check and verify model output, or can I simply“trust”

the result?

At first glance, it might seem that a prompt that produces believable model output means there's nothingleft for you to do. However, you should never take model output at face value. Always check for the followingimportant issues.

5.2.1 Truthfulness vs.“hallucination”At the time of writing (and likely for the foreseeable future), LMs struggle with ‘telling the truth,' thatis, producing correct output.In fact, a much-discussed property of LMs is their tendency to produceinaccurate and nonfactual information. This phenomenon is known as“hallucination.”17 How muchhallucination matters greatly depends on the tasks and genres of language of the model's users. For acreative writer, a language model's flexibility in presenting fictional information may be one of its greateststrengths. For someone who needs an accurate summary of a medical article or who tries to use an LM toretrieve statements of fact from court testimony, it can render the model unusable, at least without carefulpost-prompt fact-checking.Why do models hallucinate? While models depend heavily on their training data, they do not access thatdata exactly. Instead, they seem to encode patterns in the data, but not to“remember”the data precisely allthe time. Thus, for topics with plenty of supporting data and a simple task, the likelihood of hallucinationis often lower. With more complex tasks on less-discussed subjects, hallucination is less surprising. Evenwhen there is plenty of data, if the training data included frequent statements of incorrect information (forexample, the incorrect but widely discussed claim that vaccines cause autism), the model may encode (as apattern) the incorrect claim. There is ongoing active research on discouraging models from stating incorrectinformation as well as steering them away from generating confident-sounding answers (or any answer at all)to questions where the facts may be under debate, but this is still a very difficult open problem.Relatedly, there is currently no straightforward, computationally feasible way to link specific predictions orgenerated text back to specific training documents or paragraphs. So, another ongoing research challenge isendowing LMs with the ability to“cite their sources,”that is, to not only generate explicit and accuratereferences to relevant literature or sources like scholars are taught to do, but to reveal the specific texts thatinfluenced a particular next word prediction, if requested.A notable real-life example of these missing capabilities surfaced when two US lawyers in early 2023 usedChatGPT to prepare the filing for a personal injury suit against an airline. While the main text was veryfluent, the model had completely hallucinated the cases it cited as precedents and their corresponding judges,plaintiffs, and defendants. This was brought to the court's attention when it received a brief from the airline'slawyers questioning the existence of the cited cases. These cases weren't real, and the lawyers had notdisclosed that they used ChatGPT for their legal research. The federal judge in the case was furious andfined both lawyers, who blamed ChatGPT during a subsequent hearing, stating they“did not understand itwas not a search engine, but a generative language-processing tool.”Now that LM hallucinations have found their way into the judicial system, we can hope that users (andmodel builders, the“deep pockets”in such cases) have learned a lesson. LMs are not search engines, andtheir output requires careful checking, at least at present.Remember: language models don't perfectly capture their training data!

5.2.2 Model outputs that reflect social biasesAnother aspect of evaluating and revising model outputs where human judgment is key is in checking formodels' unthinking mimicry of social biases that may have appeared in their training data.NLP researchers often refer to the names of the idealized tasks we've trained our models to perform—“hatespeech detection,”“machine translation,”“language modeling”—but remember that how a model learns to17Some have argued that the term“hallucination”is misleading and anthropomorphizes language models, but at this writing

it is the most widely used by NLP researchers.

22

perform a task is heavily influenced by the particular data used to train it. (This is related to our previousdiscussion in section 2.1 about the tradeoff between abstract, aspirational notions of a task and concrete,workable ones.) In practice, models for“hate speech detection”are actually trained to perform“hate speechdetection as exemplified in the HateXplain dataset”or“hate speech detection as exemplified in the IberEval2018 dataset.”These datasets reflect their builders' focus on particular type(s) of language—for example,Spanish-language news articles or American teenagers' social media posts—but no dataset perfectly representsthe type(s) of language it's meant to represent. There are simply too many possible utterances! Therefore,despite ongoing work trying to improve models' abilities to generalize from the data observed during training,it remains possible that a model will learn a version of the task that's informed by quirks of its training data.Because there are so many possible“quirks,”it's a safe bet that a model will have learned some of them.And in fact, we've observed this time and again in NLP systems.To be more specific, let's look at some past work that's found bias traceable to the training data within hatespeech detection systems. Sap et al. (2019) found that in two separate hate speech detection datasets, tweetswritten in African American Vernacular English (AAVE) were disproportionately more likely to be labeled astoxic than those written in white-aligned English by the humans employed to detect toxicity. Not only that,but models trained on those datasets were then more likely to mistakenly label innocuous AAVE language astoxic than they were to mistakenly flag innocuous tweets in white-aligned English. This gives us an ideaof how dataset bias can propagate to models in text classification systems, but what about in cases wheremodels generate text? If models aren't associating text with any human-assigned toxicity labels, how canthey demonstrate bias?As it turns out, evidence of bias is still visible even in cases where the model isn't generating a singlepredefined category for a piece of text. A famous early example of work showing this for Google Translatebased its study on a variety of occupations for which the US Bureau of Labor Statistics publishes genderratios (Prates, Avelar, and Lamb 2019). The authors evaluated machine translation systems that translatedto English from various languages that don't use gendered singular pronouns, constructing sentences suchas“[neutral pronoun] is an engineer”and translating them into English. They found that these systemsdemonstrated a preference for translating to“he”that often far exceeded the actual degree by which menoutnumbered women in an occupation in the US. This bias likely reflects an imbalance in the number oftraining sentences associating men and women with these different professions, indicating another way inwhich a skew in the training data for a task can influence a model.Imbalances like this are examples of those“quirks”we mentioned earlier, and they can be puzzling. Somequirks, like data containing far more mentions of male politicians than female politicians, seem to followfrom the prevalence of those two categories in the real world. Other quirks initially seem to defy commonsense: though black sheep are not prevalent in the world,“black sheep”get mentioned more often in Englishtext than other-colored sheep, perhaps because they're more surprising and worthy of mention (or perhapsbecause a common idiom,“the black sheep of the family,”uses the phrase).In the same way that biases can arise in machine translation systems, LMs can exhibit bias in generatingtext. While current LMs are trained on a large portion of the internet, text on the internet can still exhibitbiases that might be spurious and purely accidental, or that might be associated with all kinds of underlyingfactors: cultural, social, racial, age, gender, political, etc. Very quickly, the risks associated with deployingreal-world systems become apparent if these biases are not checked. Machine learning systems have alreadybeen deployed by private and government organizations to automate high-stakes decisions, like hiring anddetermining eligibility for parole, which have been shown to discriminate based on such factors (Raghavan etal. 2020; Nishi 2019).So how exactly can researchers prevent models from exhibiting these biases and having these effects? It'snot a solved problem yet, and some NLP researchers would argue that these technologies simply shouldn'tbe used for these types of systems, at least until there is a reliable solution. For LMs deployed for generaluse, research is ongoing into ways to make models less likely to exhibit certain known forms of bias (e.g., seesection 4.3.4). Progress on such research depends on iterative improvements to data and evaluations that letresearchers quantitatively and reproducibly measure the various forms of bias we want to remove.Remember: datasets and evaluations never perfectly capture the ideal task!

23

5.3 Are language models intelligent?The emergence of language model products has fueled many conversations, including some that questionwhether these models might represent a form of“intelligence.”In particular, some have questioned whetherwe have already begun to develop“artificial general intelligence”(AGI). This idea implies something muchbigger than an ability to do tasks with language. What do these discussions imply for potential users of thesemodels?We believe that these discussions are largely separate from practical concerns. Until now in this document,we've mostly chosen used the term“natural language processing”instead of“artificial intelligence.”In part,we have made this choice to scope discussion around technologies for language specifically. However, aslanguage model products are increasingly used in tandem with models of other kinds of data (e.g., images,programming language code, and more), and given access to external software systems (e.g., web search),it's becoming clear that language models are being used for more than just producing fluent text. In fact,much of the discussion about these systems tends to refer to them as examples of AI (or to refer to individualsystems as“AIs”).A difficulty with the term“AI”is its lack of a clear definition. Most uncontroversially, it functions as adescriptor of several different communities researching or developing systems that, in an unspecified sense,behave“intelligently.”Exactly what we consider intelligent behavior for a system shifts over time as societybecomes familiar with techniques. Early computers did arithmetic calculations faster than humans, but werethey“intelligent?”And the applications on“smart”phones (at their best) don't seem as“intelligent”topeople who grew up with those capabilities as they did to their first users.But there's a deeper problem with the term, which is the notion of“intelligence”itself. Are the capabilitiesof humans that we consider“intelligent”relevant to the capabilities of existing or hypothetical“AI”systems?The variation in human abilities and behaviors, often used to explain our notions of human intelligence, maybe quite different from the variation we see in machine intelligence. In her 2023 keynote at ACL (one of themain NLP research conferences), the psychologist Alison Gopnik noted that in cognitive science, it's widelyunderstood that“there's no such thing as general intelligence, natural or artificial,”but rather many differentcapabilities that cannot all be maximally attained by a single agent (Gopnik 2023).In that same keynote, Gopnik also mentioned that, in her framing,“cultural technologies”like languagemodels, writing, or libraries can be impactful for a society, but it's people's learned use of them that makethem impactful, not inherent“intelligence”of the technology itself. This distinction, we believe, echoes alongstanding debate in yet another computing research community, human-computer interaction. There,the debate is framed around the development of“intelligence augmentation”tools, which humans directlymanipulate and deeply understand, still taking complete responsibility for their own actions, vs. agents, towhich humans delegate tasks (Shneiderman and Maes 1997).Notwithstanding debates among scholars, some companies like OpenAI and Anthropic state that developingAGI is their ultimate goal. We recommend first that you recognize that“AGI”is not a well-defined scientificconcept; for example, there is no agreed-upon test for whether a system has attained AGI. The term shouldtherefore be understood as a marketing device, similar to saying that a detergent makes clothes smell“fresh”or that a car is“luxurious.”Second, we recommend that you assess more concrete claims about models'specific capabilities using the tools that NLP researchers have developed for this purpose. You should expectno product to“do anything you ask,”and the clear demonstration that it has one capability should neverbe taken as evidence that it has different or broader capabilities. Third, we emphasize that AGI is not theexplicit or implicit goal of all researchers or developers of AI systems. In fact, some are far more excitedabout tools that augment human abilities than about autonomous agents with abilities that can be comparedto those of humans.We close with an observation. Until the recent advent of tools marketed as“AI,”our experience withintelligence has been primarily with other humans, whose intelligence is a bundle of a wide range ofcapabilities we take for granted. Language models have, at the very least, linguistic fluency: the text theygenerate tends to follow naturally from their prompts, perhaps indistinguishably well from humans. But LMsdon't have the whole package of intelligence that we associate with humans. In language models, fluency,

24

for example, seems to have been separated from the rest of the intelligence bundle we find in each other.We should expect this phenomenon to be quite shocking because we haven't seen it before! And indeed,many of the heated debates around LMs and current AI systems more generally center on this“unbundled”intelligence. Are the systems intelligent? Are they more intelligent than humans? Are they intelligent in thesame ways as humans? If the behaviors are in some ways indistinguishable from human behaviors, does itmatter that they were obtained or are carried out differently than for humans?We suspect that these questions will keep philosophers busy for some time to come. For most of us who workdirectly with the models or use them in our daily lives, there are far more pressing questions to ask. Whatdo I want the language model to do? What do I not want it to do? How successful is it at doing what Iwant, and how readily can I discover when it fails or trespasses into proscribed behaviors? We hope that ourdiscussion helps you devise your own answers to these questions.Remember: analogies to human capabilities never perfectly capture the capabilities of languagemodels, and it's important to explicitly test a model for any specific capability that your usecase requires!

6 Where is the development of language models headed?Language models (and the role they play in society) are still in their infancy, and it's too early to say howthey will continue to develop and the main ways in which they will evolve over time. Currently, as we'vementioned, most language models (and generative AI models more generally) are developed by a handful ofcompanies that are not very forthcoming about their construction. However, it's important to remember that,depending on various factors over the next several years, a future of more decentralized models managed bynot-for-profit entities is still possible.One key variable that's still taking shape in determining this future is governed by democratic processes:government regulation, in the form of policy and law. This means that public attention (your attention) toissues around these models could directly influence what the future of the technology looks like. We nowdiscuss both the reasons for difficulties in predicting the future of language model development and the rolethat early regulation of these models has played so far.

6.1 Why is it difficult to make projections about the future of NLP technologies?For perspective, let's consider two past shifts in the field of NLP that happened over the last ten years.The first, in the early 2010s, was a shift from statistical methods—where each parameter fulfilled a specific,understandable (to experts) role in a probabilistic model—to neural networks, where blocks of parameterswithout a corresponding interpretation were learned via gradient descent. The second shift, around 2018–19,was the general adoption of the transformer architecture we described in section 4.2, which mostly replacedpast neural network architectures popular within NLP, and the rise of language model pretraining (as discussedin section 3.2).Most in the field didn't anticipate either of those changes, and both faced skepticism. In the 2000s, neuralnetworks were still largely an idea on the margins of NLP that hadn't yet demonstrated practical use;further, prior to the introduction of the transformer, another, very different structure of neural network18 wasubiquitous in NLP research, with relatively little discussion about replacing it. Indeed, for longtime observersof NLP, one of the few seeming certainties is of a significant shift in the field every few years—whether inthe form of problems studied, resources used, or strategies for developing models. The form this shift takesdoes not necessarily follow from the dominant themes of the field over the preceding years, making it more“revolutionary”than“evolutionary.”And, as more researchers are entering NLP and more diverse groupscollaborate to consider which methods or which applications to focus on next, predicting the direction ofthese changes becomes even more daunting.A similar difficulty applies when thinking about long-term real-world impacts of NLP technologies. Evensetting aside that we don't know how NLP technology will develop, determining how a particular technology

18It was called the LSTM,“long short-term memory”network.

25

will be used poses a difficult societal question. Furthermore, NLP systems are being far more widely deployedin commercial applications; this means that model developers are getting far more feedback about them froma wider range of users, but we don't yet know the effects that deployment and popular attention will have onthe field.Remembering how these models work at a fundamental level—using preceding context to predict the nexttext, word by word, based on what worked best to mimic demonstrations observed during training—andimagining the kinds of use cases that textual mimicry is best-suited towards will help us all stay groundedand make sense of new developments.

6.2 What might AI regulation look like?An important conversation about the future of language models centers around possible regulation of thesemodels. This topic encompasses many related discussions: companies' self-regulation, auditing of modelsby third parties, restrictions on data collection by private companies (such as those recently instituted byReddit), and potential government oversight. Given that companies producing these models must alreadymake decisions about how to adjust their models' behavior, it seems most realistic to consider not whetherregulation by some party will occur, but rather which forms of regulation would be beneficial. We will firstdescribe some early attempts at regulating AI and then hypothesize about what future regulations mightfocus on.Before doing that, we make one additional point. It's worth bearing in mind that calls in the public sphere foror against regulation can arise for a variety of different reasons. For example, as Kevin Roose recently wrotefor the New York Times,“some skeptics have suggested that A.I. labs are stoking fear out of self-interest, orhyping up A.I.'s destructive potential as a kind of backdoor marketing tactic for their own products. (Afterall, who wouldn't be tempted to use a chatbot so powerful that it might wipe out humanity?)”19 Past acertain point, discussion of AI regulation can become politically charged, drawing on many complicatedvariations of societal values. Therefore, similar to when participating in any public discussion, it's helpfulto get in the habit of thinking about why a specific person might be saying what they're saying given theirbackground and interests, as well as who they're hoping their comments will influence.

6.2.1 What versions of government AI regulation are emerging?In terms of concrete regulation that has made its way into the sphere of public policy, US President JoeBiden's Executive Order on AI and the European Union's 2023 AI Act represent the most sweeping regulatorymeasures relating to AI thus far.The Executive Order on AI, made at the end of October 2023, set out to establish general principles aroundAI innovation. These were high-level and focused primarily on the management of AI risk and security, thepromotion of responsible AI innovation and competition, and the protection of individuals and their civilliberties as AI continues to advance. An additional focus of the order is to garner AI talent in the UnitedStates and the US government. While these points are focused on the promotion of AI, the order also includesa threshold of required computing power where a model could be used in“malicious cyber-enabled activity.”That is, if a specific number of floating-point operations used in the training of a model is exceeded, thensome uses of that model might be considered a risk. This definition reflects the difficulty of translatingthe high-level concept of“model risk”into lower-level terms; it is quite possible that there will be furtheriterations of this definition in response to the continued advancement of computing capabilities.The focus of the EU AI Act is the determination of a risk level posed by different AI systems to humanindividuals based on proposed and likely use cases of those systems, for the purposes of identifying higher-risktechnologies and restricting their use. The details of the AI Act are also fairly high-level and ultimately mostof the act was effectively upended by the sudden widespread surge in use of ChatGPT. The AI Act was alodestone for political debates over the extent to which AI regulation should affect different systems, withpositions influenced by concerns as varied as fostering support for scientific innovation or upholding the rightsof those affected by model decisions. The upending of the EU AI Act shows that whatever future regulation

19See also this opinion article by Bruce Schneier and Nathan Sanders.

26

is released likely won't regulate for a certain point in time—as we are already seeing in some ways with theExecutive Order on AI. Any regulation that isn't focused on broader concepts like harm reduction and safeuse cases runs the risk of becoming quickly outdated, given the current (and likely future) pace of technologydevelopment.At a lower level closer to the implementation and training of AI systems, the legal focus so far has over-whelmingly been on copyrights associated with models' training data. A 2018 amendment to Japan's 1970Copyright Act gives generative AI models broad leeway to train on copyrighted materials provided that thetraining's“purpose is not to enjoy the ideas or sentiments expressed in the work for oneself or to have othersenjoy the work.”However, more recent court cases focused on generative image models, such as Getty Imagessuing Stability AI Inc. or a group of artists suing Stability AI, Midjourney, and DeviantArt, are pushingback on that view and have yet to reach a resolution.Even these early forays into the intersection of AI systems with copyright protection differ in their leanings,which shows how difficult it can be to legislate comprehensively on AI issues. (Indeed, there are alreadyfurther proposed amendments to Japan's Copyright Act that consider restricting the application of the 2018amendment.) To date, we haven't seen many court cases focused on generative models of text. Perhaps theclosest is a court case about computer programming language code, namely Doe 1 v. Github, Inc., whichfocuses on the fact that many public repositories of code on the GitHub website, from which training datahas been drawn, come with a license that was stripped from the data during training. Given that such courtcases focus on training data, one unanswered question is how such legal cases will affect companies' opennessabout their models' training data in the future. As we discussed, the more opaque the training data, the lesshope we have of understanding a model.

6.3 How can you contribute to a healthy AI landscape?There are a lot of important actions that help move us towards a future where AI systems are developed inbeneficial ways. We'll list a few here.

• If you're a student interested in AI systems: you can become one of the people helping to decidehow these models work. For anyone in this position, you'll find it useful to study computing, math,statistics, and also fields that reason about society. After all, the question of what we build thesesystems to do deserves just as much attention as the question of how we build these systems to do it.• If you're an expert in something other than AI (e.g., healthcare, a scientific or humanisticfield): the people building these models could really benefit from your expertise. Determining how toadapt AI systems to safely assist with problems faced by experts is not something computer scientistscan do alone. To make these kinds of models useful for you and your field (and to avoid trying to solveproblems that don't really need solving), model developers need your input and help. As more scientistsand engineers enter the growing AI field, it should become easier to find people in your network whoare working on the models. Engage with them!

• If you make decisions in a business sphere: you can set a high bar for evaluating possible AI-basedsystems in your company's workflow. There's considerable flashy language about some of these systems.By ignoring that and instead discussing with developers how a particular system was tested, how wellthat testing relates to your intended use case for it, and what's missing from those tests, you can helpraise overall standards for evaluating AI.

• If you're a concerned consumer: it's a huge help for you to assume a thoughtful, reflective distanceabout LMs and AI news. In recent months, there's been seemingly nonstop discussion of these topics,and there's sure to be a lot more coming. Our biggest goal for this document is that it will help toequip you with the knowledge you need to filter the hype and make sense of the substance.

7 Final remarksCurrent language models are downright perplexing. By keeping in mind the trends in the research communitiesthat produced them, though, we gain a sense of why these models behave as they do. Keeping in mind theprimary task that these models have been trained to accomplish, i.e., next word prediction, also helps us to understand how they work. Many open questions about these models remain, but we hope that we'veprovided some helpful guidance on how to use and assess them. Though determining how these technologieswill continue to develop is difficult, there are helpful actions that each of us can take to push that developmentin a positive direction. By broadening the number and type of people involved in decisions about modeldevelopment and engaging in broader conversations about the role of LMs and AI in society, we can all helpto shape AI systems into a positive force.

AcknowledgmentsThe authors appreciate feedback from Sandy Kaplan, Lauren Bricker, Nicole DeCario, and Cass Hodges atvarious stages of this project, which was supported in part by NSF grant 2113530. All opinions and errorsare the authors' alone.

GlossaryAlgorithm: A procedure that operates on a set of inputs in a predefined, precisely specified way to producea set of outputs. Algorithms can be translated into computer programs. This document references severaldifferent algorithms: (1) stochastic gradient descent, which takes as input a (neural network) modelarchitecture, a dataset, and other settings and produces as output a model; (2) a model itself, which takesas input specified text and produces an output for the task the model was trained to perform (for example, aprobability distribution over different kinds of attitudes being expressed for a sentiment classificationmodel, or a probability distribution over which word comes next for a language model); (3) an algorithmfor constructing a language model's vocabulary (section 3.3).Alignment (of a model to human preferences): This term can refer either to the degree to which a modelreflects human preferences, or to the process of adjusting a model to better reflect human preferences. Seesection 4.3.4.Architecture (of a model): The template for arranging a model's parameters and specifying how thoseparameters are jointly used (with an input) to produce the model's output. Note that specifying the modelarchitecture does not involve specifying the values of individual parameters, which are defined later. (Ifyou consider a model to be a“black box”with knobs on its side that is given an input and produces anoutput, the model's“architecture”refers to the arrangement of knobs on/inside the box without includingthe particular values to which each knob is set.)Artificial intelligence (AI): (1) Broadly describes several fields or research communities that focus onimproving machines' ability to process complicated sources of information about the world (like images ortext) into predictions, analyses, or other human-useful outputs. (2) Also refers in popular usage (but not thisguide) to an individual system (perhaps a model) built using techniques developed in those fields (such asDeep Blue or ChatGPT).Bleu scores: A fully automated way introduced by Papineni et al. (2002) to evaluate the quality of aproposed translation of text into a target language. At a high level, the Bleu score for a proposed translationof text (with respect to a set of approved reference translations for that same text) is calculated by lookingat which fraction of small chunks (e.g., one-word chunks, two-word chunks, etc.) of the proposed translationappear in at least one of the reference translations.Computer vision (CV): A subfield of computer science research that advances the automated processingand production of information from visual signals (images).Content safeguards: A term commonly used within NLP to refer to the strategies that are used to try tokeep language models from generating outputs that are offensive, harmful, dangerous, etc. We give someexamples of these strategies in section 4.3.5.Convergence: A concept in machine learning that explains when the loss between a model's output andexpected output from data is less than some threshold. Model convergence during training usually means that the model is no longer improving, such as occurs at the end of SGD.Data: The pairs of sample inputs and their desired outputs associated with a task, used to train or evaluatea model. For NLP, this is typically a massive collection of either text that originates in digital form (e.g.,text scraped from a post published to an internet forum) or text converted into a digital format (e.g., textextracted from a scanned handwritten document). It may also include additional information describing thetext, like sentiment labels for a sentiment analysis dataset.Data-driven: A description of a process indicating that it determines actions based on analysis of massivedata stores (in contrast to having a person or multiple people make all of these decisions). For example, aperson deciding on the vocabulary for a language model they're about to build could either (1) manuallydefine a list of all words or parts of words that the model's vocabulary would include (not data-driven) or (2)collect text data and run a data-driven algorithm (see section 3.3) to automatically produce a vocabularybased on that dataset for the eventual model. Machine learning algorithms are, in general, data-driven.Deep learning: A term that describes machine learning methods focused on training (neural network)models with many layers.Depth (of a model): Refers to the number of layers a neural network architecture contains.Domain (of data): A specific and intuitive (though not formally defined) grouping of specific data. Forexample, an NLP researcher might refer to“the Wikipedia domain”of text data, or“the business emaildomain”of text data. The term offers an expedient way for researchers or practitioners to refer to data thatgenerally has some unifying characteristics or characteristics different from some other data.Extrinsic evaluation (of a model): An evaluation (of a model) that evaluates whether using that model aspart of a larger system helps that system (and how much), or which considers factors related to the model'seventual use in practice, etc.Finetuning (of a model for a specific task): Continued training of a model on a new dataset of choice thatoccurs after original parameter values were trained on other tasks/datasets. Use of the term“finetuning”indicates that the model about to be finetuned has already been trained on some task/dataset.Function: Broadly, a mapping of inputs to outputs. In other words, a function takes as input any inputmatching a particular description (like“number”or“text”) and will give a (consistent) answer for what thatinput's corresponding output should be. However, everywhere we use the word“function”in this document(except in the context of“autocomplete functions”), we are referring more specifically to functions that takein a set of numbers and produce single-number outputs.Generative AI: A subset of artificial intelligence focused on models that learn to simulate (and cantherefore automatically produce/generate) complex forms of data, such as text or images.Gradient (of a function): A calculus concept. Given a particular point in an n-dimensional landscape,the gradient of a function indicates the direction (and magnitude) of that function's steepest ascent fromthat point. By considering the current parameters of a neural network model as the point in thatn-dimensional landscape, and taking the gradient of a loss function with respect to those parameters, it ispossible to determine a very small change to each parameter that increases the loss function as much aslocally possible. This also indicates that the opposite small change can decrease the loss function as much aslocally possible, the goal when running SGD.Hallucination (by a language model): A term commonly used to describe nonfactual or false statementsin outputs produced by a language model.Hardware: The (physical) machines on which algorithms are run. For contemporary NLP, these are typicallyGPUs (graphics processing units), which were initially designed to render computer graphics quickly but werelater used to to do the same for the kinds of matrix-based operations often performed by neural networks.Intrinsic evaluation (of a model): An evaluation (of a model) that evaluates that model on a specific testset“in a vacuum,”that is, without considering how plugging that model into a larger system would helpthat larger system.

Label: Some tasks have outputs that are a relatively small set of fixed categories (unlike language modeling,where the output is a token from some usually enormous vocabulary). In cases where outputs are decidedfrom that kind of small set, NLP researchers typically refer to the correct output for a particular input asthat input's“label”. For example, the set of labels for an email spam-identification task would be“spam”or“not spam,”and a sentiment analysis task might define its set of possible labels to be“positive,”“negative,”or“neutral.”Language model: A model that takes text as input and produces a probability distribution over whichword in its vocabulary might come next. See section 3.Layer (of a neural-network-based model): A submodule with learnable parameters of a neural networkthat takes as input a numerical representation of data and outputs a numerical representation of data. Modernneural networks tend to be deep, meaning that they“stack”many layers so that the output from one layeris fed to another, whose output is then fed to another, and so on.Loss function: A mathematical function that takes in a model's proposed output given a particular inputand compares it to (at least) one reference output for what the output is supposed to be. Based on howsimilar the reference output is to the model's proposed output, the loss function will return a single number,called a“loss.”The higher the loss, the less similar the model's proposed output is to the reference output.Machine learning (ML): An area of computer science focused on algorithms that learn how to (ap-proximately) solve a problem from data, i.e., to use data to create other algorithms (models) that aredeployable on new, previously unseen data.Mappings (of input to output): A pairing of each (unique) possible input to a (not necessarily unique)output, with the mapping“translating”any input it is given to its paired output.Model: An algorithm for performing a particular task. (NLP researchers typically refer to such analgorithm as a model only if its corresponding task is sufficiently complicated to lack any provably correct,computationally feasible way for a machine to perform it. Hence, we apply machine learning to build amodel to approximate the task.) Though a model that performs a particular task does not necessarily haveto take the form of a neural network (e.g., it could instead take the form of a list of human-written rules),in practice, current NLP models almost all take the form of neural networks.Natural language processing (NLP): A subfield of computer science that advances the study andimplementation of automated processing and generation of information from text and, perhaps, otherlanguage data like speech or video of signed languages.Neural network: A category of model architecture widely used in machine learning that is subdif-ferentiable and contains many parameters, making it well-suited to being trained using some variant ofstochastic gradient descent. Neural networks use a series of calculations performed in sequence by denselyconnected layers (loosely inspired by the human brain) to produce their output.(Numerical) optimization: Can refer to (1) a family of strategies for choosing the best values for apredetermined set of parameters, given a particular quantity to minimize/maximize which is calculatedbased on those parameters (and often some data as well) or to (2) the field of research that studies thesestrategies. In this document we refer exclusively to the first definition.Overfitting: When a model learns patterns that are overly specific to its training data and that do notgeneralize well to new data outside of that training set. This problem is typically characterized by the model'svery strong task performance on the training data itself but far worse performance when given previouslyunseen data.Parallel text: A term used within NLP to refer to pairs of text (usually pairs of sentences) in two languagesthat are translations of each other. Parallel text is widely used for the development of NLP models thatperform the task (commonly called“machine translation”) of translating text from a specific source language(e.g., Urdu) into a specific target language (e.g., Thai). Some pairs of languages have much more (digital)parallel text available, and the difference in the quality of machine translation systems across differentlanguage pairs reflects that disparity.

Parameter (in a neural network model): A single value (model coefficient) that is part of the mathematicalfunction that neural networks define to perform their operations. If we consider a model as being a blackbox that performs some task, a parameter is a single one of that black box's knobs.“Parameter”can refereither to the knob itself or the value the knob is set to, depending on context.Perplexity: A number from 1 to infinity that represents how“surprised”a language model generally is tosee the actual continuations of fragments of text. The lower the perplexity, the better the language model canpredict the actual continuations of those text fragments in the evaluation data. Perplexity is an importantintrinsic evaluation for language models.Probability distribution: A collection of numbers (not necessarily unique) that are all at least 0 and addup to 1 (for example, 0.2, 0.2, 0.1, and 0.5), each paired with some possible event; the events are mutuallyexclusive. For one such event, its number is interpreted as the chance that the event will occur. For example,if a language model with a tiny vocabulary consisting of only [apple, banana, orange] takes as inputthe sentence-in-progress“banana banana banana banana”and produces a probability distribution over itsvocabulary of 0.1 for“apple,”0.6 for“banana,”and 0.3 for“orange,”this means that the model is predictingthat the next word to appear after the given sentence-in-progress has a 60% chance of being“banana.”Prompt (to a language model): The text provided by a user to the language model, which the modelthen uses as its context—i.e., as its initial basis for its next word prediction that it performs over and overagain to produce its output, word by word.Sentiment analysis: A task in NLP that aims to determine whether the overall sentiment of a piece oftext skews positive, negative, or in some versions of the task, neutral. For example, suppose that a sentimentanalysis model was given the input“Wow, that movie was amazing!”The correct output for the model giventhat input would be“positive”(or five stars, or 10/10, or something similar if the labels were in the form ofstars or integer scores from 0 to 10 instead).Stochastic gradient descent (SGD): A process by which parameters of a model are adjusted to minimizesome specific function (e.g., a loss function). SGD requires repeatedly running varying batches of datathrough the model, whose output can then be used to get a value from our (loss) function. For each batch,we then use the gradient of that function to adjust the parameters of our model to take a tiny descendingstep along that gradient. This process is repeated until the loss function's gradient flattens out and stopsindicating a lower direction.Task: A job we want a model to do. Tasks are usually described abstractly—for example, sentiment analysis,question answering, or machine translation—in a way that is not tied to any one source of data. However, inpractice, if a model is trained to perform a particular task, the version of that task that the model learns toperform will be heavily influenced by the specific training data used. See section 5.2.2.Test set (or test data): A set of data unseen by a model during its training, used to evaluate how wellthe model works.Token: The base unit of language into which an NLP model splits any text input. For contemporarylanguage models, a token can be either a word or a piece of a word. A text input passed to such a modelwill be split into its component words (in cases where that word is part of the model's vocabulary) and wordpieces (in cases where that full word doesn't exist in the model's vocabulary, so its component pieces areadded to the sequence of tokens instead).Training set (or training data): A set of data used to train a model (in other words, to decide thatmodel's parameter values). For a model that takes the form of a neural network, the training set comprisesthe batches of data used while running stochastic gradient descent.Transformer: A kind of neural network architecture introduced in 2017 that allows large models builtusing it to train faster than earlier model architectures would have allowed, and on more data (assumingaccess to certain relatively high-memory hardware). They do this by using techniques (e.g., self-attention)beyond the scope of this work. See section 4.2.




### References

Church, Kenneth W., and Robert L. Mercer. 1993.“Introduction to the Special Issue on ComputationalLinguistics Using Large Corpora.”Computational Linguistics 19 (1): 1–24. https://aclanthology.org/J93-1001.

Dodge, Jesse, Maarten Sap, Ana Marasović, William Agnew, Gabriel Ilharco, Dirk Groeneveld, MargaretMitchell, and Matt Gardner. 2021.“Documenting Large Webtext Corpora: A Case Study on the ColossalClean Crawled Corpus.”In Proceedings of the 2021 Conference on Empirical Methods in Natural LanguageProcessing, 1286–1305. Online; Punta Cana, Dominican Republic: Association for ComputationalLinguistics. https://doi.org/10.18653/v1/2021.emnlp-main.98.

Gopnik, Alison. 2023.“Large Language Models as Cultural Technologies.”Presented at the 61st Annual

Meeting of the Association for Computational Linguistics.

Gururangan, Suchin, Dallas Card, Sarah Dreier, Emily Gade, Leroy Wang, Zeyu Wang, Luke Zettlemoyer,and Noah A. Smith. 2022.“Whose Language Counts as High Quality? Measuring Language Ideologies inText Data Selection.”In Proceedings of the 2022 Conference on Empirical Methods in Natural LanguageProcessing, 2562–80. Abu Dhabi, United Arab Emirates: Association for Computational Linguistics.https://aclanthology.org/2022.emnlp-main.165.

Hoffmann, Jordan, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford,Diego de Las Casas, et al. 2022.“An Empirical Analysis of Compute-Optimal Large Language ModelTraining.”In Advances in Neural Information Processing Systems, edited by S. Koyejo, S. Mohamed, A.Agarwal, D. Belgrave, K. Cho, and A. Oh, 35:30016–30. Curran Associates, Inc. https://proceedings.neurips.cc/paper_files/paper/2022/file/c1e2faff6f588870935f114ebe04a3e5-Paper-Conference.pdf.

Nelson, Alondra. 2023.“Thick Alignment.”Presented at the 2023 ACM Conference on Fairness, Accountability, and Transparency (ACM FAccT). https://youtu.be/Sq_XwqVTqvQ?t=957.

Nishi, Andrea. 2019.“Privatizing Sentencing: A Delegation Framework for Recidivism Risk Assessment.”Columbia Law Review 119 (6): 1671–1710. https://columbialawreview.org/content/privatizing-sentencing-a-delegation-framework-for-recidivism-risk-assessment/.

Papineni, Kishore, Salim Roukos, Todd Ward, and Wei-Jing Zhu. 2002.“Bleu: A Method for AutomaticEvaluation of Machine Translation.”In Proceedings of the 40th Annual Meeting of the Association forComputational Linguistics, 311–18. Philadelphia, Pennsylvania, USA: Association for ComputationalLinguistics. https://doi.org/10.3115/1073083.1073135.

Peters, Matthew E., Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and LukeZettlemoyer. 2018.“Deep Contextualized Word Representations.”In Proceedings of the 2018 Conferenceof the North American Chapter of the Association for Computational Linguistics: Human LanguageTechnologies, Volume 1 (Long Papers), 2227–37. New Orleans, Louisiana: Association for ComputationalLinguistics. https://doi.org/10.18653/v1/N18-1202.

Prates, Marcelo O. R., Pedro H. Avelar, and Luís C. Lamb. 2019.“Assessing Gender Bias in MachineTranslation: A Case Study with Google Translate.”Neural Computing and Applications 32 (10): 6363–81.https://doi.org/10.1007/s00521-019-04144-6.

Raghavan, Manish, Solon Barocas, Jon Kleinberg, and Karen Levy. 2020.“Mitigating Bias in AlgorithmicHiring: Evaluating Claims and Practices.”In Proceedings of the 2020 Conference on Fairness, Account-ability, and Transparency, 469–81. FAT* '20. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/3351095.3372828.

Sap, Maarten, Dallas Card, Saadia Gabriel, Yejin Choi, and Noah A. Smith. 2019.“The Risk of RacialBias in Hate Speech Detection.”In Proceedings of the 57th Annual Meeting of the Association forComputational Linguistics, 1668–78. Florence, Italy: Association for Computational Linguistics. https://doi.org/10.18653/v1/P19-1163.

Sennrich, Rico, Barry Haddow, and Alexandra Birch. 2016.“Neural Machine Translation of Rare Wordswith Subword Units.”In Proceedings of the 54th Annual Meeting of the Association for ComputationalLinguistics (Volume 1: Long Papers), 1715–25. Berlin, Germany: Association for ComputationalLinguistics. https://doi.org/10.18653/v1/P16-1162.

Shannon, C. E. 1951.“Prediction and Entropy of Printed English.”The Bell System Technical Journal 30

(1): 50–64. https://doi.org/10.1002/j.1538-7305.1951.tb01366.x.

Shneiderman, Ben, and Pattie Maes. 1997.“Direct Manipulation Vs. Interface Agents.”Interactions 4 (6): 42–61. https://doi.org/10.1145/267505.267514.

Vaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser,and Illia Polosukhin. 2017.“Attention Is All You Need.”In Advances in Neural Information ProcessingSystems, edited by I. Guyon, U. Von Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R.Garnett. Vol. 30. Curran Associates, Inc. https://proceedings.neurips.cc/paper_files/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf.

Wiener, Norbert. 1960.“Some Moral and Technical Consequences of Automation.”Science 131 (3410): 1355–58. http://www.jstor.org/stable/1705998.

AppendixLoss functions and gradient descent, a bit more formallyThe first important property for a loss function is that it takes into account all the potential good and badthings about outputs when deducting points. The more dissimilar our model's output given a particular inputis from that input's correct output, the higher the loss function should be. The second important propertyis that we must be able to deduce, fully automatically and in parallel for all parameters, what adjustmentswould make the loss function decrease. You may recall from a course on calculus that questions like“Howdoes a small change to an input to a function affect the function's output?”are related to the concept ofdifferentiation. In sum, we need the loss function to be differentiable with respect to the parameters. (Thismay be a bit confusing because in calculus, we think about differentiating a function with respect to itsinputs. In a mathematical sense, the input is only part of the input to the mathematical function encoded bya neural network; the parameters are also part of its input.) If the loss function has this property, then wecan use differentiation to automatically calculate a small change for each parameter that should decrease theloss on a given example.These two properties—faithfulness to the desired evaluation and differentiability with respect to parame-ters—conflict because most evaluation scores aren't differentiable. Bleu scores for translation and error ratesfor sentiment analysis are stepwise functions (“piecewise constant”in mathematical terms): changing theparameters a tiny bit usually won't affect these evaluation scores; when it does, it could be a dramatic change.Human judgments also are not differentiable with respect to parameters.Once we know a differentiable loss function, and with a few additional assumptions, we quickly arrive at thealgorithm for stochastic gradient descent (SGD), for setting system parameters. To describe its steps a bitmore formally than we did in section 2.3.2:

1. Initialize the parameters randomly.2. Take a random sample of the training data (typically 100 to 1000 demonstrations); run each inputthrough the system and calculate the loss and its first derivative with respect to every parameter.(When first derivatives are stacked into a vector, it's called the gradient.) Keep a running total of thesum of loss values and a running total of the sum of gradients.

3. For each parameter, change its value proportional to the corresponding value in the gradient vector. (If the gradient is zero, don't change that parameter.)

4. Go to step 2 if the loss is converging.

Word error rate, more formallyGiven some test data (some text the language model wasn't trained on), we can calculate the error rate asfollows. Let the words in the test data be denoted by w1, w2, ... , wN.

1. Set m = 0; this is the count of mistakes.2. For every word wi in the test data (i is its position):

1. Feed wi's preceding context, which after the first few words will be the sequence w1, w2, ... , wi−1, into the language model as input.

2. Let the language model predict the next word; call its prediction wpred.3. If wpred is anything other than wi, the language model made an incorrect prediction, so add 1 to m.

3. The error rate is m/N.

Perplexity, more formallySection 3.4 describes underlying properties of how LMs make“decisions”about next words. Here, to preparefor a deeper dive into perplexity, we summarize and build on those properties:

• Based on the context of preceding words, a calculation is made by the neural network that assigns aprobability to every word in the vocabulary, that is, every possible choice of what word could come next.These probabilities must always sum to one (that's part of the definition of a probability distribution),and we also impose a“no zeros”rule: the probability of every vocabulary word must always be atleast slightly positive.

• To predict the next word, the model can either (a) choose the one with the highest probability (asassumed in the error rate calculation above) or (b) simulate a draw from the probability distribution,choosing a word at random such that each word's chance of being drawn is given by its probability.To illustrate, imagine a pub trivia team where individual members have different past success rates ofbeing correct. Approach (a) would correspond to the team always submitting the answer proposed bythe trivia-whiz team member whose suggested answers had most often been correct before. Approach(b) would correspond to randomly picking who should answer, with the trivia whiz's answer being mostlikely to be chosen, the second-best team member's answer next most likely, then the third-best teammember's answer, and so on. Note that the most likely outcome from (b) is the same as the outcomefrom (a), but (b) will sometimes lead to another, lower-probability word.

Whether (a), (b), or some other approach is used when an LM is deployed is an important design decision. Inkeeping with our earlier rejection of error rate, researchers try to avoid evaluating LMs in a way that makesunnecessary commitments to its eventual use.20 Option (b) is interesting because it suggests a workaroundto the pitfalls of simply counting mistakes discussed in section 3.4.In the preceding appendix subsection's error rate calculation procedure, we could apply option (b) in step 2.2.Suppose we do this not once, but many times for each context/word pair and average the error rate acrossthese random draws. With enough draws, this approach would provide meaningful error rates because we'dexpect to get each word right some of the time (no zeros rule). In practice, rather than actually carrying outthe random draws, we instead use the LM's probabilities directly to assign a score for every word in the testdata. The results of this approach are that:

• If the language model gave probability 1 to the correct next word, the score for that word would be 1.This can't happen exactly because the probabilities of all the wrong words have to exceed zero (nozeros rule). But we can get arbitrarily close in principle if the probabilities of all the wrong words getinfinitesimally small.

• If the LM gave probability 0 to the correct next word, the score for that word would be 0. But this

can't happen either because of the no zeros rule.

• In general, the greater the probability the LM assigns to the correct next word, even if it's not the most

probable word, the higher the score.

Because of the no zeros rule, the per-word probability scores are always somewhere between 0 and 1.Given the test data, we can calculate the LM probability for every word given its preceding context. If wetook a simple average of these probability scores and subtracted that from 1, we would get something like anerror rate (technically, an“expected”error rate under prediction method (b)). What is done in practice is20The technical term for our desired evaluation is“intrinsic”evaluation, meaning that we want a measure of the intrinsic

quality of a model, not its performance in some extrinsic setting.

similar in spirit but slightly different: we take the geometric average of the inverses of these probability scores,a value known as (test data) perplexity. The reasons are partly practical (tiny numbers can lead to a problemin numerical calculations, called underflow), partly theoretical, and partly historical. For completeness, here'sthe procedure:

1. Set m = 0. (This quantity is no longer a running tally of mistakes.)2. For every word wi in the test data (i is its position):

1. Feed wi's preceding context, which after the first few words will be the sequence w1, w2, ... , wi−1,

into the language model as input.

2. Let p be the probability that the language model assigns to wi (the correct next word).3. Add − log(p) to m.

3. The perplexity is exp(m/N).

Though it's probably not very intuitive from the preceding procedure, perplexity does have some nice intuitiveproperties:

• If our model perfectly predicted every word in the test data with probability 1, we would get a perplexityof 1.21 This can't happen because (1) there is some fundamental amount of uncertainty in fresh, unseentext data, and (2) some probability mass is reserved for every wrong word, too (no zeros rule). Ifperplexity comes very close to 1, the cardinal rule that test data must not be used for anything otherthan the final test, like training, should be carefully verified.

• If our model ever assigned a probability of 0 to some word in the test data, perplexity would go to

infinity.22 This won't happen because of the no zeros rule.

• Lower perplexity is better.• The perplexity can be interpreted as an average“branch factor”; in a typical next word prediction

instance, how many vocabulary words are“effectively”being considered?

21 To see this, note that − log(1) = 0, so m stays 0 throughout step 2. Note that exp(0/N) = exp(0) = 1.22To see this, note that log(0) tends toward infinity.