## 20231209åäºŒç§è°ƒæ•´ç­–ç•¥æŒ‡å—

[A Guide on 12 Tuning Strategies for Production-Ready RAG Applications | by Leonie Monigatti | Dec, 2023 | Towards Data Science](https://towardsdatascience.com/a-guide-on-12-tuning-strategies-for-production-ready-rag-applications-7ca646833439)

[12 ç§è°ƒæ•´ç­–ç•¥æŒ‡å—ï¼šä¸ºç”Ÿäº§ç¯å¢ƒæ‰“é€ é«˜æ•ˆçš„ RAG åº”ç”¨ [è¯‘] | å®ç‰çš„åˆ†äº«](https://baoyu.io/translations/rag/a-guide-on-12-tuning-strategies-for-production-ready-rag-applications)

A Guide on 12 Tuning Strategies for Production-Ready RAG Applications

How to improve the performance of your Retrieval-Augmented Generation (RAG) pipeline with these "hyperparameters" and tuning strategies

Leonie Monigatti

Fig: Tuning Strategies for Retrieval-Augmented Generation Applications

Data Science is an experimental science. It starts with theã€ŒNo Free Lunch Theorem,ã€which states that there is no one-size-fits-all algorithm that works best for every problem. And it results in data scientists using experiment tracking systems to help them tune the hyperparameters of their Machine Learning (ML) projects to achieve the best performance.

This article looks at a Retrieval-Augmented Generation (RAG) pipeline through the eyes of a data scientist. It discusses potential "hyperparameters" you can experiment with to improve your RAG pipeline's performance. Similar to experimentation in Deep Learning, where, e.g., data augmentation techniques are not a hyperparameter but a knob you can tune and experiment with, this article will also cover different strategies you can apply, which are not per se hyperparameters.

[Intro to MLOps: Experiment Tracking for Machine Learning | by Leonie Monigatti | Medium](https://medium.com/@iamleonie/intro-to-mlops-experiment-tracking-for-machine-learning-858e432bd133)

[Retrieval-Augmented Generation (RAG): From Theory to LangChain Implementation | by Leonie Monigatti | Nov, 2023 | Towards Data Science](https://towardsdatascience.com/retrieval-augmented-generation-rag-from-theory-to-langchain-implementation-4e9bd5f6a4f2)

12 ç§è°ƒæ•´ç­–ç•¥æŒ‡å—ï¼šä¸ºç”Ÿäº§ç¯å¢ƒæ‰“é€ é«˜æ•ˆçš„ RAG åº”ç”¨ [è¯‘]

å¦‚ä½•é€šè¿‡è¿™äº›ã€Œè¶…å‚æ•°ã€å’Œè°ƒæ•´ç­–ç•¥ä¼˜åŒ–ä½ çš„æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰æµç¨‹

Leonie Monigatti

Published on December 7, 2023

é’ˆå¯¹æ£€ç´¢å¢å¼ºç”Ÿæˆåº”ç”¨çš„è°ƒæ•´ç­–ç•¥

æ•°æ®ç§‘å­¦æœ¬è´¨ä¸Šæ˜¯ä¸€é—¨å®éªŒæ€§ç§‘å­¦ã€‚ä»ã€Œæ²¡æœ‰å…è´¹åˆé¤å®šç†ã€å‡ºå‘ï¼Œè¿™ä¸ªå®šç†é˜è¿°äº†æ²¡æœ‰ä¸‡èƒ½çš„ç®—æ³•èƒ½å¤Ÿè§£å†³æ‰€æœ‰é—®é¢˜ã€‚å› æ­¤ï¼Œæ•°æ®ç§‘å­¦å®¶ä»¬ç»å¸¸åˆ©ç”¨å®éªŒè·Ÿè¸ªç³»ç»Ÿæ¥è°ƒæ•´ä»–ä»¬æœºå™¨å­¦ä¹  (ML) é¡¹ç›®çš„è¶…å‚æ•°ï¼Œä»¥è¿½æ±‚æœ€ä¼˜çš„æ€§èƒ½è¡¨ç°ã€‚

æœ¬æ–‡ä»¥æ•°æ®ç§‘å­¦å®¶çš„è§†è§’æ·±å…¥æ¢è®¨äº†æ£€ç´¢å¢å¼ºç”Ÿæˆ (RAG) æµç¨‹ã€‚æ–‡ä¸­å°†è®¨è®ºä¸€ç³»åˆ—å¯èƒ½çš„ã€Œè¶…å‚æ•°ã€ï¼Œé€šè¿‡è¿™äº›å‚æ•°çš„è°ƒæ•´ï¼Œå¯ä»¥æœ‰æ•ˆæå‡ RAG æµç¨‹çš„è¡¨ç°ã€‚ç±»ä¼¼äºæ·±åº¦å­¦ä¹ ä¸­çš„å®éªŒæ‰‹æ®µï¼Œä¾‹å¦‚æ•°æ®å¢å¼ºæŠ€æœ¯ï¼Œå¹¶ä¸ç›´æ¥æ˜¯è¶…å‚æ•°ï¼Œè€Œæ˜¯ä¸€ä¸ªå¯è°ƒæ•´å’Œå®éªŒçš„å…³é”®å› ç´ ï¼Œæœ¬æ–‡ä¹Ÿä¼šä»‹ç»å¯ä»¥åº”ç”¨çš„ä¸åŒç­–ç•¥ï¼Œè¿™äº›ç­–ç•¥æœ¬èº«å¹¶ä¸æ˜¯ç›´æ¥çš„è¶…å‚æ•°ã€‚

This article covers the following "hyperparameters" sorted by their relevant stage. In the ingestion stage of a RAG pipeline, you can achieve performance improvements by:

Data cleaning

Chunking

Embedding models

Metadata

Multi-indexing

Indexing algorithms

And in the inferencing stage (retrieval and generation), you can tune:

Query transformations

Retrieval parameters

Advanced retrieval strategies

Re-ranking models

LLMs

Prompt engineering

Note that this article covers text-use cases of RAG. For multimodal RAG applications, different considerations may apply.

æ–‡ç« å›´ç»•ä»¥ä¸‹æŒ‰å…¶åº”ç”¨é˜¶æ®µåˆ†ç±»çš„ã€Œè¶…å‚æ•°ã€å±•å¼€ã€‚åœ¨ RAG æµç¨‹çš„æ•°æ®å½•å…¥é˜¶æ®µï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•æå‡æ€§èƒ½ï¼š

æ•°æ®æ¸…æ´—

æ–‡æ¡£åˆ†å—

åµŒå…¥æ¨¡å‹

å…ƒæ•°æ®

å¤šé‡ç´¢å¼•

ç´¢å¼•ç®—æ³•

åœ¨æ¨ç†é˜¶æ®µï¼ˆåŒ…æ‹¬æ£€ç´¢å’Œç”Ÿæˆï¼‰ï¼Œåˆ™å¯ä»¥è°ƒæ•´ï¼š

æŸ¥è¯¢è½¬æ¢

æ£€ç´¢å‚æ•°

é«˜çº§æ£€ç´¢ç­–ç•¥

é‡æ’åºæ¨¡å‹

å¤§è¯­è¨€æ¨¡å‹ (LLMs)

æç¤ºå·¥ç¨‹

è¯·æ³¨æ„ï¼Œæœ¬æ–‡ä¸»è¦ä»‹ç» RAG åœ¨æ–‡æœ¬åº”ç”¨æ–¹é¢çš„å†…å®¹ã€‚è‡³äºå¤šæ¨¡æ€ RAG åº”ç”¨ï¼Œå¯èƒ½æ¶‰åŠä¸åŒçš„è€ƒé‡ã€‚

### 01. Ingestion Stage

The ingestion stage is a preparation step for building a RAG pipeline, similar to the data cleaning and preprocessing steps in an ML pipeline. Usually, the ingestion stage consists of the following steps:

1. Collect data

2. Chunk data

3. Generate vector embeddings of chunks

4. Store vector embeddings and chunks in a vector database

Documents are first chunked, then the chunks are embedded, and the embeddings are stored in the vector database

Ingestion stage of a RAG pipeline

This section discusses impactful techniques and hyperparameters that you can apply and tune to improve the relevance of the retrieved contexts in the inferencing stage.

æ•°æ®å½•å…¥é˜¶æ®µ

åœ¨æ„å»º RAG ç³»ç»Ÿæ—¶ï¼Œæ•°æ®å½•å…¥é˜¶æ®µæ˜¯ä¸€ä¸ªå…³é”®çš„å‡†å¤‡å·¥åºï¼Œå…¶è¿‡ç¨‹ç±»ä¼¼äºæœºå™¨å­¦ä¹ ä¸­çš„æ•°æ®æ¸…ç†å’Œé¢„å¤„ç†ç¯èŠ‚ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ•°æ®å½•å…¥é˜¶æ®µåŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

1ã€æ”¶é›†æ•°æ®ã€‚

2ã€æ•°æ®åˆ†å‰²ã€‚

3ã€ä¸ºæ•°æ®åˆ†å‰²ç”Ÿæˆå‘é‡åµŒå…¥ã€‚

4ã€å°†å‘é‡åµŒå…¥åŠæ•°æ®åˆ†å‰²å­˜å…¥å‘é‡æ•°æ®åº“ã€‚

é¦–å…ˆå¯¹æ–‡æ¡£è¿›è¡Œåˆ†å‰²ï¼Œç„¶åå¯¹åˆ†å‰²åçš„éƒ¨åˆ†è¿›è¡Œå‘é‡åµŒå…¥ï¼Œå¹¶å°†è¿™äº›åµŒå…¥ä¿å­˜åœ¨å‘é‡æ•°æ®åº“ä¸­ã€‚

å›¾ï¼šRAG ç³»ç»Ÿçš„æ•°æ®å½•å…¥é˜¶æ®µ

è¿™ä¸€éƒ¨åˆ†ä¸»è¦è®¨è®ºäº†ä¸€äº›æœ‰ç€æ˜¾è‘—å½±å“çš„æŠ€æœ¯å’Œè¶…å‚æ•°ï¼Œé€šè¿‡å¯¹å®ƒä»¬çš„åº”ç”¨å’Œè°ƒæ•´ï¼Œå¯ä»¥åœ¨åç»­çš„æ¨ç†é˜¶æ®µæé«˜æ£€ç´¢åˆ°çš„å†…å®¹çš„ç›¸å…³æ€§ã€‚

Data cleaning

Like any Data Science pipeline, the quality of your data heavily impacts the outcome in your RAG pipeline [8, 9]. Before moving on to any of the following steps, ensure that your data meets the following criteria:

1. Clean: Apply at least some basic data cleaning techniques commonly used in Natural Language Processing, such as making sure all special characters are encoded correctly.

2. Correct: Make sure your information is consistent and factually accurate to avoid conflicting information confusing your LLM.

æ•°æ®æ¸…ç†

å’Œæ‰€æœ‰æ•°æ®ç§‘å­¦é¡¹ç›®ä¸€æ ·ï¼Œæ•°æ®çš„è´¨é‡å¯¹ RAG ç³»ç»Ÿçš„æˆæœæœ‰ç€ç›´æ¥å½±å“ [8, 9]ã€‚åœ¨è¿›è¡Œåç»­æ­¥éª¤ä¹‹å‰ï¼Œè¯·ç¡®ä¿æ‚¨çš„æ•°æ®æ»¡è¶³ä»¥ä¸‹æ ‡å‡†ï¼š

1ã€æ¸…æ´ï¼šè‡³å°‘è¿›è¡ŒåŸºæœ¬çš„æ•°æ®æ¸…ç†ï¼Œè¿™åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä¸­éå¸¸å¸¸è§ï¼Œæ¯”å¦‚ç¡®ä¿æ‰€æœ‰ç‰¹æ®Šå­—ç¬¦éƒ½è¢«æ­£ç¡®ç¼–ç ã€‚

2ã€å‡†ç¡®ï¼šç¡®ä¿æ‚¨çš„ä¿¡æ¯æ˜¯è¿è´¯ä¸”äº‹å®æ­£ç¡®çš„ï¼Œä»¥å…å‡ºç°ç›¸äº’çŸ›ç›¾çš„ä¿¡æ¯ï¼Œä»è€Œæ··æ·†å¤§å‹è¯­è¨€æ¨¡å‹ã€‚

Chunking

Chunking your documents is an essential preparation step for your external knowledge source in a RAG pipeline that can impact the performance [1, 8, 9]. It is a technique to generate logically coherent snippets of information, usually by breaking up long documents into smaller sections (but it can also combine smaller snippets into coherent paragraphs).

One consideration you need to make is the choice of the chunking technique. For example, in LangChain, different text splitters split up documents by different logics, such as by characters, tokens, etc. This depends on the type of data you have. For example, you will need to use different chunking techniques if your input data is code vs. if it is a Markdown file.

The ideal length of your chunk (chunk_size) depends on your use case: If your use case is question answering, you may need shorter specific chunks, but if your use case is summarization, you may need longer chunks. Additionally, if a chunk is too short, it might not contain enough context. On the other hand, if a chunk is too long, it might contain too much irrelevant information.

Additionally, you will need to think about a "rolling window" between chunks (overlap) to introduce some additional context.

[Document transformers | ğŸ¦œï¸ğŸ”— Langchain](https://python.langchain.com/docs/modules/data_connection/document_transformers/)

æ–‡æ¡£åˆ†å—æŠ€æœ¯

åœ¨æ„å»º RAGï¼ˆæ£€ç´¢å¼ç”Ÿæˆç½‘ç»œï¼‰ç®¡é“æ—¶ï¼Œå°†æ–‡æ¡£è¿›è¡Œæ°å½“çš„åˆ†å—æ˜¯å…³é”®å‡†å¤‡æ­¥éª¤ä¹‹ä¸€ï¼Œè¿™ç›´æ¥å½±å“ç³»ç»Ÿçš„æ€§èƒ½ [1, 8, 9]ã€‚æ–‡æ¡£åˆ†å—æ˜¯ä¸€ç§å°†é•¿æ–‡æ¡£æ‹†åˆ†æˆå°æ®µæˆ–å°†å°æ®µä¿¡æ¯ç»„åˆæˆè¿è´¯æ®µè½çš„æŠ€æœ¯ï¼Œæ—¨åœ¨ç”Ÿæˆé€»è¾‘ä¸Šè¿è´¯ã€ä¿¡æ¯ä¸°å¯Œçš„æ–‡æ¡£ç‰‡æ®µã€‚

é‡è¦çš„ä¸€ç‚¹æ˜¯è¦é€‰æ‹©é€‚å½“çš„åˆ†å—æŠ€æœ¯ã€‚ä¾‹å¦‚ï¼Œåœ¨ LangChain ä¸­ï¼Œä¸åŒçš„æ–‡æœ¬åˆ†å‰²å™¨ä½¿ç”¨ä¸åŒçš„é€»è¾‘æ¥åˆ‡åˆ†æ–‡æ¡£ï¼Œå¦‚åŸºäºå­—ç¬¦ã€Token ç­‰ã€‚è¿™ç§é€‰æ‹©å–å†³äºæ‚¨æ‰‹å¤´çš„æ•°æ®ç±»å‹ã€‚æ¯”å¦‚ï¼Œå¤„ç†ä»£ç ç±»æ•°æ®å’Œå¤„ç† Markdown æ–‡ä»¶æ—¶ï¼Œæ‚¨éœ€è¦é‡‡ç”¨ä¸åŒçš„åˆ†å—ç­–ç•¥ã€‚

ç†æƒ³çš„åˆ†å—é•¿åº¦ï¼ˆchunk_sizeï¼‰ ä¹Ÿå› åº”ç”¨åœºæ™¯è€Œå¼‚ï¼šå¦‚æœæ˜¯é—®ç­”ç³»ç»Ÿï¼Œå¯èƒ½éœ€è¦è¾ƒçŸ­çš„ç²¾ç¡®ä¿¡æ¯å—ï¼›å¦‚æœæ˜¯å†…å®¹æ‘˜è¦ï¼Œå¯èƒ½éœ€è¦è¾ƒé•¿çš„ä¿¡æ¯å—ã€‚åŒæ—¶ï¼Œå—çš„å¤§å°ä¹Ÿéœ€æ°åˆ°å¥½å¤„ï¼šå¤ªçŸ­å¯èƒ½ç¼ºä¹è¶³å¤Ÿä¸Šä¸‹æ–‡ï¼Œå¤ªé•¿åˆ™å¯èƒ½å«æœ‰è¿‡å¤šæ— å…³ä¿¡æ¯ã€‚

æ­¤å¤–ï¼Œè¿˜éœ€è¦åœ¨ä¸åŒå—ä¹‹é—´è€ƒè™‘è®¾ç½®ã€Œæ»šåŠ¨çª—å£ã€ï¼ˆoverlapï¼‰ï¼Œä»¥ä¾¿å¢åŠ é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚

Embedding models

Embedding models are at the core of your retrieval. The quality of your embeddings heavily impacts your retrieval results [1, 4]. Usually, the higher the dimensionality of the generated embeddings, the higher the precision of your embeddings.

For an idea of what alternative embedding models are available, you can look at the Massive Text Embedding Benchmark (MTEB) Leaderboard, which covers 164 text embedding models (at the time of this writing).

MTEB Leaderboard - a Hugging Face Space by mteb

Discover amazing ML apps made by the community

huggingface.co

While you can use general-purpose embedding models out-of-the-box, it may make sense to fine-tune your embedding model to your specific use case in some cases to avoid out-of-domain issues later on [9]. According to experiments conducted by LlamaIndex, fine-tuning your embedding model can lead to a 5â€“10% performance increase in retrieval evaluation metrics [2].

Note that you cannot fine-tune all embedding models (e.g., OpenAI's text-ebmedding-ada-002 can't be fine-tuned at the moment).

[MTEB Leaderboard - a Hugging Face Space by mteb](https://huggingface.co/spaces/mteb/leaderboard)

[finetune-embedding/evaluate.ipynb at main Â· run-llama/finetune-embedding](https://github.com/run-llama/finetune-embedding/blob/main/evaluate.ipynb)

[Fine-tuning - OpenAI API](https://platform.openai.com/docs/guides/fine-tuning)

åµŒå…¥æ¨¡å‹ç®€ä»‹

åœ¨ä½ çš„ä¿¡æ¯æ£€ç´¢ç³»ç»Ÿä¸­ï¼ŒåµŒå…¥æ¨¡å‹å‘æŒ¥ç€å…³é”®ä½œç”¨ã€‚åµŒå…¥çš„å“è´¨æå¤§åœ°å½±å“äº†æ£€ç´¢çš„æ•ˆæœ [1, 4]ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒåµŒå…¥å‘é‡çš„ç»´åº¦è¶Šé«˜ï¼Œå…¶ç²¾å‡†åº¦ä¹Ÿè¶Šé«˜ã€‚

æƒ³äº†è§£æ›´å¤šå¯æ›¿æ¢çš„åµŒå…¥æ¨¡å‹ï¼Ÿå¯ä»¥å‚è€ƒ Massive Text Embedding Benchmark (MTEB) æ’è¡Œæ¦œï¼Œè¿™é‡Œæ±‡é›†äº†ç›®å‰ï¼ˆæˆªè‡³æœ¬æ–‡å†™ä½œæ—¶ï¼‰164 ç§æ–‡æœ¬åµŒå…¥æ¨¡å‹çš„æ¯”è¾ƒã€‚

MTEB æ’è¡Œæ¦œ - ç”± mteb åˆ›å»ºçš„ Hugging Face Space

å°½ç®¡é€šç”¨åµŒå…¥æ¨¡å‹å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œä½†åœ¨ä¸€äº›ç‰¹å®šåœºæ™¯ä¸‹ï¼Œå¯¹åµŒå…¥æ¨¡å‹è¿›è¡Œå¾®è°ƒæ›´æœ‰åˆ©äºé€‚åº”ç‰¹å®šçš„ä½¿ç”¨ç¯å¢ƒï¼Œé¿å…æœªæ¥å‡ºç°é¢†åŸŸå¤–é—®é¢˜ [9]ã€‚LlamaIndex çš„å®éªŒæ˜¾ç¤ºï¼Œå¾®è°ƒåµŒå…¥æ¨¡å‹å¯ä»¥åœ¨æ£€ç´¢æ•ˆæœä¸Šæå‡å¤§çº¦ 5â€“10% [2]ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰åµŒå…¥æ¨¡å‹éƒ½æ”¯æŒå¾®è°ƒã€‚ä¾‹å¦‚ï¼ŒOpenAI æä¾›çš„ text-ebmedding-ada-002 ç›®å‰è¿˜ä¸æ”¯æŒå¾®è°ƒã€‚

Metadata

When you store vector embeddings in a vector database, some vector databases let you store them together with metadata (or data that is not vectorized). Annotating vector embeddings with metadata can be helpful for additional post-processing of the search results, such as metadata filtering [1, 3, 8, 9]. For example, you could add metadata, such as the date, chapter, or subchapter reference.

[Explaining Vector Databases in 3 Levels of Difficulty | by Leonie Monigatti | Towards Data Science](https://towardsdatascience.com/explaining-vector-databases-in-3-levels-of-difficulty-fc392e48ab78)

å…ƒæ•°æ®

å½“ä½ åœ¨å‘é‡æ•°æ®åº“ä¸­å­˜å‚¨å‘é‡åµŒå…¥æ—¶ï¼Œæœ‰äº›æ•°æ®åº“æ”¯æŒä½ å°†å‘é‡ä¸å…ƒæ•°æ®ï¼ˆæˆ–éå‘é‡åŒ–çš„æ•°æ®ï¼‰ä¸€åŒå­˜å‚¨ã€‚ç»™å‘é‡åµŒå…¥æ·»åŠ å…ƒæ•°æ®æ ‡æ³¨å¯ä»¥åœ¨åç»­çš„æœç´¢ç»“æœå¤„ç†ä¸­å‘æŒ¥é‡è¦ä½œç”¨ï¼Œå¦‚è¿›è¡Œå…ƒæ•°æ®ç­›é€‰ [1, 3, 8, 9]ã€‚æ¯”å¦‚ï¼Œä½ å¯ä»¥åŠ å…¥è¯¸å¦‚æ—¥æœŸã€ç« èŠ‚æˆ–å°èŠ‚çš„å¼•ç”¨ç­‰é¢å¤–ä¿¡æ¯ã€‚

Multi-indexing

If the metadata is not sufficient enough to provide additional information to separate different types of context logically, you may want to experiment with multiple indexes [1, 9]. For example, you can use different indexes for different types of documents. Note that you will have to incorporate some index routing at retrieval time [1, 9]. If you are interested in a deeper dive into metadata and separate collections, you might want to learn more about the concept of native multi-tenancy.

[Solving Multi-Tenancy In Vector Search Requires A Paradigm Shift, Etienne Dilocker, CTO, Weviate - YouTube](https://www.youtube.com/watch?v=KT2RFMTJKGs)

å¤šé‡ç´¢å¼•æŠ€æœ¯

åœ¨å…ƒæ•°æ®æ— æ³•å……åˆ†åŒºåˆ†ä¸åŒä¸Šä¸‹æ–‡ç±»å‹çš„æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥è€ƒè™‘å°è¯•å¤šé‡ç´¢å¼•æŠ€æœ¯ [1, 9]ã€‚æ¯”å¦‚ï¼Œé’ˆå¯¹ä¸åŒæ–‡æ¡£ç±»å‹é‡‡ç”¨ä¸åŒçš„ç´¢å¼•ç­–ç•¥ã€‚ä½†è¯·æ³¨æ„ï¼Œè¿™æ ·åšéœ€è¦åœ¨æ•°æ®æ£€ç´¢æ—¶åŠ å…¥ç´¢å¼•è·¯ç”±æœºåˆ¶ [1, 9]ã€‚å¦‚æœæ‚¨å¯¹å¦‚ä½•åˆ©ç”¨å…ƒæ•°æ®å’Œåˆ†ç¦»é›†åˆæœ‰æ›´æ·±çš„å…´è¶£ï¼Œå»ºè®®æ‚¨æ·±å…¥äº†è§£åŸç”Ÿå¤šç§Ÿæˆ·è¿™ä¸€æ¦‚å¿µã€‚

Indexing algorithms

To enable lightning-fast similarity search at scale, vector databases and vector indexing libraries use an Approximate Nearest Neighbor (ANN) search instead of a k-nearest neighbor (kNN) search. As the name suggests, ANN algorithms approximate the nearest neighbors and thus can be less precise than a kNN algorithm.

There are different ANN algorithms you could experiment with, such as Facebook Faiss (clustering), Spotify Annoy (trees), Google ScaNN (vector compression), and HNSWLIB (proximity graphs). Also, many of these ANN algorithms have some parameters you could tune, such as ef, efConstruction, and maxConnections for HNSW [1].

Additionally, you can enable vector compression for these indexing algorithms. Analogous to ANN algorithms, you will lose some precision with vector compression. However, depending on the choice of the vector compression algorithm and its tuning, you can optimize this as well.

However, in practice, these parameters are already tuned by research teams of vector databases and vector indexing libraries during benchmarking experiments and not by developers of RAG systems. However, if you want to experiment with these parameters to squeeze out the last bits of performance, I recommend this article as a starting point:

[An Overview on RAG Evaluation | Weaviate - Vector Database](https://weaviate.io/blog/rag-evaluation?source=post_page-----7ca646833439--------------------------------#indexing-knobs)

Learn about new trends in RAG evaluation and the current state of the art.

[facebookresearch/faiss: A library for efficient similarity search and clustering of dense vectors.](https://github.com/facebookresearch/faiss)

[spotify/annoy: Approximate Nearest Neighbors in C++/Python optimized for memory usage and loading/saving to disk](https://github.com/spotify/annoy)

[google-research/scann at master Â· google-research/google-research](https://github.com/google-research/google-research/tree/master/scann)

[nmslib/hnswlib: Header-only C++/python library for fast approximate nearest neighbors](https://github.com/nmslib/hnswlib)

ç´¢å¼•ç®—æ³•

ä¸ºäº†å®ç°åœ¨å¤§æ•°æ®é‡ä¸‹å¿«é€Ÿä¸”é«˜æ•ˆçš„ç›¸ä¼¼æ€§æœç´¢ï¼Œå‘é‡æ•°æ®åº“å’Œç´¢å¼•åº“é€šå¸¸é‡‡ç”¨è¿‘ä¼¼æœ€è¿‘é‚» (ANN) æœç´¢æ–¹æ³•ï¼Œè€Œä¸æ˜¯ä¼ ç»Ÿçš„ k-æœ€è¿‘é‚» (kNN) æœç´¢ã€‚ANN ç®—æ³•é€šè¿‡è¿‘ä¼¼è®¡ç®—æ¥å®šä½æœ€è¿‘é‚»ï¼Œå› æ­¤å¯èƒ½åœ¨ç²¾ç¡®åº¦ä¸Šç¨é€Šäº kNN ç®—æ³•ã€‚

æ‚¨å¯ä»¥è€ƒè™‘å°è¯•å¤šç§ ANN ç®—æ³•ï¼Œä¾‹å¦‚ Facebook Faiss çš„èšç±»ç®—æ³•ã€Spotify Annoy çš„æ ‘çŠ¶ç»“æ„ç®—æ³•ã€Google ScaNN çš„å‘é‡å‹ç¼©æŠ€æœ¯ï¼Œä»¥åŠ HNSWLIB çš„é‚»è¿‘å›¾ç®—æ³•ã€‚è¿™äº›ç®—æ³•ä¸­è®¸å¤šéƒ½æä¾›äº†å¯è°ƒæ•´çš„å‚æ•°ï¼Œå¦‚ HNSW çš„ efã€efConstruction å’Œ maxConnections [1]ã€‚

å¦å¤–ï¼Œæ‚¨è¿˜å¯ä»¥ä¸ºè¿™äº›ç´¢å¼•ç®—æ³•å¯ç”¨å‘é‡å‹ç¼©æŠ€æœ¯ã€‚è™½ç„¶å‘é‡å‹ç¼©å¯èƒ½ä¼šç‰ºç‰²ä¸€å®šçš„ç²¾åº¦ï¼Œä½†é€šè¿‡åˆç†é€‰æ‹©å‹ç¼©ç®—æ³•å¹¶è°ƒæ•´å‚æ•°ï¼Œæ‚¨å¯ä»¥åœ¨ä¿è¯æ•ˆç‡çš„åŒæ—¶æœ€å¤§é™åº¦åœ°å‡å°ç²¾åº¦æŸå¤±ã€‚

ä¸è¿‡ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™äº›å‚æ•°é€šå¸¸ç”±ä¸“é—¨çš„ç ”ç©¶å›¢é˜Ÿåœ¨è¿›è¡ŒåŸºå‡†æµ‹è¯•æ—¶è°ƒæ•´ï¼Œè€Œéç”± RAG ç³»ç»Ÿçš„å¼€å‘äººå‘˜è®¾ç½®ã€‚å¦‚æœæ‚¨æƒ³é€šè¿‡è°ƒæ•´è¿™äº›å‚æ•°æ¥æé«˜ç³»ç»Ÿæ€§èƒ½ï¼Œæˆ‘æ¨èæ‚¨é˜…è¯»è¿™ç¯‡æ–‡ç« ä½œä¸ºå…¥é—¨ï¼š

å…³äº RAG è¯„ä¼°çš„æ¦‚è¿° | Weaviate - å‘é‡æ•°æ®åº“

### 02. Inferencing Stage (Retrieval & Generation)

The main components of the RAG pipeline are the retrieval and the generative components. This section mainly discusses strategies to improve the retrieval (Query transformations, retrieval parameters, advanced retrieval strategies, and re-ranking models) as this is the more impactful component of the two. But it also briefly touches on some strategies to improve the generation (LLM and prompt engineering).

Fig: Inference stage of a RAG pipeline - Standard RAG schema

æ¨ç†é˜¶æ®µï¼ˆæ£€ç´¢ä¸ç”Ÿæˆï¼‰

RAG ç®¡é“çš„æ ¸å¿ƒæ˜¯æ£€ç´¢å’Œç”Ÿæˆä¸¤å¤§éƒ¨åˆ†ã€‚è¿™ä¸€èŠ‚ä¸»è¦ä»‹ç»æå‡æ£€ç´¢æ•ˆæœçš„ç­–ç•¥ï¼ˆå¦‚æŸ¥è¯¢è½¬æ¢ã€æ£€ç´¢å‚æ•°ã€é«˜çº§æ£€ç´¢ç­–ç•¥ä»¥åŠé‡æ’åºæ¨¡å‹ï¼‰ï¼Œå› ä¸ºç›¸æ¯”ä¹‹ä¸‹ï¼Œæ£€ç´¢éƒ¨åˆ†å¯¹æ•´ä½“å½±å“æ›´å¤§ã€‚åŒæ—¶ï¼Œä¹Ÿä¼šç®€è¦ä»‹ç»ä¸€äº›æå‡ç”Ÿæˆéƒ¨åˆ†æ•ˆæœçš„æ–¹æ³•ï¼ˆæ¯”å¦‚ä½¿ç”¨å¤§è¯­è¨€æ¨¡å‹ (LLM) å’Œæç¤ºå·¥ç¨‹ (prompt engineering)ï¼‰ã€‚

å›¾ï¼šRAG ç®¡é“çš„æ¨ç†é˜¶æ®µå›¾è§£ â€”â€” æ ‡å‡† RAG æ¶æ„

Query transformations

Since the search query to retrieve additional context in a RAG pipeline is also embedded into the vector space, its phrasing can also impact the search results. Thus, if your search query doesn't result in satisfactory search results, you can experiment with various query transformation techniques [5, 8, 9], such as:

1. Rephrasing: Use an LLM to rephrase the query and try again.

2. Hypothetical Document Embeddings (HyDE): Use an LLM to generate a hypothetical response to the search query and use both for retrieval.

3. Sub-queries: Break down longer queries into multiple shorter queries.

æŸ¥è¯¢è½¬æ¢

åœ¨ RAG ç®¡é“ä¸­ï¼Œç”¨äºæ£€ç´¢é™„åŠ ä¿¡æ¯çš„æœç´¢æŸ¥è¯¢ä¹Ÿä¼šè¢«åµŒå…¥åˆ°å‘é‡ç©ºé—´é‡Œï¼Œå› æ­¤æŸ¥è¯¢çš„æªè¾ä¼šç›´æ¥å½±å“æœç´¢ç»“æœã€‚æ‰€ä»¥ï¼Œå¦‚æœä½ å‘ç°æœç´¢ç»“æœä¸å°½äººæ„ï¼Œå¯ä»¥å°è¯•ä»¥ä¸‹å‡ ç§æŸ¥è¯¢è½¬æ¢æ–¹æ³• [5, 8, 9]ï¼Œä»¥æå‡æ£€ç´¢æ•ˆç‡ï¼š

1ã€é‡æ–°æªè¾ï¼šç”¨å¤§è¯­è¨€æ¨¡å‹ (LLM) æ”¹å†™ä½ çš„æŸ¥è¯¢è¯­å¥ï¼Œç„¶åå†è¯•ä¸€æ¬¡ã€‚

2ã€å‡è®¾æ€§æ–‡æ¡£åµŒå…¥ï¼ˆHyDEï¼‰ï¼šä½¿ç”¨å¤§è¯­è¨€æ¨¡å‹ (LLM) ç”Ÿæˆä¸€ä¸ªé’ˆå¯¹æŸ¥è¯¢çš„å‡è®¾æ€§å›ç­”ï¼Œå¹¶ç»“åˆä½¿ç”¨ä»¥è¿›è¡Œæ£€ç´¢ã€‚

3ã€å­æŸ¥è¯¢ï¼šå°†å¤æ‚çš„é•¿æŸ¥è¯¢åˆ†è§£æˆå‡ ä¸ªç®€çŸ­çš„å°æŸ¥è¯¢ã€‚

Retrieval parameters

The retrieval is an essential component of the RAG pipeline. The first consideration is whether semantic search will be sufficient for your use case or if you want to experiment with hybrid search.

In the latter case, you need to experiment with weighting the aggregation of sparse and dense retrieval methods in hybrid search [1, 4, 9]. Thus, tuning the parameter alpha, which controls the weighting between semantic (alpha = 1) and keyword-based search (alpha = 0), will become necessary.

[Improving Retrieval Performance in RAG Pipelines with Hybrid Search | by Leonie Monigatti | Nov, 2023 | Towards Data Science](https://towardsdatascience.com/improving-retrieval-performance-in-rag-pipelines-with-hybrid-search-c75203c2f2f5)

How to find more relevant search results by combining traditional keyword-based search with modern vector search

Also, the number of search results to retrieve will play an essential role. The number of retrieved contexts will impact the length of the used context window (see Prompt Engineering). Also, if you are using a re-ranking model, you need to consider how many contexts to input to the model (see Re-ranking models).

Note, while the used similarity measure for semantic search is a parameter you can change, you should not experiment with it but instead set it according to the used embedding model (e.g., text-embedding-ada-002 supports cosine similarity or multi-qa-MiniLM-l6-cos-v1 supports cosine similarity, dot product, and Euclidean distance).

æ£€ç´¢å‚æ•°

æ£€ç´¢è¿‡ç¨‹æ˜¯ RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰æµç¨‹çš„æ ¸å¿ƒç¯èŠ‚ã€‚é¦–å…ˆï¼Œä½ éœ€è¦å†³å®šä»…ä½¿ç”¨è¯­ä¹‰æœç´¢æ˜¯å¦è¶³å¤Ÿï¼Œæˆ–è€…ä½ æ˜¯å¦æƒ³å°è¯•æ›´å¤æ‚çš„æ··åˆæœç´¢ã€‚

åœ¨é€‰æ‹©æ··åˆæœç´¢æ—¶ï¼Œä½ éœ€è¦ç ”ç©¶å¦‚ä½•åœ¨ç¨€ç–å’Œå¯†é›†æ£€ç´¢æ–¹æ³•ä¹‹é—´è¿›è¡Œæœ‰æ•ˆçš„æƒé‡åˆ†é… [1, 4, 9]ã€‚è¿™å°±æ¶‰åŠåˆ°è°ƒæ•´ alpha å‚æ•°ï¼Œè¯¥å‚æ•°è´Ÿè´£å¹³è¡¡åŸºäºè¯­ä¹‰çš„æœç´¢ï¼ˆalpha = 1ï¼‰å’ŒåŸºäºå…³é”®è¯çš„æœç´¢ï¼ˆalpha = 0ï¼‰çš„é‡è¦æ€§ã€‚

å¦ä¸€ä¸ªå…³é”®å› ç´ æ˜¯æ£€ç´¢ç»“æœçš„æ•°é‡ã€‚æ£€ç´¢åˆ°çš„ä¸Šä¸‹æ–‡æ•°é‡ä¼šå½±å“æ‰€ç”¨ä¸Šä¸‹æ–‡çª—å£çš„é•¿åº¦ï¼ˆå‚è§æç¤ºå·¥ç¨‹ï¼‰ã€‚æ­¤å¤–ï¼Œå¦‚æœä½ ä½¿ç”¨çš„æ˜¯é‡æ’æ¨¡å‹ï¼Œä½ è¿˜éœ€è¦è€ƒè™‘å‘æ¨¡å‹è¾“å…¥å¤šå°‘ä¸ªä¸Šä¸‹æ–‡ï¼ˆå‚è§é‡æ’åºæ¨¡å‹ï¼‰ã€‚

è¯·æ³¨æ„ï¼Œè™½ç„¶ä½ å¯ä»¥æ›´æ”¹ç”¨äºè¯­ä¹‰æœç´¢çš„ç›¸ä¼¼åº¦åº¦é‡å‚æ•°ï¼Œä½†æœ€å¥½ä¸è¦éšæ„å˜åŠ¨ï¼Œè€Œæ˜¯æ ¹æ®æ‰€ä½¿ç”¨çš„åµŒå…¥æ¨¡å‹æ¥è®¾å®šã€‚ä¾‹å¦‚ï¼Œtext-embedding-ada-002 æ”¯æŒä½™å¼¦ç›¸ä¼¼åº¦ï¼Œè€Œ multi-qa-MiniLM-l6-cos-v1 æ”¯æŒä½™å¼¦ç›¸ä¼¼åº¦ã€ç‚¹ç§¯å’Œæ¬§å‡ é‡Œå¾—è·ç¦»ã€‚

Advanced retrieval strategies

This section could technically be its own article. For this overview, we will keep this as concise as possible. For an in-depth explanation of the following techniques, I recommend this DeepLearning.AI course:

[Building and Evaluating Advanced RAG Applications - DeepLearning.AI](https://www.deeplearning.ai/short-courses/building-evaluating-advanced-rag/?source=post_page-----7ca646833439--------------------------------)

Learn methods like sentence-window retrieval and auto-merging retrieval, improving your RAG pipeline's performanceâ€¦

The underlying idea of this section is that the chunks for retrieval shouldn't necessarily be the same chunks used for the generation. Ideally, you would embed smaller chunks for retrieval (see Chunking) but retrieve bigger contexts. [7]

Sentence-window retrieval: Do not just retrieve the relevant sentence, but the window of appropriate sentences before and after the retrieved one.

Auto-merging retrieval: The documents are organized in a tree-like structure. At query time, separate but related, smaller chunks can be consolidated into a larger context.

é«˜çº§æ£€ç´¢ç­–ç•¥

æœ¬èŠ‚å†…å®¹è¶³å¤Ÿç¼–å†™æˆä¸€ç¯‡ç‹¬ç«‹æ–‡ç« ã€‚ä¸ºäº†ä¿æŒç®€æ´ï¼Œæˆ‘ä»¬ä»…æä¾›ä¸€ä¸ªæ¦‚è§ˆã€‚æƒ³è¦æ·±å…¥äº†è§£ä¸‹é¢æåˆ°çš„æŠ€æœ¯ï¼Œæˆ‘å»ºè®®ä½ å‚è€ƒ DeepLearning.AI æä¾›çš„è¿™ä¸ªè¯¾ç¨‹ï¼š

æ„å»ºå’Œè¯„ä¼°é«˜çº§ RAG åº”ç”¨

è¿™ä¸€èŠ‚çš„æ ¸å¿ƒç†å¿µæ˜¯ï¼šç”¨äºæ£€ç´¢çš„æ•°æ®å—ä¸å¿…æ˜¯ç”¨äºç”Ÿæˆå†…å®¹çš„åŒä¸€æ•°æ®å—ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œåº”è¯¥åµŒå…¥æ›´å°çš„æ•°æ®å—æ¥è¿›è¡Œæ£€ç´¢ï¼ˆå‚è§æ–‡æ¡£åˆ†å—ï¼‰ï¼Œä½†åŒæ—¶æ£€ç´¢æ›´å¹¿æ³›çš„ä¸Šä¸‹æ–‡ã€‚[7]

å¥å­çª—å£æ£€ç´¢ï¼šåœ¨æ£€ç´¢æ—¶ï¼Œä¸åªæ˜¯æ‰¾åˆ°ç›¸å…³çš„å•ä¸ªå¥å­ï¼Œè€Œæ˜¯è¦è·å–è¯¥å¥å­å‰åçš„ç›¸å…³å¥å­ã€‚

è‡ªåŠ¨åˆå¹¶æ£€ç´¢ï¼šæ–‡æ¡£æŒ‰æ ‘çŠ¶ç»“æ„ç»„ç»‡ã€‚åœ¨æŸ¥è¯¢æ—¶ï¼Œå¯ä»¥æŠŠè‹¥å¹²ä¸ªå°çš„ã€ç›¸å…³çš„æ•°æ®å—åˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ä¸Šä¸‹æ–‡ã€‚

Re-ranking models

While semantic search retrieves context based on its semantic similarity to the search query, "most similar" doesn't necessarily mean "most relevant". Re-ranking models, such as Cohere's Rerank model, can help eliminate irrelevant search results by computing a score for the relevance of the query for each retrieved context [1, 9].

"most similar" doesn't necessarily mean "most relevant"

If you are using a re-ranker model, you may need to re-tune the number of search results for the input of the re-ranker and how many of the reranked results you want to feed into the LLM.

As with the embedding models, you may want to experiment with fine-tuning the re-ranker to your specific use case.

[Rerank - Optimize Your Search With One Line of Code | Cohere](https://cohere.com/rerank?ref=txt.cohere.com&__hstc=14363112.8fc20f6b1a1ad8c0f80dcfed3741d271.1697800567394.1701091033915.1701173515537.7&__hssc=14363112.1.1701173515537&__hsfp=3638092843)

é‡æ’åºæ¨¡å‹

è™½ç„¶è¯­ä¹‰æœç´¢æ˜¯æ ¹æ®æœç´¢æŸ¥è¯¢ä¸ä¸Šä¸‹æ–‡çš„è¯­ä¹‰ç›¸ä¼¼åº¦æ¥è¿›è¡Œçš„ï¼Œä½†ã€Œæœ€ç›¸ä¼¼ã€å¹¶ä¸æ€»ç­‰åŒäºã€Œæœ€ç›¸å…³ã€ã€‚åƒ Cohere çš„ Rerank è¿™æ ·çš„é‡æ’åºæ¨¡å‹èƒ½å¤Ÿé€šè¿‡ä¸ºæ¯ä¸ªæ£€ç´¢ç»“æœè®¡ç®—ä¸æŸ¥è¯¢ç›¸å…³æ€§çš„å¾—åˆ†ï¼Œå¸®åŠ©æ’é™¤ä¸ç›¸å…³çš„æœç´¢ç»“æœ [1, 9]ã€‚

ã€Œæœ€ç›¸ä¼¼ã€ä¸æ€»æ„å‘³ç€ã€Œæœ€ç›¸å…³ã€

ä½¿ç”¨é‡æ’åºæ¨¡å‹æ—¶ï¼Œä½ å¯èƒ½éœ€è¦é‡æ–°è°ƒæ•´æœç´¢ç»“æœçš„æ•°é‡ï¼Œä»¥åŠä½ æƒ³è¦è¾“å…¥åˆ°å¤§è¯­è¨€æ¨¡å‹ (Large Language Model) çš„ç»è¿‡é‡æ’åºçš„ç»“æœæ•°é‡ã€‚

å’ŒåµŒå…¥æ¨¡å‹ä¸€æ ·ï¼Œä½ å¯èƒ½éœ€è¦å°è¯•é’ˆå¯¹ä½ çš„ç‰¹å®šåº”ç”¨åœºæ™¯å¯¹é‡æ’åºæ¨¡å‹è¿›è¡Œå¾®è°ƒã€‚

LLMs

The LLM is the core component for generating the response. Similarly to the embedding models, there is a wide range of LLMs you can choose from depending on your requirements, such as open vs. proprietary models, inferencing costs, context length, etc. [1]

As with the embedding models or re-ranking models, you may want to experiment with fine-tuning the LLM to your specific use case to incorporate specific wording or tone of voice.

å¤§è¯­è¨€æ¨¡å‹ (LLM)

åœ¨ç”Ÿæˆå›åº”çš„è¿‡ç¨‹ä¸­ï¼Œå¤§è¯­è¨€æ¨¡å‹ (LLM) æ‰®æ¼”ç€æ ¸å¿ƒè§’è‰²ã€‚æ­£å¦‚åµŒå…¥æ¨¡å‹é‚£æ ·ï¼ŒLLM çš„é€‰æ‹©å–å†³äºæ‚¨çš„å…·ä½“éœ€æ±‚ï¼Œæ¯”å¦‚é€‰æ‹©å¼€æ”¾æºä»£ç è¿˜æ˜¯ä¸“æœ‰æ¨¡å‹ã€è€ƒè™‘æ¨ç†æˆæœ¬ã€ä¸Šä¸‹æ–‡é•¿åº¦ç­‰å› ç´ ã€‚æ‚¨å¯ä»¥ä»ä¼—å¤š LLM ä¸­æŒ‘é€‰æœ€é€‚åˆæ‚¨çš„ [1]ã€‚

ä¸å¤„ç†åµŒå…¥æ¨¡å‹æˆ–é‡æ–°æ’åºæ¨¡å‹æ—¶ç›¸ä¼¼ï¼Œæ‚¨å¯èƒ½éœ€è¦é’ˆå¯¹ç‰¹å®šåœºæ™¯å¯¹ LLM è¿›è¡Œå¾®è°ƒï¼Œä»¥ä¾¿æ›´å¥½åœ°èå…¥ç‰¹å®šçš„è¯æ±‡æˆ–è¯­è°ƒã€‚

Prompt engineering

How you phrase or engineer your prompt will significantly impact the LLM's completion [1, 8, 9].

Please base your answer only on the search results and nothing else!

Very important! Your answer MUST be grounded in the search results provided.

Please explain why your answer is grounded in the search results!

Additionally, using few-shot examples in your prompt can improve the quality of the completions.

As mentioned in Retrieval parameters, the number of contexts fed into the prompt is a parameter you should experiment with [1]. While the performance of your RAG pipeline can improve with increasing relevant context, you can also run into a "Lost in the Middle" [6] effect where relevant context is not recognized as such by the LLM if it is placed in the middle of many contexts.

æç¤ºå·¥ç¨‹ (Prompt engineering)

å¦‚ä½•å·§å¦™åœ°è®¾è®¡æ‚¨çš„æç¤ºè¯æˆ–é—®é¢˜ï¼Œå°†ç›´æ¥å½±å“åˆ° LLM çš„å›ç­”æ•ˆæœ [1, 8, 9]ã€‚ä¸€ä¸ªå¥½çš„æç¤ºè¯è®¾è®¡èƒ½è®© LLM æä¾›æ›´åŠ å‡†ç¡®å’Œé«˜è´¨é‡çš„å›ç­”ã€‚

è¯·ç¡®ä¿æ‚¨çš„å›ç­”ä»…åŸºäºæœç´¢ç»“æœï¼Œä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–ä¿¡æ¯ï¼

è¿™ä¸€ç‚¹éå¸¸å…³é”®ï¼æ‚¨çš„å›ç­”å¿…é¡»ä¸¥æ ¼åŸºäºæä¾›çš„æœç´¢ç»“æœã€‚

å¹¶è¯·è¯´æ˜æ‚¨çš„å›ç­”ä¸ºä½•ä¸æœç´¢ç»“æœå¯†åˆ‡ç›¸å…³ï¼

åœ¨æç¤ºè¯ä¸­åŠ å…¥å°‘æ ·æœ¬ (few-shot) ç¤ºä¾‹ï¼Œå¯ä»¥æœ‰æ•ˆæå‡ LLM ç”Ÿæˆå†…å®¹çš„è´¨é‡ã€‚

æ­£å¦‚åœ¨æ£€ç´¢å‚æ•°ä¸€èŠ‚ä¸­æåˆ°çš„ï¼Œæ¢ç´¢åœ¨æç¤ºè¯ä¸­åŠ å…¥çš„ä¸Šä¸‹æ–‡æ•°é‡ä¹Ÿæ˜¯å€¼å¾—å°è¯•çš„ã€‚è™½ç„¶å¢åŠ ç›¸å…³ä¸Šä¸‹æ–‡æœ‰åŠ©äºæé«˜æ‚¨çš„ RAG (æ£€ç´¢å¢å¼ºç”Ÿæˆ) ç³»ç»Ÿçš„æ€§èƒ½ï¼Œä½†åŒæ—¶ä¹Ÿå¯èƒ½äº§ç”Ÿã€Œè¿·å¤±åœ¨ä¸­é—´ã€[6] çš„ç°è±¡ï¼Œå³ LLM æ— æ³•æœ‰æ•ˆè¯†åˆ«è¢«æ”¾ç½®åœ¨ä¼—å¤šä¸Šä¸‹æ–‡ä¸­é—´çš„ç›¸å…³ä¿¡æ¯ã€‚

### 03. Summary

As more and more developers gain experience with prototyping RAG pipelines, it becomes more important to discuss strategies to bring RAG pipelines to production-ready performances. This article discussed different "hyperparameters" and other knobs you can tune in a RAG pipeline according to the relevant stages:

This article covered the following strategies in the ingestion stage:

Data cleaning: Ensure data is clean and correct.

Chunking: Choice of chunking technique, chunk size (chunk_size) and chunk overlap (overlap).

Embedding models: Choice of the embedding model, incl. dimensionality, and whether to fine-tune it.

Metadata: Whether to use metadata and choice of metadata.

Multi-indexing: Decide whether to use multiple indexes for different data collections.

Indexing algorithms: Choice and tuning of ANN and vector compression algorithms can be tuned but are usually not tuned by practitioners.

And the following strategies in the inferencing stage (retrieval and generation):

Query transformations: Experiment with rephrasing, HyDE, or sub-queries.

Retrieval parameters: Choice of search technique (alpha if you have hybrid search enabled) and the number of retrieved search results.

Advanced retrieval strategies: Whether to use advanced retrieval strategies, such as sentence-window or auto-merging retrieval.

Re-ranking models: Whether to use a re-ranking model, choice of re-ranking model, number of search results to input into the re-ranking model, and whether to fine-tune the re-ranking model.

LLMs: Choice of LLM and whether to fine-tune it.

Prompt engineering: Experiment with different phrasing and few-shot examples.

Enjoyed This Story?

Subscribe for free to get notified when I publish a new story.

Get an email whenever Leonie Monigatti publishes.

Get an email whenever Leonie Monigatti publishes. By signing up, you will create a Medium account if you don't alreadyâ€¦

medium.com

Find me on LinkedIn, Twitter, and Kaggle!

éšç€è¶Šæ¥è¶Šå¤šçš„å¼€å‘äººå‘˜ç§¯ææ¢ç´¢ RAG (æ£€ç´¢å¢å¼ºç”Ÿæˆ) ç®¡é“çš„åŸå‹è®¾è®¡ï¼Œå¦‚ä½•å°† RAG ç®¡é“æå‡è‡³é€‚ç”¨äºç”Ÿäº§ç¯å¢ƒçš„æ€§èƒ½æ°´å¹³å˜å¾—æ„ˆå‘é‡è¦ã€‚æœ¬æ–‡æ¢è®¨äº†åœ¨ RAG ç®¡é“ä¸åŒé˜¶æ®µå¯ä»¥è°ƒæ•´çš„å„ç§ã€Œè¶…å‚æ•°ã€å’Œå…¶ä»–å¯è°ƒèŠ‚é¡¹ï¼š

æ–‡ç« åœ¨æ•°æ®å½•å…¥é˜¶æ®µä¸­ä»‹ç»äº†ä»¥ä¸‹ç­–ç•¥ï¼š

1ã€æ•°æ®æ¸…æ´—ï¼šç¡®ä¿æ•°æ®çš„æ¸…æ´å’Œå‡†ç¡®æ€§ã€‚

2ã€åˆ†å—ï¼šé€‰æ‹©åˆé€‚çš„åˆ†å—æŠ€æœ¯ã€å—å¤§å°ï¼ˆchunk_sizeï¼‰å’Œå—ä¹‹é—´çš„é‡å ï¼ˆoverlapï¼‰ã€‚

3ã€åµŒå…¥æ¨¡å‹ï¼šé€‰æ‹©åµŒå…¥æ¨¡å‹ï¼ŒåŒ…æ‹¬æ¨¡å‹çš„ç»´åº¦ä»¥åŠæ˜¯å¦éœ€è¦è¿›è¡Œå¾®è°ƒã€‚

4ã€å…ƒæ•°æ®ï¼šå†³å®šæ˜¯å¦ä½¿ç”¨å…ƒæ•°æ®ä»¥åŠé€‰æ‹©å“ªäº›å…ƒæ•°æ®ã€‚

5ã€å¤šé‡ç´¢å¼•ï¼šå†³å®šæ˜¯å¦ä¸ºä¸åŒçš„æ•°æ®é›†åˆä½¿ç”¨å¤šä¸ªç´¢å¼•ã€‚

6ã€ç´¢å¼•ç®—æ³•ï¼šé€‰æ‹©å’Œè°ƒæ•´è¿‘ä¼¼æœ€è¿‘é‚» (ANN) å’Œå‘é‡å‹ç¼©ç®—æ³•ï¼Œè™½ç„¶è¿™é€šå¸¸ä¸æ˜¯å®è·µè€…æ‰€è°ƒæ•´çš„ã€‚

ä»¥åŠåœ¨æ¨ç†é˜¶æ®µï¼ˆæ£€ç´¢å’Œç”Ÿæˆï¼‰ä¸­ä»‹ç»çš„ç­–ç•¥ï¼š

1ã€æŸ¥è¯¢è½¬æ¢ï¼šå°è¯•ä½¿ç”¨æ”¹å†™ã€HyDE æˆ–å­æŸ¥è¯¢ç­‰æ–¹å¼ã€‚

2ã€æ£€ç´¢å‚æ•°ï¼šé€‰æ‹©æœç´¢æŠ€æœ¯ï¼ˆå¦‚æœå¯ç”¨æ··åˆæœç´¢ï¼Œåˆ™ä¸º alphaï¼‰å’Œæ£€ç´¢çš„æœç´¢ç»“æœæ•°é‡ã€‚

4ã€é«˜çº§æ£€ç´¢ç­–ç•¥ï¼šå†³å®šæ˜¯å¦ä½¿ç”¨é«˜çº§æ£€ç´¢ç­–ç•¥ï¼Œå¦‚å¥å­çª—å£æˆ–è‡ªåŠ¨åˆå¹¶æ£€ç´¢ã€‚

5ã€é‡æ–°æ’åºæ¨¡å‹ï¼šæ˜¯å¦ä½¿ç”¨é‡æ–°æ’åºæ¨¡å‹ï¼Œé€‰æ‹©å“ªç§é‡æ–°æ’åºæ¨¡å‹ï¼Œç¡®å®šè¾“å…¥åˆ°è¯¥æ¨¡å‹ä¸­çš„æœç´¢ç»“æœæ•°é‡ï¼Œä»¥åŠæ˜¯å¦å¯¹æ¨¡å‹è¿›è¡Œå¾®è°ƒã€‚

6ã€å¤§è¯­è¨€æ¨¡å‹ (LLM)ï¼šé€‰æ‹©é€‚åˆçš„å¤§è¯­è¨€æ¨¡å‹å¹¶å†³å®šæ˜¯å¦è¿›è¡Œå¾®è°ƒã€‚

7ã€æç¤ºå·¥ç¨‹ï¼šå°è¯•ä½¿ç”¨ä¸åŒçš„æªè¾å’Œå°‘æ ·æœ¬ç¤ºä¾‹ã€‚

åœ¨ LinkedInã€Twitter å’Œ Kaggle ä¸Šæ‰¾åˆ°æˆ‘ï¼

### References

Literature

[1] Connor Shorten and Erika Cardenas (2023). Weaviate Blog. An Overview on RAG Evaluation (accessed Nov. 27, 2023)

[An Overview on RAG Evaluation | Weaviate - Vector Database](https://weaviate.io/blog/rag-evaluation)

[2] Jerry Liu (2023). LlamaIndex Blog. Fine-Tuning Embeddings for RAG with Synthetic Data (accessed Nov. 28, 2023)

[Fine-Tuning Embeddings for RAG with Synthetic Data | by Jerry Liu | LlamaIndex Blog](https://blog.llamaindex.ai/fine-tuning-embeddings-for-rag-with-synthetic-data-e534409a3971)

[3] LlamaIndex Documentation (2023). Building Performant RAG Applications for Production (accessed Nov. 28, 2023)

[Building Performant RAG Applications for Production - LlamaIndex ğŸ¦™ 0.9.13](https://docs.llamaindex.ai/en/stable/optimizing/production_rag.html)

[4] Voyage AI (2023). Embeddings Drive the Quality of RAG: A Case Study of Chat.LangChain (accessed Dec. 5, 2023)

[Embeddings Drive the Quality of RAG: A Case Study of Chat.LangChainÂ  â€“ Voyage AI](https://blog.voyageai.com/2023/10/29/a-case-study-of-chat-langchain/)

[5] LlamaIndex Documentation (2023). Query Transformations (accessed Nov. 28, 2023)

[6] Liu, N. F., Lin, K., Hewitt, J., Paranjape, A., Bevilacqua, M., Petroni, F., & Liang, P. (2023). Lost in the middle: How language models use long contexts. arXiv preprint arXiv:2307.03172.

[7] DeepLearning.AI (2023). Building and Evaluating Advanced RAG Applications (accessed Dec 4, 2023)

[Building and Evaluating Advanced RAG Applications - DeepLearning.AI](https://www.deeplearning.ai/short-courses/building-evaluating-advanced-rag/)

[8] Ahmed Besbes (2023). Towards Data Science. Why Your RAG Is Not Reliable in a Production Environment (accessed Nov. 27, 2023)

[Why Your RAG Is Not Reliable in a Production Environment | by Ahmed Besbes | Oct, 2023 | Towards Data Science](https://towardsdatascience.com/why-your-rag-is-not-reliable-in-a-production-environment-9e6a73b3eddb)

[9] Matt Ambrogi (2023). Towards Data Science. 10 Ways to Improve the Performance of Retrieval Augmented Generation Systems (accessed Nov. 27, 2023)

[10 Ways to Improve the Performance of Retrieval Augmented Generation Systems | by Matt Ambrogi | Towards Data Science](https://towardsdatascience.com/10-ways-to-improve-the-performance-of-retrieval-augmented-generation-systems-5fa2cee7cd5c)