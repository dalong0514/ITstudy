## 20231230é«˜çº§RAGæŠ€æœ¯å›¾è§£æ¦‚è§ˆ

Advanced RAG Techniques: an Illustrated Overview

IVAN ILIN

[Advanced RAG Techniques: an Illustrated Overview | by IVAN ILIN | Dec, 2023 | Towards AI](https://pub.towardsai.net/advanced-rag-techniques-an-illustrated-overview-04d193d8fec6)

[é«˜çº§ RAG æŠ€æœ¯ï¼šå›¾è§£æ¦‚è§ˆ [è¯‘] | å®ç‰çš„åˆ†äº«](https://baoyu.io/translations/rag/advanced-rag-techniques-an-illustrated-overview)

A comprehensive study of the advanced retrieval augmented generation techniques and algorithms, systemising various approaches. The article comes with a collection of links in my knowledge base referencing various implementations and studies mentioned.

Since the goal of the post is to make an overview & explanation of avaliable RAG algorithms and techniques, I won't dive into implementations details in code, just referencing them and leaving it to the vast documentation & tutorials available.

æœ¬æ–‡å…¨é¢ç ”ç©¶äº†é«˜çº§æ£€ç´¢å¢å¼ºå¼ç”ŸæˆæŠ€æœ¯ï¼ˆRAGï¼‰åŠå…¶ç®—æ³•ï¼Œç³»ç»Ÿåœ°æ•´ç†äº†å„ç§æ–¹æ³•ã€‚æ–‡ç« ä¸­è¿˜åŒ…å«äº†æˆ‘çŸ¥è¯†åº“ä¸­ä¸æåˆ°çš„å„ç§å®ç°å’Œç ”ç©¶ç›¸å…³çš„é“¾æ¥é›†ã€‚

ç”±äºæœ¬æ–‡çš„ç›®çš„åœ¨äºæ¦‚è¿°å’Œè§£é‡Šå½“å‰å¯ç”¨çš„ RAG ç®—æ³•å’ŒæŠ€æœ¯ï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šæ·±å…¥æ¢è®¨ä»£ç å®ç°çš„ç»†èŠ‚ï¼Œä»…åšç®€è¦æåŠï¼Œå¹¶æ¨èé˜…è¯»ä¸°å¯Œçš„ç›¸å…³æ–‡æ¡£ä¸æ•™ç¨‹ã€‚

### 01. Intro

If you are familiar with the RAG concept, please skip to the Advanced RAG part.

Retrieval Augmented Generation, aka RAG, provides LLMs with the information retrieved from some data source to ground its generated answer on. Basically RAG is Search + LLM prompting, where your ask the model to answer the query provided the information found with the search algorithm as a context. Both the query and the retrieved context are injected into the prompt that is sent to the LLM.

RAG is the most popular architecture of the LLM based systems in 2023. There are many products build almost solely on RAG â€” from Question Answering services combining web search engines with LLMs to hundreds of chat-with-your-data apps.

Even the vector search area got pumped by that hype although embedding based search engines were made with faiss back in 2019. Vector database startups like chroma, weavaite.io and pinecone have been built upon existing open source search indices â€” mainly faiss and nmslib â€” and added an extra storage for the input texts plus some other tooling lately.

There are two most prominent open source libraries for LLM-based pipelines & applications â€” LangChain and LlamaIndex, founded with a month difference in October and November 2022, respectfully, inspired by the ChatGPT launch and having gained massive adoption in 2023.

The purpose of this article is to systemise the key advanced RAG techniques with references to their implementations â€” mostly in the LlamaIndex â€” in order to facilitate other developers' dive into the technology.

The problem is that most of the tutorials cherry-pick one or several techniques and explain in details how to implement them rather than decribing the full variety of the avaliable tools .

Another thing is that both LlamaIndex and LangChian are amazing open source projects, developing at such a pace that their documentation is already thicker than a machine learning textbook in 2016.

å¼•è¨€

å¦‚æœæ‚¨å·²ç†Ÿæ‚‰ RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰æ¦‚å¿µï¼Œè¯·ç›´æ¥è·³è‡³é«˜çº§ RAG éƒ¨åˆ†ã€‚

æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRetrieval Augmented Generationï¼Œç®€ç§° RAGï¼‰ä¸ºå¤§è¯­è¨€æ¨¡å‹ (LLMs) æä¾›äº†ä»æ•°æ®æºæ£€ç´¢çš„ä¿¡æ¯ï¼Œä»¥æ­¤ä¸ºåŸºç¡€ç”Ÿæˆå›ç­”ã€‚ç®€è€Œè¨€ä¹‹ï¼ŒRAG ç»“åˆäº†æœç´¢æŠ€æœ¯å’Œå¤§è¯­è¨€æ¨¡å‹çš„æç¤ºåŠŸèƒ½ï¼Œå³æ¨¡å‹æ ¹æ®æœç´¢ç®—æ³•æ‰¾åˆ°çš„ä¿¡æ¯ä½œä¸ºä¸Šä¸‹æ–‡æ¥å›ç­”æŸ¥è¯¢é—®é¢˜ã€‚æ— è®ºæ˜¯æŸ¥è¯¢è¿˜æ˜¯æ£€ç´¢çš„ä¸Šä¸‹æ–‡ï¼Œéƒ½ä¼šè¢«æ•´åˆåˆ°å‘ç»™å¤§è¯­è¨€æ¨¡å‹çš„æç¤ºä¸­ã€‚

2023 å¹´ï¼ŒåŸºäº RAG æ¶æ„çš„å¤§è¯­è¨€æ¨¡å‹ç³»ç»Ÿæˆä¸ºæœ€å—æ¬¢è¿çš„æŠ€æœ¯ã€‚è®¸å¤šäº§å“å‡ ä¹å…¨ä¾èµ– RAG æ¶æ„ï¼Œè¿™åŒ…æ‹¬ç»“åˆç½‘ç»œæœç´¢å¼•æ“å’Œå¤§è¯­è¨€æ¨¡å‹çš„é—®ç­”æœåŠ¡ï¼Œä»¥åŠæ•°ä»¥ç™¾è®¡çš„æ•°æ®äº¤äº’åº”ç”¨ç¨‹åºã€‚

å³ä½¿æ˜¯å‘é‡æœç´¢é¢†åŸŸä¹Ÿå›  RAG çš„çƒ­æ½®è€Œå¾—åˆ°æ¨åŠ¨ï¼Œå°½ç®¡åŸºäºåµŒå…¥å¼æœç´¢å¼•æ“çš„æŠ€æœ¯æ—©åœ¨ 2019 å¹´å°±å·²ç»è¿ç”¨äº† faissã€‚ä¾‹å¦‚ chromaã€weaviate.io å’Œ pinecone è¿™æ ·çš„å‘é‡æ•°æ®åº“åˆåˆ›å…¬å¸åœ¨ç°æœ‰çš„å¼€æºæœç´¢ç´¢å¼•åŸºç¡€ä¸Š â€”â€” ä¸»è¦æ˜¯ faiss å’Œ nmslib â€”â€” æ„å»ºäº†è‡ªå·±çš„ç³»ç»Ÿï¼Œå¹¶åœ¨è¿‘æœŸå¢åŠ äº†è¾“å…¥æ–‡æœ¬çš„é¢å¤–å­˜å‚¨å’Œå…¶ä»–å·¥å…·ã€‚

ä¸¤ä¸ªæœ€æ˜¾è‘—çš„å¼€æºåº“ç”¨äºåŸºäºå¤§è¯­è¨€æ¨¡å‹çš„ç®¡é“å’Œåº”ç”¨ç¨‹åºæ˜¯ LangChain å’Œ LlamaIndexï¼Œå®ƒä»¬åˆ†åˆ«åœ¨ 2022 å¹´ 10 æœˆå’Œ 11 æœˆæˆç«‹ï¼Œç›¸å·®ä¸€ä¸ªæœˆï¼Œå—åˆ° ChatGPT å‘å¸ƒçš„å¯å‘ï¼Œå¹¶åœ¨ 2023 å¹´è·å¾—äº†å¹¿æ³›åº”ç”¨ã€‚

æœ¬æ–‡æ—¨åœ¨ç³»ç»Ÿåœ°ä»‹ç»é«˜çº§ RAG æŠ€æœ¯åŠå…¶åœ¨ LlamaIndex ç­‰å¹³å°çš„å®ç°ï¼Œä»¥å¸®åŠ©å¼€å‘è€…æ·±å…¥ç†è§£è¿™é¡¹æŠ€æœ¯ã€‚

é—®é¢˜åœ¨äºï¼Œå¤§å¤šæ•°æ•™ç¨‹ä»…æŒ‘é€‰ä¸ªåˆ«æŠ€æœ¯è¿›è¡Œè¯¦ç»†è®²è§£ï¼Œè€Œæ²¡æœ‰å…¨é¢ä»‹ç»æ‰€æœ‰å¯ç”¨çš„å·¥å…·ã€‚

å¦ä¸€ä¸ªé—®é¢˜æ˜¯ï¼ŒLlamaIndex å’Œ LangChain éƒ½æ˜¯å‘å±•è¿…é€Ÿçš„ä¼˜ç§€å¼€æºé¡¹ç›®ï¼Œä»¥è‡³äºå®ƒä»¬çš„æ–‡æ¡£å·²ç»æ¯” 2016 å¹´çš„æœºå™¨å­¦ä¹ æ•™ç§‘ä¹¦è¿˜è¦åšã€‚

### 02. Naive RAG

The starting point of the RAG pipeline in this article would be a corpus of text documents â€” we skip everything before that point, leaving it to the amazing open source data loaders connecting to any imaginable source from Youtube to Notion.

Fig: A scheme by author, as well all the schemes further in the text

Vanilla RAG case in brief looks the following way: you split your texts into chunks, then you embed these chunks into vectors with some Transformer Encoder model, you put all those vectors into an index and finally you create a prompt for an LLM that tells the model to answers user's query given the context we found on the search step.

In the runtime we vectorise user's query with the same Encoder model and then execute search of this query vector against the index, find the top-k results, retrieve the corresponding text chunks from our database and feed them into the LLM prompt as context.

The prompt can look like that:

```py
def question_answering(context, query):
    prompt = f"""
                Give the answer to the user query delimited by triple backticks ```{query}```\
                using the information given in context delimited by triple backticks ```{context}```.\
                If there is no relevant information in the provided context, try to answer yourself, 
                but tell user that you did not have any relevant context to base your answer on.
                Be concise and output the answer of size less than 80 tokens.
                """

    response = get_completion(instruction, prompt, model="gpt-3.5-turbo")
    answer = response.choices[0].message["content"]
    return answer
```

an example of a RAG prompt

Prompt engineering is the cheapest thing you can try to improve your RAG pipeline. Make sure you've checked a quite comprehensive OpenAI prompt engineering guide.

Obviously despite OpenAI being the market leader as an LLM provider there is a number of alternatives such as Claude from Anthropic, recent trendy smaller but very capable models like Mixtral form Mistral, Phi-2 from Microsoft and many open source options like Llama2, OpenLLaMA, Falcon, so you have a choice of the brain for your RAG pipeline.

åŸå§‹ RAG æ–¹æ³•

æœ¬æ–‡ä¸­æ‰€è®¨è®ºçš„ RAG æµç¨‹èµ·å§‹äºä¸€ç³»åˆ—æ–‡æœ¬æ–‡æ¡£ â€”â€” æœ¬æ–‡ä¸æ¶‰åŠæ­¤ä¹‹å‰çš„å†…å®¹ï¼Œè€Œæ˜¯å°†å…¶äº¤ç”±èƒ½å¤Ÿè¿æ¥åˆ°ä» Youtube åˆ° Notion ç­‰ä»»ä½•æƒ³è±¡å¾—åˆ°çš„æ¥æºçš„ä¼˜ç§€å¼€æºæ•°æ®åŠ è½½å™¨å¤„ç†ã€‚

ä½œè€…è®¾è®¡çš„ä¸€ä¸ªæ–¹æ¡ˆï¼Œä»¥åŠæ–‡ä¸­æ¥ä¸‹æ¥çš„æ‰€æœ‰æ–¹æ¡ˆ

æ ‡å‡† RAG æ–¹æ³•ç®€è€Œè¨€ä¹‹ï¼Œæ˜¯è¿™æ ·çš„ï¼šä½ å°†æ–‡æœ¬åˆ†å‰²æˆå°å—ï¼Œç„¶åä½¿ç”¨æŸç§ Transformer Encoder æ¨¡å‹å°†è¿™äº›å°å—è½¬æ¢ä¸ºå‘é‡ï¼ŒæŠŠè¿™äº›å‘é‡æ±‡æ€»åˆ°ä¸€ä¸ªç´¢å¼•ä¸­ï¼Œæœ€ååˆ›å»ºä¸€ä¸ªé’ˆå¯¹å¤§è¯­è¨€æ¨¡å‹çš„æç¤ºï¼ŒæŒ‡å¯¼æ¨¡å‹æ ¹æ®æˆ‘ä»¬åœ¨æœç´¢æ­¥éª¤ä¸­æ‰¾åˆ°çš„ä¸Šä¸‹æ–‡å›ç­”ç”¨æˆ·çš„æŸ¥è¯¢ã€‚

åœ¨å®é™…è¿è¡Œä¸­ï¼Œæˆ‘ä»¬ç”¨ç›¸åŒçš„ Encoder æ¨¡å‹å°†ç”¨æˆ·çš„æŸ¥è¯¢è½¬åŒ–ä¸ºå‘é‡ï¼Œç„¶åå¯¹è¿™ä¸ªæŸ¥è¯¢å‘é‡è¿›è¡Œæœç´¢ï¼Œä¸ç´¢å¼•è¿›è¡ŒåŒ¹é…ï¼Œæ‰¾å‡ºæœ€ç›¸å…³çš„å‰ k ä¸ªç»“æœï¼Œä»æˆ‘ä»¬çš„æ•°æ®åº“ä¸­æå–ç›¸åº”çš„æ–‡æœ¬å—ï¼Œå¹¶å°†å…¶ä½œä¸ºä¸Šä¸‹æ–‡è¾“å…¥ LLM è¿›è¡Œå¤„ç†ã€‚

è¿™æ ·çš„æç¤ºå¯ä»¥æ˜¯ï¼š

ä¸€ä¸ª RAG æç¤ºçš„ä¾‹å­

æç¤ºä¼˜åŒ–æ˜¯æå‡ RAG æµç¨‹æ€§èƒ½çš„ä¸€ç§ç®€ä¾¿æœ‰æ•ˆçš„æ–¹æ³•ã€‚ä¸è¦å¿˜äº†æŸ¥é˜… OpenAI æä¾›çš„è¯¦å°½çš„æç¤ºä¼˜åŒ–æŒ‡å—ã€‚

è™½ç„¶ OpenAI æ˜¯å¤§è¯­è¨€æ¨¡å‹æä¾›å•†çš„å¸‚åœºé¢†å¤´ç¾Šï¼Œä½†è¿˜æœ‰å…¶ä»–ä¸å°‘é€‰æ‹©ï¼Œä¾‹å¦‚ Anthropic çš„ Claudeï¼ŒMistral æ¨å‡ºçš„æœ€æ–°æ½®æµçš„å°å‹ä½†åŠŸèƒ½å¼ºå¤§çš„æ¨¡å‹ Mixtralï¼ŒMicrosoft çš„ Phi-2ï¼Œä»¥åŠå¦‚ Llama2ï¼ŒOpenLLaMAï¼ŒFalcon ç­‰ä¼—å¤šå¼€æºé€‰æ‹©ï¼Œä¾›ä½ ä¸º RAG æµç¨‹é€‰ç”¨ä¸åŒçš„ã€Œå¤§è„‘ã€ã€‚

### 03. Advanced RAG

Now we'll dive into the overview of the advanced RAG techniques.

Here is a scheme depicting core steps and algorithms involved.

Some logic loops and complex multistep agentic behaviours are omitted to keep the scheme readable.

Some key components of an advanced RAG architecture. It's more a choice of available instruments than a blueprint.

The green elements on the scheme are the core RAG techniques discussed further, the blue ones are texts. Not all the advanced RAG ideas are easily visualised on a single scheme, for example, various context enlarging approaches are omitted â€” we'll dive into that on the way.

é«˜çº§ RAG æŠ€æœ¯æ¦‚è§ˆ

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¯¦ç»†æ¢è®¨é«˜çº§ RAG æŠ€æœ¯ã€‚

ä¸‹é¢è¿™å¹…å›¾å±•ç¤ºäº†æ¶‰åŠçš„æ ¸å¿ƒæ­¥éª¤å’Œç®—æ³•ã€‚

ä¸ºäº†ä½¿å›¾è§£æ¸…æ™°æ˜“æ‡‚ï¼Œæˆ‘ä»¬çœç•¥äº†ä¸€äº›é€»è¾‘å¾ªç¯å’Œå¤æ‚çš„å¤šæ­¥éª¤æ™ºèƒ½ä½“è¡Œä¸ºã€‚

è¿™æ˜¯é«˜çº§ RAG æ¶æ„ä¸­çš„ä¸€äº›å…³é”®ç»„æˆéƒ¨åˆ†ï¼Œæ›´åƒæ˜¯ä¸€å¥—å¯é€‰å·¥å…·çš„é›†åˆï¼Œè€Œä¸æ˜¯å›ºå®šçš„è®¾è®¡è“å›¾ã€‚

å›¾ä¸­çš„ç»¿è‰²å…ƒç´ ä»£è¡¨æˆ‘ä»¬å°†è¿›ä¸€æ­¥æ¢è®¨çš„æ ¸å¿ƒ RAG æŠ€æœ¯ï¼Œè“è‰²éƒ¨åˆ†åˆ™æ˜¯ç›¸å…³æ–‡æœ¬ã€‚å¹¶ä¸æ˜¯æ‰€æœ‰é«˜çº§ RAG æ¦‚å¿µéƒ½èƒ½åœ¨ä¸€å¼ å›¾ä¸Šå±•ç¤ºå¾—ä¸€ç›®äº†ç„¶ï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬çœç•¥äº†ä¸€äº›æ‰©å±•ä¸Šä¸‹æ–‡çš„æ–¹æ³• â€”â€” æˆ‘ä»¬ä¼šåœ¨åç»­çš„è®¨è®ºä¸­é€æ­¥æ·±å…¥è¿™äº›è¯é¢˜ã€‚

#### 3.1 Chunking & vectorisation

First of all we want to create an index of vectors, representing our document contents and then in the runtime to search for the least cosine distance between all these vectors and the query vector which corresponds to the closest semantic meaning.

3.1 åˆ†å— (Chunking) & å‘é‡åŒ– (Vectorisation)

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸ºæ–‡æ¡£å†…å®¹åˆ›å»ºä¸€ä¸ªå‘é‡ç´¢å¼•ï¼Œç„¶ååœ¨å®æ—¶è¿è¡Œä¸­ï¼Œå¯»æ‰¾è¿™äº›å‘é‡ä¸æŸ¥è¯¢å‘é‡ä¹‹é—´æœ€å°çš„ä½™å¼¦è·ç¦»ï¼Œè¿™æ ·å¯ä»¥æ‰¾åˆ°ä¸æŸ¥è¯¢æœ€æ¥è¿‘çš„è¯­ä¹‰å«ä¹‰ã€‚

1.1 Chunking

Transformer models have fixed input sequence length and even if the input context window is large, the vector of a sentence or a few better represents their semantic meaning than a vector averaged over a few pages of text (depends on the model too, but true in general), so chunk your data â€” split the initial documents in chunks of some size without loosing their meaning (splitting your text in sentences or in paragraphs, not cutting a single sentence in two parts). There are various text splitter implementations capable of this task.

The size of the chunk is a parameter to think of â€” it depends on the embedding model you use and its capacity in tokens, standard transformer Encoder models like BERT-based Sentence Transformers take 512 tokens at most, OpenAI ada-002 is capable of handling longer sequences like 8191 tokens, but the compromise here is enough context for the LLM to reason upon vs specific enough text embedding in order to efficiently execute search upon. Here you can find a research illustrating chunk size selection concerns. In LlamaIndex this is covered by the NodeParser class with some advanced options as defining your own text splitter, metadata, nodes / chunks relations, etc.

[Chunking Strategies for LLM Applications | Pinecone](https://www.pinecone.io/learn/chunking-strategies/)

[Node Parser - LlamaIndex ğŸ¦™ 0.9.32](https://docs.llamaindex.ai/en/stable/api_reference/service_context/node_parser.html)

1.1 åˆ†å—ï¼ˆChunkingï¼‰

Transformer æ¨¡å‹çš„è¾“å…¥åºåˆ—é•¿åº¦æ˜¯å›ºå®šçš„ã€‚å³ä¾¿è¾“å…¥çš„ä¸Šä¸‹æ–‡çª—å£å¾ˆå¤§ï¼Œç›¸æ¯”äºå‡ é¡µæ–‡æœ¬çš„å¹³å‡å‘é‡ï¼Œä¸€å¥è¯æˆ–å‡ å¥è¯çš„å‘é‡æ›´èƒ½å‡†ç¡®åœ°ä»£è¡¨å…¶è¯­ä¹‰å«ä¹‰ï¼ˆè¿™ä¹Ÿå–å†³äºå…·ä½“çš„æ¨¡å‹ï¼Œä½†ä¸€èˆ¬éƒ½æ˜¯è¿™æ ·ï¼‰ã€‚å› æ­¤ï¼Œä½ éœ€è¦å°†æ•°æ®è¿›è¡Œåˆ†å— â€”â€” æŠŠåˆå§‹æ–‡æ¡£åˆ†æˆä¸€äº›å—ï¼Œæ¯å—å¤§å°é€‚ä¸­ï¼Œæ—¢ä¸ä¸¢å¤±åŸæœ‰çš„å«ä¹‰ï¼ˆæ¯”å¦‚ï¼Œå¯ä»¥æŒ‰å¥å­æˆ–æ®µè½åˆ†å‰²æ–‡æœ¬ï¼Œè€Œä¸æ˜¯å°†å•ä¸ªå¥å­åˆ‡æˆä¸¤åŠï¼‰ã€‚æœ‰è®¸å¤šæ–‡æœ¬åˆ†å‰²å·¥å…·èƒ½å¤Ÿå®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚

å—çš„å¤§å°æ˜¯ä¸€ä¸ªéœ€è¦æ·±æ€ç†Ÿè™‘çš„å‚æ•° â€”â€” å®ƒå–å†³äºä½ æ‰€ä½¿ç”¨çš„åµŒå…¥æ¨¡å‹ä»¥åŠå®ƒåœ¨ tokens æ–¹é¢çš„å®¹é‡ã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†çš„ Transformer ç¼–ç æ¨¡å‹ï¼Œå¦‚åŸºäº BERT çš„å¥å­ Transformers æœ€å¤šå¯ä»¥å¤„ç† 512 ä¸ª tokensï¼Œè€Œ OpenAI ada-002 èƒ½å¤Ÿå¤„ç†æ›´é•¿çš„åºåˆ—ï¼Œä¾‹å¦‚ 8191 ä¸ª tokensï¼Œä½†è¿™é‡Œéœ€è¦æƒè¡¡çš„æ˜¯ï¼Œä¸º LLM æä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡è¿›è¡Œæ¨ç†ï¼ŒåŒæ—¶ç¡®ä¿æ–‡æœ¬åµŒå…¥è¶³å¤Ÿå…·ä½“ï¼Œä»¥ä¾¿æœ‰æ•ˆåœ°æ‰§è¡Œæœç´¢ã€‚åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥æ‰¾åˆ°ä¸€é¡¹ç ”ç©¶ï¼Œå±•ç¤ºäº†é€‰æ‹©å—å¤§å°æ—¶çš„å„ç§è€ƒè™‘å› ç´ ã€‚åœ¨ LlamaIndex ä¸­ï¼Œè¿™ä¸€é—®é¢˜é€šè¿‡ NodeParser ç±»å¾—åˆ°è§£å†³ï¼Œå®ƒæä¾›äº†å®šä¹‰è‡ªå·±çš„æ–‡æœ¬åˆ†å‰²å™¨ã€å…ƒæ•°æ®ã€èŠ‚ç‚¹/å—å…³ç³»ç­‰é«˜çº§é€‰é¡¹ã€‚

1.2 Vectorisation

The next step is to choose a model to embed our chunks â€” there are quite some options, I go with the search optimised models like bge-large or E5 embeddings family â€” just check the MTEB leaderboard for the latest updates.

For an end2end implementation of the chunking & vectorisation step check an example of a full data ingestion pipeline in LlamaIndex.

[MTEB Leaderboard - a Hugging Face Space by mteb](https://huggingface.co/spaces/mteb/leaderboard)

ç›®å‰æ’åç¬¬ä¸€çš„æ˜¯ e5-mistral-7b-instructã€‚ï¼ˆ2024-01-17ï¼‰

[intfloat/e5-mistral-7b-instruct Â· Hugging Face](https://huggingface.co/intfloat/e5-mistral-7b-instruct)

[intfloat/multilingual-e5-large Â· Hugging Face](https://huggingface.co/intfloat/multilingual-e5-large)

[BAAI/bge-large-en-v1.5 Â· Hugging Face](https://huggingface.co/BAAI/bge-large-en-v1.5)

bge-large-en-v1.5 ä¸‹è½½é‡å¾ˆå¤§ï¼Œä¸”æ”¯æŒä¸­æ–‡ï¼Œç”¨å®ƒå–ä»£ä¹‹å‰çš„ m3e-base è¯•è¯•ã€‚çœ‹æ¨¡å‹ä»‹ç»ï¼Œè¯„åˆ†æ¯” m3e-base é«˜ä¸å°‘ã€‚ï¼ˆ2024-01-17ï¼‰

[Ingestion Pipeline - LlamaIndex ğŸ¦™ 0.9.31](https://docs.llamaindex.ai/en/latest/module_guides/loading/ingestion_pipeline/root.html#)

1.2 å‘é‡åŒ– (Vectorisation)

ä¸‹ä¸€æ­¥æ˜¯é€‰æ‹©ä¸€ä¸ªæ¨¡å‹æ¥åµŒå…¥æˆ‘ä»¬çš„å— â€”â€” è¿™é‡Œæœ‰å¾ˆå¤šé€‰æ‹©ã€‚æˆ‘ä¸ªäººå€¾å‘äºä½¿ç”¨ä¸ºæœç´¢ä¼˜åŒ–çš„æ¨¡å‹ï¼Œå¦‚ bge-large æˆ– E5 åµŒå…¥æ¨¡å‹ã€‚ä½ å¯ä»¥æŸ¥çœ‹ MTEB æ’è¡Œæ¦œäº†è§£æœ€æ–°çš„æ¨¡å‹æ›´æ–°æƒ…å†µã€‚

æƒ³äº†è§£å¦‚ä½•åœ¨ç«¯åˆ°ç«¯ç³»ç»Ÿä¸­å®ç°å—å¤„ç†å’Œå‘é‡åŒ–æ­¥éª¤å—ï¼Ÿä¸å¦¨å‚è€ƒ LlamaIndex ä¸­å®Œæ•´æ•°æ®æ‘„å–ç®¡é“çš„ç¤ºä¾‹ã€‚

#### 3.2 Search index

2.1 Vector store index

In this scheme and everywhere further in the text I omit the Encoder block and send our query straight to the index for the scheme simplicity. The query always gets vectorised first of course. Same with the top k cunks â€” index retrieves top k vectors, not chunks, but I replace them with chunks as fetching them is a trivial step.

The crucial part of the RAG pipeline is the search index, storing your vectorised content we got in the previous step. The most naive implementation uses a flat index â€” a brute force distance calculation between the query vector and all the chunks' vectors.

A proper search index, optimised for efficient retrieval on 10000+ elements scales is a vector index like faiss, nmslib or annoy, using some Approximate Nearest Neighbours implementation like clustring, trees or HNSW algorithm.

There are also managed solutions like OpenSearch or ElasticSearch and vector databases, taking care of the data ingestion pipeline described in step 1 under the hood, like Pinecone, Weaviate or Chroma.

Depending on your index choice, data and search needs you can also store metadata along with vectors and then use metadata filters to search for information within some dates or sources for example.

LlamaIndex supports lots of vector store indices but there are also other simpler index implementations supported like list index, tree index, and keyword table index â€” we'll talk about the latter in the Fusion retrieval part.

[Using Vector Stores - LlamaIndex ğŸ¦™ 0.9.31](https://docs.llamaindex.ai/en/latest/community/integrations/vector_stores.html#)

2 æœç´¢ç´¢å¼•

2.1 å‘é‡å­˜å‚¨ç´¢å¼•

åœ¨è¿™ä¸ªæ¶æ„åŠåç»­å†…å®¹ä¸­ï¼Œä¸ºäº†ç®€åŒ–æè¿°ï¼Œæˆ‘ä»¬ä¸è€ƒè™‘ç¼–ç å™¨éƒ¨åˆ†ï¼Œç›´æ¥æŠŠæŸ¥è¯¢å†…å®¹é€å…¥ç´¢å¼•ã€‚æ˜¾ç„¶ï¼ŒæŸ¥è¯¢å†…å®¹ä¼šé¦–å…ˆè¿›è¡Œå‘é‡åŒ–ã€‚ç±»ä¼¼åœ°ï¼Œå°½ç®¡ç´¢å¼•æ˜¯æ ¹æ®å‘é‡è€Œä¸æ˜¯å…·ä½“çš„å—æ¥è¿›è¡Œæ£€ç´¢çš„ï¼Œä½†æœ€ç»ˆæˆ‘ä»¬è¿˜æ˜¯ä»¥å—çš„å½¢å¼å±•ç°ç»“æœï¼Œå› ä¸ºè·å–è¿™äº›å—ç›¸å¯¹ç®€å•ã€‚

RAG ç®¡é“çš„æ ¸å¿ƒæ˜¯æœç´¢ç´¢å¼•ï¼Œå®ƒå­˜å‚¨äº†æˆ‘ä»¬åœ¨ä¸Šä¸€æ­¥éª¤ä¸­å‘é‡åŒ–çš„å†…å®¹ã€‚æœ€åŸºæœ¬çš„å®ç°æ–¹æ³•æ˜¯é‡‡ç”¨å¹³é¢ç´¢å¼•ï¼Œå³ç›´æ¥è®¡ç®—æŸ¥è¯¢å‘é‡ä¸æ‰€æœ‰å—å‘é‡ä¹‹é—´çš„è·ç¦»ã€‚

ä¸ºäº†å®ç°é«˜æ•ˆæ£€ç´¢ï¼Œä¸€ä¸ªæ›´é«˜çº§çš„æœç´¢ç´¢å¼•åº”è¯¥é‡‡ç”¨å‘é‡ç´¢å¼•ï¼Œæ¯”å¦‚ faissã€nmslib æˆ– annoyã€‚è¿™äº›å·¥å…·åŸºäºè¿‘ä¼¼æœ€è¿‘é‚»å±…ç®—æ³•ï¼Œå¦‚èšç±»ã€æ ‘ç»“æ„æˆ– HNSW ç®—æ³•ã€‚

æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€äº›æ‰˜ç®¡æœåŠ¡ï¼Œå¦‚ OpenSearchã€ElasticSearch å’Œå‘é‡æ•°æ®åº“ï¼Œå®ƒä»¬è‡ªåŠ¨å¤„ç†å‰æ–‡æåˆ°çš„æ•°æ®æ‘„å–æµç¨‹ï¼Œä¾‹å¦‚ Pineconeã€Weaviate å’Œ Chromaã€‚

æ ¹æ®æ‚¨çš„ç´¢å¼•é€‰æ‹©ã€æ•°æ®å’Œæœç´¢éœ€æ±‚ï¼Œæ‚¨è¿˜å¯ä»¥å­˜å‚¨å…ƒæ•°æ®ï¼Œå¹¶ä½¿ç”¨å…ƒæ•°æ®è¿‡æ»¤å™¨æ¥æŒ‰ç…§æ—¥æœŸæˆ–æ¥æºç­‰æ¡ä»¶è¿›è¡Œä¿¡æ¯æ£€ç´¢ã€‚

LlamaIndex æ”¯æŒå¤šç§å‘é‡å­˜å‚¨ç´¢å¼•ï¼ŒåŒæ—¶ä¹Ÿå…¼å®¹å…¶ä»–ç®€å•çš„ç´¢å¼•ç±»å‹ï¼Œå¦‚åˆ—è¡¨ç´¢å¼•ã€æ ‘ç´¢å¼•å’Œå…³é”®è¯è¡¨ç´¢å¼•ã€‚å…³äºè¿™äº›ç´¢å¼•ï¼Œæˆ‘ä»¬ä¼šåœ¨åç»­çš„èåˆæ£€ç´¢éƒ¨åˆ†è¯¦ç»†ä»‹ç»ã€‚

2.2 Hierarchical indices

In case you have many documents to retrieve from, you need to be able to efficiently search inside them, find relevant information and synthesise it in a single answer with references to the sources. An efficient way to do that in case of a large database is to create two indices â€” one composed of summaries and the other one composed of document chunks, and to search in two steps, first filtering out the relevant docs by summaries and then searching just inside this relevant group.

2.2 åˆ†å±‚ç´¢å¼•

å½“éœ€è¦ä»ä¼—å¤šæ–‡æ¡£ä¸­æ£€ç´¢ä¿¡æ¯æ—¶ï¼Œé«˜æ•ˆçš„æœç´¢ã€å‘ç°ç›¸å…³å†…å®¹å¹¶æ•´åˆæˆå«æœ‰å‚è€ƒæ¥æºçš„ç­”æ¡ˆå˜å¾—å°¤ä¸ºé‡è¦ã€‚åœ¨å¤„ç†å¤§å‹æ•°æ®åº“æ—¶ï¼Œä¸€ä¸ªé«˜æ•ˆçš„ç­–ç•¥æ˜¯æ„å»ºä¸¤ä¸ªç´¢å¼•ï¼šä¸€ä¸ªåŒ…å«æ‘˜è¦ï¼Œå¦ä¸€ä¸ªåŒ…å«æ–‡æ¡£çš„å„ä¸ªéƒ¨åˆ†ã€‚è¿™æ ·çš„æœç´¢åˆ†ä¸ºä¸¤æ­¥ï¼šé¦–å…ˆåˆ©ç”¨æ‘˜è¦æ¥ç­›é€‰å‡ºç›¸å…³æ–‡æ¡£ï¼Œç„¶ååªåœ¨è¿™ä¸ªç­›é€‰å‡ºçš„ç›¸å…³æ–‡æ¡£é›†ä¸­ç»§ç»­æ·±å…¥æœç´¢ã€‚

2.3 Hypothetical Questions and HyDE

Another approach is to ask an LLM to generate a question for each chunk and embed these questions in vectors, at runtime performing query search against this index of question vectors (replacing chunks vectors with questions vectors in our index) and then after retrieval route to original text chunks and send them as the context for the LLM to get an answer.

This approach improves search quality due to a higher semantic similarity between query and hypothetical question compared to what we'd have for an actual chunk.

There is also the reversed logic apporach called HyDE â€” you ask an LLM to generate a hypothetical response given the query and then use its vector along with the query vector to enhance search quality.

2ã€å·²ä¸‹è½½è®ºæ–‡ã€Œ2023065Precise Zero-Shot Dense Retrieval without Relevance Labelsã€å­˜å…¥ Zoteroã€‚ï¼ˆ2024-01-17ï¼‰ã€

2.3 å‡è®¾æ€§é—®é¢˜å’Œ HyDE

å¦ä¸€ç§ç­–ç•¥æ˜¯è®©å¤§è¯­è¨€æ¨¡å‹ä¸ºæ–‡æ¡£çš„æ¯ä¸ªéƒ¨åˆ†äº§ç”Ÿä¸€ä¸ªé—®é¢˜ï¼Œå¹¶æŠŠè¿™äº›é—®é¢˜è½¬æ¢æˆæ•°å­¦ä¸Šçš„å‘é‡ã€‚åœ¨å®é™…æ“ä½œä¸­ï¼Œè¿™äº›é—®é¢˜å‘é‡æ„æˆä¸€ä¸ªç´¢å¼•ï¼Œç”¨äºå¯¹ç”¨æˆ·çš„æŸ¥è¯¢è¿›è¡ŒåŒ¹é…æœç´¢ï¼ˆè¿™é‡Œæ˜¯ç”¨é—®é¢˜å‘é‡è€ŒéåŸæ–‡æ¡£çš„å†…å®¹å‘é‡æ¥æ„æˆç´¢å¼•ï¼‰ï¼Œæ£€ç´¢åˆ°ç›¸åº”é—®é¢˜åï¼Œå†é“¾æ¥å›åŸå§‹æ–‡æ¡£çš„ç›¸åº”éƒ¨åˆ†ï¼Œä½œä¸ºå¤§è¯­è¨€æ¨¡å‹æä¾›ç­”æ¡ˆçš„èƒŒæ™¯ä¿¡æ¯ã€‚

è¿™ç§æ–¹æ³•é€šè¿‡å¢å¼ºæŸ¥è¯¢ä¸å‡è®¾é—®é¢˜ä¹‹é—´çš„è¯­ä¹‰ç›¸ä¼¼æ€§ï¼Œä»è€Œæå‡äº†æœç´¢çš„ç²¾å‡†åº¦ï¼Œç›¸æ¯”ç›´æ¥ä½¿ç”¨æ–‡æ¡£å†…å®¹çš„æ–¹æ³•æ•ˆæœæ›´ä½³ã€‚

æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€ç§åå‘é€»è¾‘çš„æ–¹æ³•ï¼Œåä¸º HyDEã€‚è¿™ç§æ–¹æ³•ä¸­ï¼Œä½ ä¼šè®©å¤§è¯­è¨€æ¨¡å‹é’ˆå¯¹ä¸€ä¸ªæŸ¥è¯¢ç”Ÿæˆä¸€ä¸ªå‡è®¾æ€§çš„å›åº”ï¼Œç„¶åç»“åˆè¿™ä¸ªå›åº”çš„å‘é‡å’ŒæŸ¥è¯¢çš„å‘é‡ï¼Œå…±åŒç”¨äºæå‡æœç´¢çš„æ•ˆæœã€‚

2.4 Context enrichment

The concept here is to retrieve smaller chunks for better search quality, but add up surrounding context for LLM to reason upon.

There are two options â€” to expand context by sentences around the smaller retrieved chunk or to split documents recursively into a number of larger parent chunks, containing smaller child chunks.

2.4 è¯­å¢ƒå¢å¼º

æœ¬èŠ‚çš„æ ¸å¿ƒç†å¿µæ˜¯é€šè¿‡æ£€ç´¢æ›´å°çš„ä¿¡æ¯å—æ¥æé«˜æœç´¢è´¨é‡ï¼ŒåŒæ—¶ä¸ºå¤§è¯­è¨€æ¨¡å‹å¢åŠ æ›´å¤šå‘¨å›´è¯­å¢ƒä»¥ä¾¿å…¶è¿›è¡Œæ¨ç†ã€‚

æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ³•ï¼šä¸€æ˜¯é€šè¿‡å¢åŠ æ£€ç´¢åˆ°çš„å°å—å‘¨å›´çš„å¥å­æ¥æ‰©å¤§è¯­å¢ƒï¼›äºŒæ˜¯é€’å½’åœ°å°†æ–‡æ¡£åˆ†å‰²æˆåŒ…å«å°å—çš„å¤§å—ã€‚

2.4.1 Sentence Window Retrieval

In this scheme each sentence in a document is embedded separately which provides great accuracy of the query to context cosine distance search.

In order to better reason upon the found context after fetching the most relevant single sentence we extend the context window by k sentences before and after the retrieved sentence and then send this extended context to LLM.

The green part is the sentence embedding found while search in index, and the whole black + green paragraph is fed to the LLM to enlarge its context while reasoning upon the provided query

[Metadata Replacement + Node Sentence Window - LlamaIndex ğŸ¦™ 0.9.32](https://docs.llamaindex.ai/en/stable/examples/node_postprocessor/MetadataReplacementDemo.html)

2.4.1 å¥å­çª—å£æ£€ç´¢æ³•

åœ¨è¿™ç§æ–¹æ³•ä¸­ï¼Œæ–‡æ¡£çš„æ¯ä¸ªå¥å­éƒ½è¢«å•ç‹¬ç¼–ç ï¼Œè¿™æ ·å¯ä»¥æå¤§æé«˜æŸ¥è¯¢ä¸è¯­å¢ƒä¹‹é—´çš„ä½™å¼¦è·ç¦»æœç´¢çš„å‡†ç¡®æ€§ã€‚

ä¸ºäº†æ›´å¥½åœ°åˆ†ææ‰¾åˆ°çš„è¯­å¢ƒï¼Œæˆ‘ä»¬åœ¨æ£€ç´¢åˆ°çš„æœ€ç›¸å…³å•å¥ä¹‹å‰åå„æ‰©å±• k ä¸ªå¥å­ï¼Œç„¶åæŠŠè¿™ä¸ªæ‰©å±•åçš„è¯­å¢ƒé€ç»™ LLM è¿›è¡Œæ¨ç†ã€‚

å›¾ä¸­ç»¿è‰²éƒ¨åˆ†ä»£è¡¨åœ¨ç´¢å¼•æœç´¢ä¸­æ‰¾åˆ°çš„å¥å­ç¼–ç ï¼Œè€Œæ•´ä¸ªé»‘è‰²å’Œç»¿è‰²çš„æ®µè½åˆ™æ˜¯æä¾›ç»™ LLM ä»¥æ‰©å¤§å…¶æ¨ç†è¯­å¢ƒçš„å†…å®¹ã€‚

2.4.2 Auto-merging Retriever (aka Parent Document Retriever)

The idea here is pretty much similar to Sentence Window Retriever â€” to search for more granular pieces of information and then to extend the context window before feeding said context to an LLM for reasoning. Documents are split into smaller child chunks referring to larger parent chunks.

Documents are splitted into an hierarchy of chunks and then the smallest leaf chunks are sent to index. At the retrieval time we retrieve k leaf chunks, and if there is n chunks referring to the same parent chunk, we replace them with this parent chunk and send it to LLM for answer generation.

Fetch smaller chunks during retrieval first, then if more than n chunks in top k retrieved chunks are linked to the same parent node (larger chunk), we replace the context fed to the LLM by this parent node â€” works like auto merging a few retrieved chunks into a larger parent chunk, hence the method name. Just to note â€” search is performed just within the child nodes index. Check the LlamaIndex tutorial on Recursive Retriever + Node References for a deeper dive.

[Auto Merging Retriever - LlamaIndex ğŸ¦™ 0.9.31](https://docs.llamaindex.ai/en/latest/examples/retrievers/auto_merging_retriever.html#)

2.4.2 è‡ªåŠ¨åˆå¹¶æ£€ç´¢æ³• ï¼ˆä¹Ÿç§°ä¸ºçˆ¶æ–‡æ¡£æ£€ç´¢æ³•)

è¿™é‡Œçš„æ€è·¯ä¸å¥å­çª—å£æ£€ç´¢æ³•ç±»ä¼¼ â€”â€” æœç´¢æ›´ç²¾ç»†çš„ä¿¡æ¯ç‰‡æ®µï¼Œç„¶ååœ¨å°†è¿™äº›å†…å®¹é€ç»™ LLM è¿›è¡Œæ¨ç†å‰æ‰©å¤§è¯­å¢ƒçª—å£ã€‚æ–‡æ¡£è¢«åˆ†å‰²æˆå°çš„å­å—ï¼Œè¿™äº›å­å—åˆä¸æ›´å¤§çš„çˆ¶å—ç›¸å…³è”ã€‚

æ–‡æ¡£è¢«åˆ†å‰²æˆå±‚æ¬¡åŒ–çš„å—ç»“æ„ï¼Œæœ€å°çš„å¶å­å—è¢«é€è‡³ç´¢å¼•ã€‚åœ¨æ£€ç´¢æ—¶ï¼Œæˆ‘ä»¬ä¼šæ‰¾å‡º k ä¸ªå¶å­å—ï¼Œå¦‚æœå­˜åœ¨ n ä¸ªå—éƒ½æŒ‡å‘åŒä¸€çˆ¶å—ï¼Œæˆ‘ä»¬å°±ç”¨è¿™ä¸ªçˆ¶å—æ›¿æ¢å®ƒä»¬ï¼Œå¹¶æŠŠå®ƒé€ç»™ LLM ç”¨äºç”Ÿæˆç­”æ¡ˆã€‚

é¦–å…ˆæ£€ç´¢è¾ƒå°çš„æ•°æ®å—ï¼Œå¦‚æœåœ¨æœ€åˆæ£€ç´¢åˆ°çš„å‰ k ä¸ªæ•°æ®å—ä¸­æœ‰è¶…è¿‡ n ä¸ªæ•°æ®å—ä¸åŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼ˆå³æ›´å¤§çš„æ•°æ®å—ï¼‰ç›¸è¿ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šç”¨è¿™ä¸ªçˆ¶èŠ‚ç‚¹æ¥æ›¿æ¢æä¾›ç»™å¤§è¯­è¨€æ¨¡å‹çš„ä¸Šä¸‹æ–‡ã€‚è¿™ä¸ªè¿‡ç¨‹ç±»ä¼¼äºè‡ªåŠ¨å°†å‡ ä¸ªæ£€ç´¢åˆ°çš„å°æ•°æ®å—åˆå¹¶æˆä¸€ä¸ªè¾ƒå¤§çš„çˆ¶æ•°æ®å—ï¼Œå› æ­¤å¾—åã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè¿™ç§æœç´¢åªåœ¨å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸­è¿›è¡Œã€‚æƒ³è¦æ·±å…¥äº†è§£ï¼Œå¯ä»¥æŸ¥é˜… LlamaIndex çš„æ•™ç¨‹ï¼Œäº†è§£é€’å½’æ£€ç´¢å™¨ + èŠ‚ç‚¹å¼•ç”¨ã€‚

2.5 Fusion retrieval or hybrid search

A relatively old idea that you could take the best from both worlds â€” keyword-based old school search â€” sparse retrieval algorithms like tf-idf or search industry standard BM25 â€” and modern semantic or vector search and combine it in one retrieval result.

The only trick here is to properly combine the retrieved results with different similarity scores â€” this problem is usually solved with the help of the Reciprocal Rank Fusion algorithm, reranking the retrieved results for the final output.

In LangChain this is implemented in the Ensemble Retriever class, combining a list of retrievers you define, for example a faiss vector index and a BM25 based retriever and using RRF for reranking.

In LlamaIndex this is done in a pretty similar fashion.

Hybrid or fusion search usually provides better retrieval results as two complementary search algorithms are combined, taking into account both semantic similarity and keyword matching between the query and the stored documents.

[tfâ€“idf - Wikipedia](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)

[Okapi BM25 - Wikipedia](https://en.wikipedia.org/wiki/Okapi_BM25)

[Ensemble Retriever | ğŸ¦œï¸ğŸ”— Langchain](https://python.langchain.com/docs/modules/data_connection/retrievers/ensemble)

[Reciprocal Rerank Fusion Retriever - LlamaIndex ğŸ¦™ 0.9.32](https://docs.llamaindex.ai/en/stable/examples/retrievers/reciprocal_rerank_fusion.html)

2.5 èåˆæ£€ç´¢æˆ–æ··åˆæœç´¢

è¿™æ˜¯ä¸€ä¸ªæ—©å·²æœ‰ä¹‹çš„æƒ³æ³•ï¼šç»“åˆä¼ ç»Ÿçš„åŸºäºå…³é”®è¯çš„æœç´¢å’Œç°ä»£çš„è¯­ä¹‰æˆ–å‘é‡æœç´¢ã€‚ä¼ ç»Ÿæœç´¢ä½¿ç”¨å¦‚ tf-idf æˆ–è¡Œä¸šæ ‡å‡†çš„ BM25 ç­‰ç¨€ç–æ£€ç´¢ç®—æ³•ï¼Œè€Œç°ä»£æœç´¢åˆ™é‡‡ç”¨è¯­ä¹‰æˆ–å‘é‡æ–¹æ³•ã€‚è¿™ä¸¤ç§æ–¹æ³•çš„ç»“åˆå°±èƒ½äº§ç”Ÿå‡ºè‰²çš„æ£€ç´¢ç»“æœã€‚

å…¶å…³é”®åœ¨äºå¦‚ä½•æ°å½“åœ°èåˆè¿™ä¸¤ç§ä¸åŒç›¸ä¼¼åº¦å¾—åˆ†çš„æ£€ç´¢ç»“æœã€‚è¿™ä¸ªé—®é¢˜é€šå¸¸é€šè¿‡äº’æƒ æ’åèåˆ (Reciprocal Rank Fusion) ç®—æ³•æ¥è§£å†³ï¼Œè¯¥ç®—æ³•èƒ½æœ‰æ•ˆåœ°å¯¹æ£€ç´¢ç»“æœè¿›è¡Œé‡æ–°æ’åºï¼Œä»¥å¾—åˆ°æœ€ç»ˆçš„è¾“å‡ºç»“æœã€‚

åœ¨ LangChain ä¸­ï¼Œè¿™ç§æ–¹æ³•æ˜¯é€šè¿‡åˆå¥æ£€ç´¢å™¨ (Ensemble Retriever) æ¥å®ç°çš„ï¼Œè¯¥ç±»å°†æ‚¨å®šä¹‰çš„å¤šä¸ªæ£€ç´¢å™¨ç»“åˆèµ·æ¥ï¼Œæ¯”å¦‚ä¸€ä¸ªåŸºäº faiss çš„å‘é‡ç´¢å¼•å’Œä¸€ä¸ªåŸºäº BM25 çš„æ£€ç´¢å™¨ï¼Œå¹¶åˆ©ç”¨ RRF ç®—æ³•è¿›è¡Œç»“æœçš„é‡æ–°æ’åºã€‚

åœ¨ LlamaIndex ä¸­ï¼Œè¿™ä¸€è¿‡ç¨‹ä¹Ÿæ˜¯ä»¥ç±»ä¼¼çš„æ–¹å¼å®ç°çš„ã€‚

æ··åˆæˆ–èåˆæœç´¢é€šå¸¸èƒ½æä¾›æ›´ä¼˜ç§€çš„æ£€ç´¢ç»“æœï¼Œå› ä¸ºå®ƒç»“åˆäº†ä¸¤ç§äº’è¡¥çš„æœç´¢ç®—æ³• â€”â€” æ—¢è€ƒè™‘äº†æŸ¥è¯¢å’Œå­˜å‚¨æ–‡æ¡£ä¹‹é—´çš„è¯­ä¹‰ç›¸ä¼¼æ€§ï¼Œä¹Ÿè€ƒè™‘äº†å…³é”®è¯åŒ¹é…ã€‚

#### 3.3 Reranking & filtering

So we got our retrieval results with any of the algorithms described above, now it is time to refine them through filtering, re-ranking or some transformation. In LlamaIndex there is a variety of available Postprocessors, filtering out results based on similarity score, keywords, metadata or reranking them with other models like an LLM,

sentence-transformer cross-encoder, Cohere reranking endpoint

or based on metadata like date recency â€” basically, all you could imagine.

This is the final step before feeding our retrieved context to LLM in order to get the resulting answer.

Now it is time to get to the more sophisticated RAG techniques like Query transformation and Routing, both involving LLMs and thus representing agentic behaviour â€” some complex logic involving LLM reasoning within our RAG pipeline.

03 é‡æ–°æ’åä¸è¿‡æ»¤

åœ¨åº”ç”¨äº†å‰è¿°çš„æ£€ç´¢ç®—æ³•åï¼Œæˆ‘ä»¬å¾—åˆ°äº†åˆæ­¥çš„æœç´¢ç»“æœã€‚ä¸‹ä¸€æ­¥æ˜¯é€šè¿‡è¿‡æ»¤ã€é‡æ–°æ’åˆ—æˆ–è½¬æ¢è¿™äº›ç»“æœæ¥è¿›ä¸€æ­¥ä¼˜åŒ–å®ƒä»¬ã€‚åœ¨ LlamaIndex ä¸­ï¼Œä½ å¯ä»¥æ‰¾åˆ°å¤šç§åå¤„ç†å™¨ï¼Œè¿™äº›å¤„ç†å™¨èƒ½å¤ŸåŸºäºç›¸ä¼¼åº¦åˆ†æ•°ã€å…³é”®è¯ã€å…ƒæ•°æ®è¿›è¡Œè¿‡æ»¤ï¼Œæˆ–è€…ä½¿ç”¨å…¶ä»–æ¨¡å‹å¦‚å¤§è¯­è¨€æ¨¡å‹ã€å¥å­-è½¬æ¢å™¨äº¤å‰ç¼–ç å™¨å’Œ Cohere çš„é‡æ–°æ’åæ¥å£æ¥é‡æ–°æ’åˆ—ç»“æœï¼Œç”šè‡³å¯ä»¥æ ¹æ®å…ƒæ•°æ®çš„æ—¥æœŸæ–°è¿‘åº¦æ¥æ“ä½œ â€”â€” åŸºæœ¬ä¸ŠåŒ…æ‹¬äº†ä½ èƒ½æƒ³åˆ°çš„æ‰€æœ‰åŠŸèƒ½ã€‚

è¿™ä¸€æ­¥æ˜¯åœ¨å°†æˆ‘ä»¬æ£€ç´¢åˆ°çš„ä¸Šä¸‹æ–‡é€å…¥å¤§è¯­è¨€æ¨¡å‹ï¼Œä»¥è·å¾—æœ€ç»ˆå›ç­”ä¹‹å‰çš„æœ€åç¯èŠ‚ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢ç´¢æ›´ä¸ºé«˜çº§çš„ RAG æŠ€æœ¯ï¼Œæ¯”å¦‚æŸ¥è¯¢è½¬æ¢å’Œè·¯ç”±ã€‚è¿™äº›æŠ€æœ¯æ¶‰åŠåˆ°å¤§è¯­è¨€æ¨¡å‹çš„ä½¿ç”¨ï¼Œä»£è¡¨äº†ä¸€ç§æ›´å¤æ‚çš„é€»è¾‘æ€ç»´ â€”â€” åœ¨ RAG æµç¨‹ä¸­èåˆäº† LLM çš„æ¨ç†èƒ½åŠ›ã€‚

#### 3.4 Query transformations

Query transformations are a family of techniques using an LLM as a reasoning engine to modify user input in order to improve retrieval quality. There are different options to do that.

Query transformation principles illustrated

If the query is complex, LLM can decompose it into several sub queries. For examle, if you ask:

â€” "What framework has more stars on Github, Langchain or LlamaIndex?",

and it is unlikely that we'll find a direct comparison in some text in our corpus so it makes sense to decompose this question in two sub-queries presupposing simpler and more concrete information retrieval:

â€” "How many stars does Langchain have on Github?"

â€” "How many stars does Llamaindex have on Github?"

They would be executed in parallel and then the retrieved context would be combined in a single prompt for LLM to synthesize a final answer to the initial query. Both libraries have this functional implemented â€” as a Multi Query Retriever in Langchain and as a Sub Question Query Engine in Llamaindex.

Step-back prompting uses LLM to generate a more general query, retrieving for which we obtain a more general or high-level context useful to ground the answer to our original query on.

Retrieval for the original query is also performed and both contexts are fed to the LLM on the final answer generation step.

Here is a LangChain implementation.

Query re-writing uses LLM to reformulate initial query in order to improve retrieval. Both LangChain and LlamaIndex have implementations, tough a bit different, I find LlamaIndex solution being more powerful here.

Reference citations

This one goes without a number as this is more an instrument than a retrieval improvement technique, although a very important one.

If we've used multiple sources to generate an answer either due to the initial query complexity (we had to execute multiple subqueries and then to combine retrieved context in one answer), or because we found relevant context for a single query in various documents, the question rises if we could accurately back reference our sources.

There are a couple of ways to do that:

Insert this referencing task into our prompt and ask LLM to mention ids of the used sources.

Match the parts of generated response to the original text chunks in our index â€” llamaindex offers an efficient fuzzy matching based solution for this case. In case you have not heard of fuzzy matching, this is an incredibly powerful string matching technique.

04 æŸ¥è¯¢å˜æ¢

æŸ¥è¯¢å˜æ¢æ˜¯åˆ©ç”¨å¤§è¯­è¨€æ¨¡å‹ä½œä¸ºæ¨ç†å¼•æ“ï¼Œå¯¹ç”¨æˆ·è¾“å…¥è¿›è¡Œè°ƒæ•´çš„ä¸€ç³»åˆ—æŠ€æœ¯ï¼Œç›®çš„æ˜¯æå‡æ£€ç´¢çš„è´¨é‡ã€‚æœ‰å¤šç§æ–¹æ³•å¯ä»¥å®ç°è¿™ä¸€ç‚¹ã€‚

æŸ¥è¯¢å˜æ¢çš„åŸç†ç¤ºæ„å›¾

å¯¹äºå¤æ‚çš„æŸ¥è¯¢ï¼Œå¤§è¯­è¨€æ¨¡å‹èƒ½å¤Ÿå°†å…¶æ‹†åˆ†ä¸ºå¤šä¸ªå­æŸ¥è¯¢ã€‚æ¯”å¦‚ï¼Œå½“ä½ é—®ï¼š

åœ¨ Github ä¸Šï¼ŒLangchain å’Œ LlamaIndex è¿™ä¸¤ä¸ªæ¡†æ¶å“ªä¸ªæ›´å—æ¬¢è¿ï¼Ÿæˆ‘ä»¬ä¸å¤ªå¯èƒ½ç›´æ¥åœ¨è¯­æ–™åº“çš„æ–‡æœ¬ä¸­æ‰¾åˆ°å®ƒä»¬çš„æ¯”è¾ƒï¼Œæ‰€ä»¥å°†è¿™ä¸ªé—®é¢˜åˆ†è§£ä¸ºä¸¤ä¸ªæ›´ç®€å•ã€å…·ä½“çš„å­æŸ¥è¯¢æ˜¯åˆç†çš„ï¼š

Langchain åœ¨ Github ä¸Šæœ‰å¤šå°‘æ˜Ÿï¼Ÿ

Llamaindex åœ¨ Github ä¸Šæœ‰å¤šå°‘æ˜Ÿï¼Ÿ

è¿™äº›å­æŸ¥è¯¢ä¼šåŒæ—¶è¿›è¡Œï¼Œæ£€ç´¢åˆ°çš„ä¿¡æ¯éšåè¢«æ±‡æ€»åˆ°ä¸€ä¸ªè¯­å¥ä¸­ï¼Œä¾›å¤§è¯­è¨€æ¨¡å‹ç»¼åˆå‡ºå¯¹åŸå§‹æŸ¥è¯¢çš„æœ€ç»ˆç­”æ¡ˆã€‚è¿™ä¸¤ä¸ªåŠŸèƒ½åˆ†åˆ«åœ¨ Langchain ä¸­ä»¥å¤šæŸ¥è¯¢æ£€ç´¢å™¨çš„å½¢å¼å’Œåœ¨ Llamaindex ä¸­ä»¥å­é—®é¢˜æŸ¥è¯¢å¼•æ“çš„å½¢å¼å®ç°ã€‚

å›æº¯æç¤ºæ˜¯æŒ‡åˆ©ç”¨å¤§è¯­è¨€æ¨¡å‹æ¥ç”Ÿæˆæ›´å¹¿æ³›çš„æŸ¥è¯¢ï¼Œä»¥æ­¤æ£€ç´¢åˆ°æ›´ä¸€èˆ¬æ€§æˆ–é«˜å±‚æ¬¡çš„ä¸Šä¸‹æ–‡ï¼Œå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°å›ç­”åŸå§‹æŸ¥è¯¢ã€‚æˆ‘ä»¬ä¸ä»…å¯¹åŸå§‹æŸ¥è¯¢è¿›è¡Œäº†æ£€ç´¢ï¼Œè¿˜å°†è¿™ä¸¤ç§ä¸Šä¸‹æ–‡éƒ½è¾“å…¥åˆ°å¤§è¯­è¨€æ¨¡å‹ä¸­ï¼Œä»¥ç”Ÿæˆæœ€ç»ˆçš„ç­”æ¡ˆã€‚è¿™æ˜¯ LangChain çš„ä¸€ä¸ªç¤ºä¾‹å®ç°ã€‚

æŸ¥è¯¢é‡å†™æ˜¯æŒ‡ä½¿ç”¨å¤§è¯­è¨€æ¨¡å‹æ¥é‡æ–°æ„é€ åˆå§‹æŸ¥è¯¢ï¼Œä»è€Œæé«˜æ£€ç´¢çš„æ•ˆæœã€‚LangChain å’Œ LlamaIndex éƒ½æä¾›äº†è¿™æ ·çš„åŠŸèƒ½ï¼Œè™½ç„¶å®ƒä»¬çš„æ–¹æ³•æœ‰æ‰€ä¸åŒï¼Œä½†æˆ‘è®¤ä¸º LlamaIndex åœ¨è¿™æ–¹é¢çš„è§£å†³æ–¹æ¡ˆæ›´ä¸ºå¼ºå¤§ã€‚

å‚è€ƒå¼•ç”¨ï¼š

è¿™éƒ¨åˆ†æ²¡æœ‰å•ç‹¬ç¼–å·ï¼Œå› ä¸ºå®ƒæ›´å¤šåœ°è¢«è§†ä¸ºä¸€ç§å·¥å…·ï¼Œè€Œéä¸€ä¸ªæ”¹è¿›æ£€ç´¢çš„æŠ€æœ¯ï¼Œä½†å®ƒåŒæ ·é‡è¦ã€‚å¦‚æœæˆ‘ä»¬åœ¨ç”Ÿæˆç­”æ¡ˆæ—¶å¼•ç”¨äº†å¤šä¸ªä¸åŒçš„æ¥æºï¼Œä¸ç®¡æ˜¯å› ä¸ºåˆæ­¥æŸ¥è¯¢çš„å¤æ‚æ€§ï¼ˆéœ€è¦æ‰§è¡Œå¤šä¸ªå­æŸ¥è¯¢å¹¶åˆå¹¶ç»“æœï¼‰ï¼Œè¿˜æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ä¸åŒæ–‡æ¡£ä¸­æ‰¾åˆ°äº†é’ˆå¯¹å•ä¸€æŸ¥è¯¢çš„ç›¸å…³ä¸Šä¸‹æ–‡ï¼Œæˆ‘ä»¬å°±ä¼šé¢ä¸´ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•èƒ½å¤Ÿå‡†ç¡®åœ°æ ‡æ³¨æˆ‘ä»¬æ‰€å¼•ç”¨çš„å„ä¸ªæ¥æºã€‚

å®ç°è¿™ä¸€ç‚¹æœ‰å‡ ç§æ–¹æ³•ï¼š

åœ¨æˆ‘ä»¬çš„æç¤ºä¸­åŠ å…¥å¼•ç”¨ä»»åŠ¡ï¼Œè¯·æ±‚å¤§è¯­è¨€æ¨¡å‹æ˜ç¡®æåŠæ‰€ç”¨æ¥æºçš„ idã€‚

å°†ç”Ÿæˆçš„ç­”æ¡ˆçš„éƒ¨åˆ†å†…å®¹ä¸æˆ‘ä»¬ç´¢å¼•ä¸­çš„åŸå§‹æ–‡æœ¬è¿›è¡ŒåŒ¹é… â€”â€” LlamaIndex æä¾›äº†ä¸€ç§é«˜æ•ˆçš„åŸºäºæ¨¡ç³ŠåŒ¹é…çš„æ–¹æ¡ˆã€‚å¦‚æœä½ ä¸ç†Ÿæ‚‰æ¨¡ç³ŠåŒ¹é…ï¼Œè¿™å…¶å®æ˜¯ä¸€ç§éå¸¸å¼ºå¤§çš„å­—ç¬¦ä¸²åŒ¹é…æŠ€æœ¯ã€‚

#### 3.5 Chat Engine

The next big thing about building a nice RAG system that can work more than once for a single query is the chat logic, taking into account the dialogue context, same as in the classic chat bots in the pre-LLM era.

This is needed to support follow up questions, anaphora, or arbitrary user commands relating to the previous dialogue context. It is solved by query compression technique, taking chat context into account along with the user query.

As always, there are several approaches to said context compression â€”

a popular and relatively simple ContextChatEngine, first retrieving context relevant to user's query and then sending it to LLM along with chat history from the memory buffer for LLM to be aware of the previous context while generating the next answer.

A bit more sophisticated case is CondensePlusContextMode â€” there in each interaction the chat history and last message are condensed into a new query, then this query goes to the index and the retrieved context is passed to the LLM along with the original user message to generate an answer.

It's important to note that there is also support for OpenAI agents based Chat Engine in LlamaIndex providing a more flexible chat mode and Langchain also supports OpenAI functional API.

An illustration of different Chat Engine types and principles

There are other Chat engine types like ReAct Agent, but let's skip to Agents themselves in section 7.

05 èŠå¤©å¼•æ“

æ„å»ºä¸€ä¸ªèƒ½å¯¹åŒä¸€æŸ¥è¯¢å¤šæ¬¡å“åº”çš„ä¼˜ç§€ RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰ç³»ç»Ÿçš„å…³é”®ä¹‹ä¸€æ˜¯èŠå¤©é€»è¾‘ï¼Œç‰¹åˆ«æ˜¯è¦è€ƒè™‘åˆ°å¯¹è¯çš„ä¸Šä¸‹æ–‡ï¼Œè¿™ä¸€ç‚¹ä¸ LLMï¼ˆå¤§è¯­è¨€æ¨¡å‹ï¼‰æ—¶ä»£ä¹‹å‰çš„ä¼ ç»ŸèŠå¤©æœºå™¨äººç±»ä¼¼ã€‚

è¿™æ˜¯ä¸ºäº†æ”¯æŒå¯¹åç»­é—®é¢˜ã€ä»£è¯æŒ‡ä»£æˆ–ä¸å…ˆå‰å¯¹è¯ä¸Šä¸‹æ–‡ç›¸å…³çš„ç”¨æˆ·æŒ‡ä»¤çš„å¤„ç†ã€‚è¿™ä¸ªé—®é¢˜é€šè¿‡è€ƒè™‘èŠå¤©ä¸Šä¸‹æ–‡çš„æŸ¥è¯¢å‹ç¼©æŠ€æœ¯æ¥è§£å†³ï¼Œå¹¶ç»“åˆäº†ç”¨æˆ·çš„æŸ¥è¯¢ã€‚

å¤„ç†è¿™ç§ä¸Šä¸‹æ–‡å‹ç¼©æœ‰å‡ ç§æ–¹æ³• â€”â€” ä¸€ä¸ªå—æ¬¢è¿ä¸”ç›¸å¯¹ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ ContextChatEngineï¼Œå®ƒé¦–å…ˆæ£€ç´¢ä¸ç”¨æˆ·æŸ¥è¯¢ç›¸å…³çš„ä¸Šä¸‹æ–‡ï¼Œç„¶åå°†å…¶ä¸æ¥è‡ªå†…å­˜ç¼“å†²åŒºçš„èŠå¤©å†å²ä¸€èµ·å‘é€ç»™å¤§è¯­è¨€æ¨¡å‹ï¼Œè®©å¤§è¯­è¨€æ¨¡å‹åœ¨ç”Ÿæˆä¸‹ä¸€æ­¥ç­”æ¡ˆæ—¶èƒ½å¤Ÿäº†è§£ä¹‹å‰çš„ä¸Šä¸‹æ–‡ã€‚

æ›´ä¸ºå¤æ‚çš„æƒ…å†µæ˜¯ CondensePlusContextMode â€”â€” åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œæ¯æ¬¡äº’åŠ¨æ—¶éƒ½å°†èŠå¤©å†å²å’Œæœ€æ–°æ¶ˆæ¯å‹ç¼©æˆä¸€ä¸ªæ–°çš„æŸ¥è¯¢ï¼Œç„¶åè¿™ä¸ªæŸ¥è¯¢è¢«å‘é€åˆ°ç´¢å¼•ä¸­ï¼Œå¹¶å°†æ£€ç´¢åˆ°çš„ä¸Šä¸‹æ–‡ä¸åŸå§‹ç”¨æˆ·æ¶ˆæ¯ä¸€èµ·ä¼ é€’ç»™å¤§è¯­è¨€æ¨¡å‹ï¼Œä»¥ç”Ÿæˆç­”æ¡ˆã€‚

å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒLlamaIndex è¿˜æ”¯æŒåŸºäº OpenAI æ™ºèƒ½ä½“çš„èŠå¤©å¼•æ“ï¼Œæä¾›äº†ä¸€ç§æ›´çµæ´»çš„èŠå¤©æ¨¡å¼ï¼Œè€Œ Langchain ä¹Ÿæ”¯æŒ OpenAI çš„åŠŸèƒ½æ€§ APIã€‚

ä¸åŒèŠå¤©å¼•æ“ç±»å‹å’Œå®ƒä»¬çš„å·¥ä½œåŸç†ç¤ºæ„å›¾

è¿˜æœ‰åƒ ReAct æ™ºèƒ½ä½“è¿™æ ·çš„å…¶ä»–èŠå¤©å¼•æ“ç±»å‹ï¼Œä½†æˆ‘ä»¬æ¥ä¸‹æ¥å°†ç›´æ¥è·³è½¬åˆ°ç¬¬ 7 èŠ‚ï¼Œè®¨è®ºæ™ºèƒ½ä½“æœ¬èº«ã€‚

#### 3.6 Query Routing

Query routing is the step of LLM-powered decision making upon what to do next given the user query â€” the options usually are to summarise, to perform search against some data index or to try a number of different routes and then to synthesise their output in a single answer.

Query routers are also used to select an index, or, broader, data store, where to send user query â€” either you have multiple sources of data, for example, a classic vector store and a graph database or a relational DB, or you have an hierarchy of indices â€” for a multi-document storage a pretty classic case would be an index of summaries and another index of document chunks vectors for example.

Defining the query router includes setting up the choices it can make.

The selection of a routing option is performed with an LLM call, returning its result in a predefined format, used to route the query to the given index, or, if we are taking of the agnatic behaviour, to sub-chains or even other agents as shown in the Multi documents agent scheme below.

Both LlamaIndex and LangChain have support for query routers.

06 æŸ¥è¯¢è·¯ç”±

æŸ¥è¯¢è·¯ç”±æ˜¯æŒ‡åœ¨æ¥æ”¶åˆ°ç”¨æˆ·çš„æŸ¥è¯¢åï¼Œç”±å¤§è¯­è¨€æ¨¡å‹å†³å®šæ¥ä¸‹æ¥çš„æ“ä½œæ­¥éª¤ â€”â€” å¸¸è§çš„åšæ³•åŒ…æ‹¬æ¦‚è¿°æŸ¥è¯¢å†…å®¹ã€å¯¹ç‰¹å®šæ•°æ®ç´¢å¼•è¿›è¡Œæœç´¢ï¼Œæˆ–å°è¯•å¤šä¸ªä¸åŒçš„å¤„ç†æ–¹æ³•ï¼Œå¹¶å°†è¿™äº›æ–¹æ³•çš„ç»“æœåˆæˆä¸€ä¸ªç­”æ¡ˆã€‚

æŸ¥è¯¢è·¯ç”±å™¨çš„å¦ä¸€ä¸ªä½œç”¨æ˜¯é€‰æ‹©æ•°æ®å­˜å‚¨ä½ç½®æ¥å¤„ç†ç”¨æˆ·æŸ¥è¯¢ã€‚è¿™äº›æ•°æ®å­˜å‚¨ä½ç½®å¯èƒ½æ˜¯å¤šæ ·çš„ï¼Œæ¯”å¦‚ä¼ ç»Ÿçš„å‘é‡å­˜å‚¨ã€å›¾å½¢æ•°æ®åº“æˆ–å…³ç³»å‹æ•°æ®åº“ï¼Œæˆ–è€…æ˜¯ä¸åŒå±‚çº§çš„ç´¢å¼•ç³»ç»Ÿã€‚åœ¨å¤„ç†å¤šæ–‡æ¡£å­˜å‚¨æ—¶ï¼Œé€šå¸¸ä¼šç”¨åˆ°æ‘˜è¦ç´¢å¼•å’Œæ–‡æ¡£å—å‘é‡ç´¢å¼•è¿™ä¸¤ç§ä¸åŒçš„ç´¢å¼•ã€‚

è®¾ç½®æŸ¥è¯¢è·¯ç”±å™¨åŒ…æ‹¬å†³å®šå®ƒå¯ä»¥åšå‡ºå“ªäº›é€‰æ‹©ã€‚

é€‰æ‹©ç‰¹å®šè·¯ç”±çš„è¿‡ç¨‹æ˜¯é€šè¿‡å¤§è¯­è¨€æ¨¡å‹æ¥å®ç°çš„ï¼Œå…¶ç»“æœæŒ‰ç…§é¢„å®šä¹‰çš„æ ¼å¼è¿”å›ï¼Œä»¥æŒ‡å¯¼æŸ¥è¯¢åˆ°è¾¾æŒ‡å®šçš„ç´¢å¼•ã€‚å¦‚æœæ˜¯æ¶‰åŠåˆ°å…³è”æ“ä½œï¼Œè¿™äº›æŸ¥è¯¢è¿˜å¯èƒ½è¢«å‘é€åˆ°å­é“¾æˆ–å…¶ä»–æ™ºèƒ½ä½“ï¼Œå¦‚ä¸‹é¢çš„å¤šæ–‡æ¡£æ™ºèƒ½ä½“æ–¹æ¡ˆæ‰€å±•ç¤ºçš„é‚£æ ·ã€‚

LlamaIndex å’Œ LangChain éƒ½æä¾›äº†å¯¹æŸ¥è¯¢è·¯ç”±å™¨çš„æ”¯æŒã€‚

#### 3.7 Agents in RAG

Agents (supported both by Langchain and LlamaIndex) have been around almost since the first LLM API has been released â€” the idea was to provide an LLM, capable of reasoning, with a set of tools and a task to be completed. The tools might include some deterministic functions like any code function or an external API or even other agents â€” this LLM chaining idea is where LangChain got its name from.

Agents are a huge thing itself and it's impossible to make a deep enough dive into the topic inside a RAG overview, so I'll just continue with the agent-based multi document retrieval case, making a short stop at the OpenAI Assistants station as it's a relatively new thing, presented at the recent OpenAI dev conference as GPTs, and working under the hood of the RAG system described below.

OpenAI Assistants basically have implemented a lot of tools needed around an LLM that we previously had in open source â€” a chat history, a knowledge storage, a document uploading interface and, maybe most important, function calling API. This latter provides capabilities to convert natural language into API calls to external tools or database queries.

In LlamaIndex there is an OpenAIAgent class marrying this advanced logic with the ChatEngine and QueryEngine classes, providing knowledge-based and context aware chatting along with the ability of multiple OpenAI functions calls in one conversation turn, which really brings the smart agentic behaviour.

Let's take a look at the Multi-Document Agents scheme â€” a pretty sophisticated setting, involving initialisation of an agent (OpenAIAgent) upon each document, capable of doc summarisation and the classic QA mechanics, and a top agent, responsible for queries routing to doc agents and for the final answer synthesis.

Each document agent has two tools â€” a vector store index and a summary index, and based on the routed query it decides which one to use.

And for the top agent, all document agents are tools respectfully.

This scheme illustrates an advanced RAG architecture with a lot of routing decisions made by each involved agent. The benefit of such approach is the ability to compare different solutions or entities, described in different documents and their summaries along with the classic single doc summarisation and QA mechanics â€” this basically covers the most frequent chat-with-collection-of-docs usecases.

A scheme illustrating multi document agents, involving both query routing and agentic behavior patterns.

The drawback of such a complex scheme can be guessed from the picture â€” it's a bit slow due to multiple back and forth iterations with the LLMs inside our agents. Just in case, an LLM call is always the longest operation in a RAG pipeline â€” search is optimised for speed by design. So for a large multi document storage I'd recommed to think of some simplifications to this scheme making it scalable.

07 RAG ä¸­çš„ AI æ™ºèƒ½ä½“

AI æ™ºèƒ½ä½“ï¼ˆå¾—åˆ°äº† Langchain å’Œ LlamaIndex çš„æ”¯æŒï¼‰å‡ ä¹ä»ç¬¬ä¸€ä¸ªå¤§è¯­è¨€æ¨¡å‹ API å‘å¸ƒä¹‹åˆå°±å·²ç»å‡ºç°äº† â€”â€” è¿™ä¸ªæ„æƒ³æ—¨åœ¨èµ‹äºˆä¸€ä¸ªå…·å¤‡æ¨ç†èƒ½åŠ›çš„å¤§è¯­è¨€æ¨¡å‹ï¼Œé…å¤‡å„ç§å·¥å…·å’Œä¸€ä¸ªç‰¹å®šçš„ä»»åŠ¡ã€‚è¿™äº›å·¥å…·å¯èƒ½åŒ…æ‹¬è¯¸å¦‚ä»£ç åŠŸèƒ½ã€å¤–éƒ¨ API æˆ–å…¶ä»–æ™ºèƒ½ä½“ç­‰ç¡®å®šæ€§åŠŸèƒ½ â€”â€” LangChain æ­£æ˜¯ç”±è¿™ç§å¤§è¯­è¨€æ¨¡å‹é“¾æ¥çš„ç†å¿µå¾—åã€‚

æ™ºèƒ½ä½“æœ¬èº«éå¸¸å¤æ‚ï¼Œè€Œä¸”ä¸å¯èƒ½åœ¨ä¸€ä¸ª RAG æ¦‚è§ˆæ–‡ç« ä¸­å¯¹å®ƒè¿›è¡Œæ·±å…¥æ¢è®¨ã€‚å› æ­¤ï¼Œæˆ‘å°†ç»§ç»­ä»‹ç»åŸºäºæ™ºèƒ½ä½“çš„å¤šæ–‡æ¡£æ£€ç´¢æ¡ˆä¾‹ï¼Œå¹¶ç®€è¦æåŠ OpenAI åŠ©æ‰‹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªç›¸å¯¹è¾ƒæ–°çš„æ¦‚å¿µï¼Œåœ¨æœ€è¿‘çš„ OpenAI å¼€å‘è€…å¤§ä¼šä¸Šä½œä¸º GPTs å‘ˆç°ï¼Œå¹¶åœ¨ä¸‹æ–‡å°†è¦ä»‹ç»çš„ RAG ç³»ç»Ÿä¸­å‘æŒ¥ä½œç”¨ã€‚

OpenAI åŠ©æ‰‹åŸºæœ¬ä¸Šæ•´åˆäº†æˆ‘ä»¬ä»¥å‰åœ¨å¼€æºé¢†åŸŸçœ‹åˆ°çš„è®¸å¤šå›´ç»•å¤§è¯­è¨€æ¨¡å‹çš„å·¥å…· â€”â€” å¦‚èŠå¤©å†å²ã€çŸ¥è¯†å­˜å‚¨ã€æ–‡æ¡£ä¸Šä¼ ç•Œé¢ï¼Œå°¤å…¶æ˜¯å‡½æ•°è°ƒç”¨ APIã€‚è¿™ä¸€åŠŸèƒ½å¯ä»¥å°†è‡ªç„¶è¯­è¨€æŒ‡ä»¤è½¬æ¢ä¸ºå¯¹å¤–éƒ¨å·¥å…·æˆ–æ•°æ®åº“çš„ API è°ƒç”¨ã€‚

åœ¨ LlamaIndex ä¸­ï¼ŒOpenAIAgent ç±»å°†è¿™ç§å…ˆè¿›çš„é€»è¾‘ä¸ ChatEngine å’Œ QueryEngine ç±»ç»“åˆåœ¨ä¸€èµ·ï¼Œå®ç°äº†åŸºäºçŸ¥è¯†å’Œä¸Šä¸‹æ–‡çš„æ™ºèƒ½èŠå¤©ï¼Œä»¥åŠåœ¨å•æ¬¡å¯¹è¯ä¸­è°ƒç”¨å¤šä¸ª OpenAI åŠŸèƒ½çš„èƒ½åŠ›ï¼Œä»è€ŒçœŸæ­£å®ç°äº†æ™ºèƒ½çš„ä»£ç†è¡Œä¸ºã€‚

è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å¤šæ–‡æ¡£æ™ºèƒ½ä½“çš„æ–¹æ¡ˆ â€”â€” è¿™æ˜¯ä¸€ä¸ªé¢‡ä¸ºå¤æ‚çš„é…ç½®ï¼Œæ¶‰åŠåˆ°åœ¨æ¯ä¸ªæ–‡æ¡£ä¸Šåˆå§‹åŒ–ä¸€ä¸ªæ™ºèƒ½ä½“ï¼ˆOpenAIAgentï¼‰ï¼Œè¯¥æ™ºèƒ½ä½“èƒ½è¿›è¡Œæ–‡æ¡£æ‘˜è¦åˆ¶ä½œå’Œä¼ ç»Ÿé—®ç­”æœºåˆ¶çš„æ“ä½œï¼Œè¿˜æœ‰ä¸€ä¸ªé¡¶å±‚æ™ºèƒ½ä½“ï¼Œè´Ÿè´£å°†æŸ¥è¯¢åˆ†é…åˆ°å„ä¸ªæ–‡æ¡£æ™ºèƒ½ä½“ï¼Œå¹¶ç»¼åˆå½¢æˆæœ€ç»ˆçš„ç­”æ¡ˆã€‚

æ¯ä¸ªæ–‡æ¡£æ™ºèƒ½ä½“é…å¤‡äº†ä¸¤ç§å·¥å…· â€”â€” å‘é‡å­˜å‚¨ç´¢å¼•å’Œæ‘˜è¦ç´¢å¼•ã€‚å®ƒä¼šæ ¹æ®è¢«åˆ†é…çš„æŸ¥è¯¢æ¥å†³å®šä½¿ç”¨å“ªä¸€ä¸ªå·¥å…·ã€‚å¯¹é¡¶å±‚æ™ºèƒ½ä½“è€Œè¨€ï¼Œæ‰€æœ‰çš„æ–‡æ¡£æ™ºèƒ½ä½“éƒ½æ˜¯å…¶å·¥å…·ã€‚

è¿™ä¸ªæ–¹æ¡ˆå±•ç¤ºäº†ä¸€ç§é«˜çº§ RAG æ¶æ„ï¼Œå…¶ä¸­æ¯ä¸ªå‚ä¸çš„æ™ºèƒ½ä½“éƒ½éœ€è¦åšå‡ºä¼—å¤šçš„è·¯ç”±å†³ç­–ã€‚è¿™ç§æ–¹æ³•çš„ä¼˜åŠ¿åœ¨äºï¼Œå®ƒå¯ä»¥å¯¹æè¿°äºä¸åŒæ–‡æ¡£åŠå…¶æ‘˜è¦ä¸­çš„ä¸åŒè§£å†³æ–¹æ¡ˆæˆ–å®ä½“è¿›è¡Œæ¯”è¾ƒï¼ŒåŒæ—¶è¿˜åŒ…æ‹¬äº†ä¼ ç»Ÿçš„å•æ–‡æ¡£æ‘˜è¦åˆ¶ä½œå’Œé—®ç­”æœºåˆ¶ â€”â€” è¿™å¤§è‡´æ¶µç›–äº†ä¸æ–‡æ¡£é›†åˆäº¤äº’çš„å¸¸è§ç”¨ä¾‹ã€‚

å›¾ç¤ºå±•ç¤ºäº†æ¶‰åŠæŸ¥è¯¢è·¯ç”±å’Œæ™ºèƒ½ä½“è¡Œä¸ºæ¨¡å¼çš„å¤šæ–‡æ¡£æ™ºèƒ½ä½“æ–¹æ¡ˆã€‚

è¿™ç§å¤æ‚é…ç½®çš„ç¼ºç‚¹å¯ä»¥é€šè¿‡å›¾ç‰‡ç†è§£ â€”â€” ç”±äºéœ€è¦åœ¨æ™ºèƒ½ä½“å†…éƒ¨çš„å¤§è¯­è¨€æ¨¡å‹ä¹‹é—´è¿›è¡Œå¤šæ¬¡å¾€è¿”è¿­ä»£ï¼Œå…¶è¿è¡Œé€Ÿåº¦è¾ƒæ…¢ã€‚é¡ºä¾¿ä¸€æï¼ŒLLM è°ƒç”¨é€šå¸¸æ˜¯ RAG ç®¡é“ä¸­è€—æ—¶æœ€é•¿çš„æ“ä½œï¼Œè€Œæœç´¢åˆ™æ˜¯å‡ºäºè®¾è®¡è€ƒè™‘è€Œä¼˜åŒ–äº†é€Ÿåº¦ã€‚å› æ­¤ï¼Œå¯¹äºå¤§å‹çš„å¤šæ–‡æ¡£å­˜å‚¨ï¼Œæˆ‘å»ºè®®è€ƒè™‘å¯¹æ­¤æ–¹æ¡ˆè¿›è¡Œç®€åŒ–ï¼Œä»¥ä¾¿å®ç°æ‰©å±•ã€‚

#### 3.8 Response synthesiser

This is the final step of any RAG pipeline â€” generate an answer based on all the context we carefully retrieved and on the initial user query.

The simplest approach would be just to concatenate and feed all the fetched context (above some relevance threshold) along with the query to an LLM at once.

But, as always, there are other more sophisticated options involving multiple LLM calls to refine retrieved context and generate a better answer.

The main approaches to response synthesis are:

1. iteratively refine the answer by sending retrieved context to LLM chunk by chunk

2. summarise the retrieved context to fit into the prompt

3. generate multiple answers based on different context chunks and then to concatenate or summarise them.

For more details please check the Response synthesizer module docs.

08 å“åº”åˆæˆé˜¶æ®µ

è¿™æ˜¯ä»»ä½• RAG æµç¨‹çš„æœ€ç»ˆæ­¥éª¤ â€”â€” åŸºäºæˆ‘ä»¬ç²¾å¿ƒæ£€ç´¢çš„æ‰€æœ‰ä¸Šä¸‹æ–‡å’Œç”¨æˆ·çš„åˆå§‹æŸ¥è¯¢æ¥ç”Ÿæˆç­”æ¡ˆã€‚æœ€ç®€å•çš„æ–¹å¼æ˜¯å°†æ‰€æœ‰é«˜ç›¸å…³æ€§çš„æ£€ç´¢ä¸Šä¸‹æ–‡å’ŒæŸ¥è¯¢ä¸€èµ·ç›´æ¥è¾“å…¥åˆ°ä¸€ä¸ªå¤§è¯­è¨€æ¨¡å‹ (å¤§è¯­è¨€æ¨¡å‹) ä¸­ã€‚ç„¶è€Œï¼Œè¿˜æœ‰å…¶ä»–æ›´ä¸ºå¤æ‚çš„æ–¹æ³•ï¼Œä¾‹å¦‚é€šè¿‡å¤šæ¬¡è°ƒç”¨å¤§è¯­è¨€æ¨¡å‹æ¥ç²¾ç»†åŒ–æ£€ç´¢çš„ä¸Šä¸‹æ–‡ï¼Œä»è€Œå¾—å‡ºæ›´ä¼˜çš„ç­”æ¡ˆã€‚

å“åº”åˆæˆçš„ä¸»è¦æ–¹æ³•åŒ…æ‹¬ï¼š

1ã€é€šè¿‡é€å—å‘é€æ£€ç´¢çš„ä¸Šä¸‹æ–‡åˆ°å¤§è¯­è¨€æ¨¡å‹ï¼Œä»¥é€æ­¥ä¼˜åŒ–ç­”æ¡ˆã€‚

2ã€æ¦‚æ‹¬æ£€ç´¢çš„ä¸Šä¸‹æ–‡ï¼Œä½¿å…¶é€‚åº”æç¤ºæ¡ä»¶ã€‚

3ã€æ ¹æ®ä¸åŒçš„ä¸Šä¸‹æ–‡å—ç”Ÿæˆå¤šä¸ªç­”æ¡ˆï¼Œç„¶åå°†å®ƒä»¬æ•´åˆæˆ–æ¦‚æ‹¬ã€‚æ›´å¤šè¯¦æƒ…è¯·å‚é˜…å“åº”åˆæˆå™¨æ¨¡å—æ–‡æ¡£ã€‚

### 04. Encoder and LLM fine-tuning

This approach involves fine-tuning of some of the two DL models involved in our RAG pipeline â€” either the Transformer Encoder, resposible for embeddings quality and thus context retrieval quality or an LLM, responsible for the best usage of the provided context to answer user query â€” luckily, the latter is a good few shot learner.

One big advantage nowadays is the availability of high-end LLMs like GPT-4 to generate high quality synthetic datasets.

But you should always be aware that taking an open-source model trained by professional research teams on carefully collected, cleaned and validated large datasets and making a quick tuning using small synthetic dataset might narrow down the model's capabilities in general.

ç¼–ç å™¨ä¸å¤§è¯­è¨€æ¨¡å‹çš„å¾®è°ƒ

è¿™ä¸ªæ–¹æ³•æ¶‰åŠå¯¹ RAG æµç¨‹ä¸­çš„ä¸¤ä¸ªæ·±åº¦å­¦ä¹ æ¨¡å‹ä¹‹ä¸€è¿›è¡Œå¾®è°ƒ â€”â€” æˆ–æ˜¯è´Ÿè´£åµŒå…¥è´¨é‡å’Œä¸Šä¸‹æ–‡æ£€ç´¢è´¨é‡çš„ Transformer ç¼–ç å™¨ï¼Œæˆ–æ˜¯è´Ÿè´£æœ€æœ‰æ•ˆåˆ©ç”¨æä¾›ä¸Šä¸‹æ–‡æ¥å›ç­”ç”¨æˆ·æŸ¥è¯¢çš„å¤§è¯­è¨€æ¨¡å‹ â€”â€” å¹¸è¿çš„æ˜¯ï¼Œåè€…æ“…é•¿äºå°‘æ ·æœ¬å­¦ä¹ ã€‚

å¦‚ä»Šï¼Œæˆ‘ä»¬èƒ½å¤Ÿåˆ©ç”¨åƒ GPT-4 è¿™æ ·çš„é«˜ç«¯å¤§è¯­è¨€æ¨¡å‹æ¥åˆ›å»ºé«˜è´¨é‡çš„åˆæˆæ•°æ®é›†ï¼Œè¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„ä¼˜åŠ¿ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿåº”å½“æ³¨æ„åˆ°ï¼Œä»…ç”¨å°å‹åˆæˆæ•°æ®é›†å¯¹ä¸“ä¸šç ”ç©¶å›¢é˜Ÿå¼€å‘çš„ã€åŸºäºå¤§é‡ç²¾å¿ƒæ”¶é›†ã€æ¸…æ´å’ŒéªŒè¯çš„æ•°æ®é›†è®­ç»ƒçš„å¼€æºæ¨¡å‹è¿›è¡Œå¿«é€Ÿè°ƒæ•´ï¼Œå¯èƒ½ä¼šé™ä½æ¨¡å‹çš„æ•´ä½“æ€§èƒ½å’Œèƒ½åŠ›ã€‚

#### 4.1 Encoder fine-tuning

I've also been a bit skeptical about the Encoder funetuning approach as the latest Transformer Encoders optimised for search are pretty efficient.

So I have tested the performance increase provided by finetuning of bge-large-en-v1.5 (top 4 of the MTEB leaderboard at the time of writing) in the LlamaIndex notebook setting, and it demonstrated a 2% retrieval quality increase. Nothing dramatic but it is nice to be aware of that option, especially if you have a narrow domain dataset you're building RAG for.

ç¼–ç å™¨å¾®è°ƒ (Encoder fine-tuning)

æˆ‘æ›¾å¯¹ä½¿ç”¨ç¼–ç å™¨å¾®è°ƒæ¥å¢å¼º Transformer ç¼–ç å™¨çš„æ•ˆç‡æŒæœ‰ä¸€äº›æ€€ç–‘ï¼Œæ¯•ç«Ÿæœ€æ–°çš„æœç´¢ä¼˜åŒ– Transformer ç¼–ç å™¨å·²ç»ç›¸å½“é«˜æ•ˆã€‚ç„¶è€Œï¼Œåœ¨ LlamaIndex ç¬”è®°æœ¬ä¸­ï¼Œæˆ‘æµ‹è¯•äº†å¯¹ bge-large-en-v1.5ï¼ˆåœ¨æ’°æ–‡æ—¶ä½äº MTEB æ’è¡Œæ¦œå‰å››ï¼‰çš„å¾®è°ƒæ•ˆæœã€‚ç»“æœæ˜¾ç¤ºï¼Œè¿™ç§å¾®è°ƒä½¿æ£€ç´¢è´¨é‡æå‡äº† 2%ã€‚è™½ç„¶è¿™ä¸ªæå‡ä¸æ˜¯ç‰¹åˆ«æ˜¾è‘—ï¼Œä½†äº†è§£è¿™ç§é€‰æ‹©å¯¹äºç‰¹å®šé¢†åŸŸæ•°æ®é›†çš„ RAG (Retrieval-Augmented Generationï¼Œæ£€ç´¢å¢å¼ºç”Ÿæˆ) æ„å»ºæ¥è¯´æ˜¯éå¸¸æœ‰ä»·å€¼çš„ã€‚

#### 4.2 Ranker fine-tuning

The other good old option is to have a cross-encoder for reranking your retrieved results if you dont trust your base Encoder completely.

It works the following way â€” you pass the query and each of the top k retrieved text chunks to the cross-encoder, separated by a SEP token, and fine-tune it to output 1 for relevant chunks and 0 for non-relevant.

A good example of such tuning process could be found here, the results say the pairwise score was improved by 4% by cross-encoder finetuning.

æ’åºå™¨å¾®è°ƒ (Ranker fine-tuning)

å¦ä¸€ä¸ªå€¼å¾—è€ƒè™‘çš„è€æ–¹æ³•æ˜¯ï¼Œåœ¨ä½ ä¸å®Œå…¨ä¿¡ä»»åŸºç¡€ç¼–ç å™¨çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨äº¤å‰ç¼–ç å™¨ (cross-encoder) å¯¹æ£€ç´¢åˆ°çš„ç»“æœè¿›è¡Œé‡æ–°æ’åˆ—ã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼šä½ æŠŠæŸ¥è¯¢å’Œæ¯ä¸ªå‰ k ä¸ªæ£€ç´¢åˆ°çš„æ–‡æœ¬å—ä¸€èµ·é€å…¥äº¤å‰ç¼–ç å™¨ï¼Œä¸­é—´ç”¨ SEP (åˆ†éš”ç¬¦) Token åˆ†éš”ï¼Œå¹¶å¯¹å®ƒè¿›è¡Œå¾®è°ƒï¼Œä½¿å…¶å¯¹ç›¸å…³çš„æ–‡æœ¬å—è¾“å‡º 1ï¼Œå¯¹ä¸ç›¸å…³çš„è¾“å‡º 0ã€‚ä¸€ä¸ªè¿™ç§å¾®è°ƒè¿‡ç¨‹çš„ä¼˜ç§€ä¾‹å­å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼Œç»“æœæ˜¾ç¤ºé€šè¿‡äº¤å‰ç¼–ç å™¨å¾®è°ƒï¼Œæˆå¯¹æ¯”è¾ƒå¾—åˆ†æé«˜äº† 4%ã€‚

#### 4.3 LLM fine-tuning

Recently OpenAI started providing LLM finetuning API and LlamaIndex has a tutorial on finetuning GPT-3.5-turbo in RAG setting to "distill" some of the GPT-4 knowledge. The idea here is to take a document, generate a number of questions with GPT-3.5-turbo, then use GPT-4 to generate answers to these questions based on the document contents (build a GPT4-powered RAG pipeline) and then to fine-tune GPT-3.5-turbo on that dataset of question-answer pairs. The ragas framework used for the RAG pipeline evaluation shows a 5% increase in the faithfulness metrics, meaning the fine-tuned GPT 3.5-turbo model made a better use of the provided context to generate its answer, than the original one.

A bit more sophisticated approach is demonstrated in the recent paper RA-DIT: Retrieval Augmented Dual Instruction Tuning by Meta AI Research, suggesting a technique to tune both the LLM and the Retriever

(a Dual Encoder in the original paper) on triplets of query, context and answer. For the implementations details please refer to this guide.

This technique was used both to fine-tune OpenAI LLMs through the fine-tuning API and Llama2 open-source model (in the original paper), resulting in ~5% increase in knowledge-intense tasks metrics (compared to Llama2 65B with RAG) and a couple percent increase in common sense reasoning tasks.

In case you know better approaches to LLM finetuning for RAG, please share your expertise in the comments section, especially if they are applied to the smaller open source LLMs.

å¤§è¯­è¨€æ¨¡å‹å¾®è°ƒ

OpenAI æœ€è¿‘æ¨å‡ºäº†å¤§è¯­è¨€æ¨¡å‹å¾®è°ƒçš„ API ï¼ŒåŒæ—¶ LlamaIndex ä¹Ÿæä¾›äº†ä¸€ä¸ªæ•™ç¨‹ï¼Œæ•™ä½ å¦‚ä½•åœ¨ RAGï¼ˆæ£€ç´¢å¼é—®ç­”ç”Ÿæˆï¼‰ç¯å¢ƒä¸­å¯¹ GPT-3.5-turbo è¿›è¡Œå¾®è°ƒï¼Œä»¥ä¾¿ä» GPT-4 ä¸­è·å–çŸ¥è¯†ã€‚è¿™ä¸ªæ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šå…ˆç”¨ GPT-3.5-turbo ä»ä¸€ä¸ªæ–‡æ¡£ä¸­ç”Ÿæˆä¸€ç³»åˆ—é—®é¢˜ï¼Œç„¶ååˆ©ç”¨ GPT-4 æ ¹æ®æ–‡æ¡£å†…å®¹æ¥å›ç­”è¿™äº›é—®é¢˜ï¼Œé€šè¿‡è¿™ç§æ–¹å¼æ„å»ºåŸºäº GPT-4 çš„ RAG å¤„ç†æµç¨‹ï¼Œæ¥ç€å†å¯¹è¿™æ‰¹é—®é¢˜å’Œç­”æ¡ˆå¯¹è¿›è¡Œå¾®è°ƒã€‚ä½¿ç”¨çš„ ragas æ¡†æ¶åœ¨ RAG æµç¨‹è¯„ä¼°ä¸­è¡¨ç°å‡ºäº†æ˜¾è‘—çš„æå‡ï¼Œå¾®è°ƒåçš„ GPT 3.5-turbo åœ¨ç”Ÿæˆç­”æ¡ˆæ—¶ï¼Œç›¸æ¯”åŸå§‹æ¨¡å‹æ›´å¥½åœ°åˆ©ç”¨äº†æ‰€ç»™çš„ä¸Šä¸‹æ–‡ï¼Œå¿ å®åº¦æé«˜äº† 5%ã€‚

Meta AI ç ”ç©¶å›¢é˜Ÿæœ€è¿‘çš„ä¸€ç¯‡è®ºæ–‡ä¸­ä»‹ç»äº†ä¸€ç§æ›´ä¸ºå¤æ‚çš„æ–¹æ³•ï¼Œåä¸º RA-DITï¼ˆæ£€ç´¢å¢å¼ºçš„åŒå‘æŒ‡ä»¤è°ƒæ•´ï¼‰ï¼Œæå‡ºäº†ä¸€ç§åŒæ—¶å¯¹å¤§è¯­è¨€æ¨¡å‹å’Œæ£€ç´¢å™¨ï¼ˆè®ºæ–‡ä¸­ç§°ä¸ºåŒç¼–ç å™¨ï¼‰è¿›è¡Œè°ƒæ•´çš„æŠ€æœ¯ã€‚è¿™ç§æŠ€æœ¯ä¾æ®é—®é¢˜ã€ä¸Šä¸‹æ–‡å’Œç­”æ¡ˆçš„ä¸‰å…ƒç»„æ¥è¿›è¡Œè°ƒæ•´ã€‚æ›´å¤šå®æ–½ç»†èŠ‚è¯·å‚è€ƒè¿™ä¸ªæŒ‡å—ã€‚è¿™ç§æŠ€æœ¯ä¸ä»…è¢«ç”¨äºé€šè¿‡å¾®è°ƒ API å¯¹ OpenAI çš„å¤§è¯­è¨€æ¨¡å‹è¿›è¡Œå¾®è°ƒï¼Œä¹Ÿè¢«ç”¨äº Llama2 çš„å¼€æºæ¨¡å‹ï¼Œç›¸æ¯”äºæ­è½½ RAG çš„ Llama2 65Bï¼Œå®ƒåœ¨çŸ¥è¯†å¯†é›†å‹ä»»åŠ¡ä¸Šçš„è¡¨ç°æå‡äº†çº¦ 5%ï¼Œåœ¨å¸¸è¯†æ¨ç†ä»»åŠ¡ä¸Šä¹Ÿæœ‰æ‰€æå‡ã€‚

å¦‚æœæ‚¨å¯¹ RAG ç¯å¢ƒä¸‹çš„å¤§è¯­è¨€æ¨¡å‹å¾®è°ƒæœ‰æ›´å¥½çš„æ–¹æ³•ï¼Œè¯·åœ¨è¯„è®ºåŒºåˆ†äº«æ‚¨çš„è§è§£ï¼Œå°¤å…¶æ˜¯é‚£äº›é€‚ç”¨äºå°å‹å¼€æºå¤§è¯­è¨€æ¨¡å‹çš„æ–¹æ³•ã€‚

### 05. Evaluation

There are several frameworks for RAG systems performance evaluation sharing the idea of having a few separate metrics like overall answer relevance, answer groundedness, faithfulness and retrieved context relevance.

Ragas, mentioned in the previous section, uses faithfulness and answer relevance as the generated answer quality metrics and classic context precision and recall for the retrieval part of the RAG scheme.

In a recently released great short course Building and Evaluating Advanced RAG by Andrew NG, LlamaIndex and the evaluation framework Truelens, they suggest the RAG triad â€” retrieved context relevance to the query, groundedness (how much the LLM answer is supported by the provided context) and answer relevance to the query.

The key and the most controllable metric is the retrieved context relevance â€” basically parts 1â€“7 of the advanced RAG pipeline described above plus the Encoder and Ranker fine-tuning sections are meant to improve this metric, while part 8 and LLM fine-tuning are focusing on answer relevance and groundedness.

A good example of a pretty simple retriever evaluation pipeline could be found here and it was applied in the Encoder fine-tuning section.

A bit more advanced approach taking into account not only the hit rate, but the Mean Reciprocal Rank, a common search engine metric, and also generated answer metrics such as faithfulness abd relevance, is demonstrated in the OpenAI cookbook.

LangChain has a pretty advanced evaluation framework LangSmith where custom evaluators may be implemented plus it monitors the traces running inside your RAG pipeline in order to make your system more transparent.

In case you are building with LlamaIndex, there is a rag_evaluator llama pack, providing a quick tool to evaluate your pipeline with a public dataset.

è¯„ä¼°

ç›®å‰å­˜åœ¨å¤šç§æ¡†æ¶ç”¨äºè¯„ä¼° RAG (Retrieval-Augmented Generation) ç³»ç»Ÿçš„æ€§èƒ½ï¼Œå®ƒä»¬æ™®éé‡‡ç”¨äº†å‡ é¡¹ç‹¬ç«‹çš„è¯„ä¼°æŒ‡æ ‡ï¼Œå¦‚ç­”æ¡ˆçš„ç›¸å…³æ€§ã€ç­”æ¡ˆçš„åŸºäºæ€§ã€çœŸå®æ€§å’Œæ£€ç´¢åˆ°çš„å†…å®¹çš„ç›¸å…³æ€§ã€‚

åœ¨ä¹‹å‰ç« èŠ‚æåŠçš„ Ragasï¼Œä½¿ç”¨çœŸå®æ€§å’Œç­”æ¡ˆç›¸å…³æ€§æ¥è¯„ä»·ç”Ÿæˆç­”æ¡ˆçš„è´¨é‡ï¼Œå¹¶ä½¿ç”¨ä¼ ç»Ÿçš„ä¸Šä¸‹æ–‡ç²¾å‡†åº¦å’Œå¬å›ç‡æ¥è¯„ä¼° RAG æ–¹æ¡ˆçš„æ£€ç´¢æ€§èƒ½ã€‚

åœ¨å®‰å¾·é² NG æœ€è¿‘æ¨å‡ºçš„ç²¾å½©çŸ­æœŸè¯¾ç¨‹æ„å»ºå’Œè¯„ä¼°é«˜çº§ RAG ä¸­ï¼Œä»¥åŠå…¶ä¸­æåˆ°çš„ LlamaIndex å’Œè¯„ä¼°æ¡†æ¶ Truelensï¼Œä»–ä»¬æå‡ºäº†ä¸€ä¸ª RAG ä¸‰å…ƒç»„è¯„ä¼°æ¨¡å¼ â€” åˆ†åˆ«æ˜¯å¯¹é—®é¢˜çš„æ£€ç´¢å†…å®¹ç›¸å…³æ€§ã€ç­”æ¡ˆçš„åŸºäºæ€§ï¼ˆå³å¤§è¯­è¨€æ¨¡å‹çš„ç­”æ¡ˆåœ¨å¤šå¤§ç¨‹åº¦ä¸Šå¾—åˆ°äº†æä¾›çš„ä¸Šä¸‹æ–‡çš„æ”¯æŒï¼‰å’Œç­”æ¡ˆå¯¹é—®é¢˜çš„ç›¸å…³æ€§ã€‚

å…¶ä¸­æœ€å…³é”®ä¸”å¯æ§çš„æŒ‡æ ‡æ˜¯æ£€ç´¢å†…å®¹çš„ç›¸å…³æ€§ â€” å®é™…ä¸Šæ˜¯ä¸Šè¿°é«˜çº§ RAG ç®¡é“çš„å‰ 1-7 éƒ¨åˆ†åŠ ä¸Šç¼–ç å™¨å’Œæ’åå™¨çš„å¾®è°ƒéƒ¨åˆ†ï¼Œè¿™äº›éƒ½æ˜¯ä¸ºäº†æé«˜è¿™ä¸ªæŒ‡æ ‡ã€‚è€Œç¬¬ 8 éƒ¨åˆ†å’Œå¤§è¯­è¨€æ¨¡å‹çš„å¾®è°ƒåˆ™ä¸“æ³¨äºæé«˜ç­”æ¡ˆçš„ç›¸å…³æ€§å’ŒåŸºäºæ€§ã€‚

ä¸€ä¸ªç®€å•æœ‰æ•ˆçš„æ£€ç´¢å™¨è¯„ä¼°ç®¡é“çš„ä¾‹å­å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼Œå®ƒå·²è¢«åº”ç”¨äºç¼–ç å™¨çš„å¾®è°ƒéƒ¨åˆ†ã€‚ä¸€ä¸ªæ›´é«˜çº§çš„æ–¹æ³•ä¸ä»…è€ƒè™‘å‘½ä¸­ç‡ï¼Œè¿˜åŒ…æ‹¬äº†å¸¸ç”¨çš„æœç´¢å¼•æ“è¯„ä¼°æŒ‡æ ‡å¹³å‡å€’æ•°æ’å (Mean Reciprocal Rank)ï¼Œä»¥åŠç”Ÿæˆç­”æ¡ˆçš„è´¨é‡æŒ‡æ ‡ï¼Œå¦‚çœŸå®æ€§å’Œç›¸å…³æ€§ï¼Œè¿™åœ¨ OpenAI çš„å®ç”¨æŒ‡å—ä¸­æœ‰æ‰€å±•ç¤ºã€‚

LangChain æä¾›äº†ä¸€ä¸ªé¢‡ä¸ºå…ˆè¿›çš„è¯„ä¼°æ¡†æ¶ LangSmithã€‚åœ¨è¿™ä¸ªæ¡†æ¶ä¸­ï¼Œä½ ä¸ä»…å¯ä»¥å®ç°è‡ªå®šä¹‰çš„è¯„ä¼°å™¨ï¼Œè¿˜èƒ½ç›‘æ§ RAG ç®¡é“å†…çš„è¿è¡Œè½¨è¿¹ï¼Œè¿›è€Œå¢å¼ºç³»ç»Ÿçš„é€æ˜åº¦ã€‚

å¦‚æœä½ æ­£åœ¨ä½¿ç”¨ LlamaIndex è¿›è¡Œæ„å»ºï¼Œå¯ä»¥å°è¯• rag_evaluator llama packã€‚è¿™æ˜¯ä¸€ä¸ªä¾¿æ·çš„å·¥å…·ï¼Œèƒ½å¤Ÿå¸®åŠ©ä½ åˆ©ç”¨å…¬å…±æ•°æ®é›†æ¥å¯¹ä½ çš„ç®¡é“è¿›è¡Œè¯„ä¼°ã€‚


### 06. Conclusion

I tried to outline the core algorithmic approaches to RAG and to illustrate some of them in hopes this might spark some novel ideas to try in your RAG pipeline, or bring some system to the vast variety of tecniques that have been invented this year â€” for me 2023 was the most exciting year in ML so far.

There are many more other things to consider like web search based RAG (RAGs by LlamaIndex, webLangChain, etc), taking a deeper dive into agentic architectures (and the recent OpenAI stake in this game) and some ideas on LLMs Long-term memory.

The main production challenge for RAG systems besides answer relevance and faithfulness is speed, especially if you are into the more flexible agent-based schemes, but that's a thing for another post. This streaming feature ChatGPT and most other assistants use is not a random cyberpunk style, but merely a way to shorten the perceived answer generation time.

That is why I see a very bright future for the smaller LLMs and recent releases of Mixtral and Phi-2 are leading us in this direction.

Thank you very much for reading this long post!

The main references are collected in my knowledge base, there is a co-pilot to chat with this set of documents: https://app.iki.ai/playlist/236.

ç»“è®º

æˆ‘è¯•å›¾å‹¾å‹’å‡º RAG çš„æ ¸å¿ƒç®—æ³•æ–¹æ³•ï¼Œå¹¶å±•ç¤ºå…¶ä¸­çš„ä¸€äº›ï¼Œå¸Œæœ›è¿™èƒ½æ¿€å‘ä½ åœ¨ RAG æµç¨‹ä¸­å°è¯•ä¸€äº›æ–°æ€è·¯ï¼Œæˆ–è€…ä¸ºä»Šå¹´æ¶Œç°çš„ä¼—å¤šæŠ€æœ¯å¸¦æ¥ä¸€å®šçš„ç³»ç»Ÿæ€§ â€”â€” å¯¹æˆ‘è€Œè¨€ï¼Œ2023 å¹´æ˜¯è¿„ä»Šä¸ºæ­¢åœ¨æœºå™¨å­¦ä¹ é¢†åŸŸæœ€ä»¤äººå…´å¥‹çš„ä¸€å¹´ã€‚

è¿˜æœ‰è®¸å¤šå…¶ä»–å› ç´ éœ€è¦è€ƒè™‘ï¼Œä¾‹å¦‚åŸºäºç½‘ç»œæœç´¢çš„ RAGï¼ˆå¦‚ LlamaIndex çš„ RAGsã€webLangChain ç­‰ï¼‰ï¼Œæ›´æ·±å…¥åœ°æ¢ç´¢æ™ºèƒ½ä½“æ¶æ„ï¼ˆä»¥åŠæœ€è¿‘ OpenAI åœ¨è¿™ä¸ªé¢†åŸŸçš„æŠ•èµ„ï¼‰ï¼Œä»¥åŠä¸€äº›å…³äºå¤§è¯­è¨€æ¨¡å‹é•¿æœŸè®°å¿†çš„æƒ³æ³•ã€‚

RAG ç³»ç»Ÿçš„ä¸»è¦ç”Ÿäº§æŒ‘æˆ˜é™¤äº†å›ç­”çš„ç›¸å…³æ€§å’Œå¿ å®åº¦å¤–ï¼Œè¿˜æœ‰é€Ÿåº¦ï¼Œå°¤å…¶æ˜¯å¦‚æœä½ å–œæ¬¢æ›´çµæ´»çš„åŸºäºæ™ºèƒ½ä½“çš„æ–¹æ¡ˆï¼Œä½†è¿™æ˜¯å¦ä¸€ç¯‡æ–‡ç« çš„å†…å®¹ã€‚ChatGPT å’Œå¤§å¤šæ•°å…¶ä»–åŠ©æ‰‹ä½¿ç”¨çš„è¿™ç§æµå¼ç‰¹æ€§ä¸æ˜¯éšæœºçš„èµ›åšæœ‹å…‹é£æ ¼ï¼Œè€Œåªæ˜¯ä¸€ç§ç¼©çŸ­æ„ŸçŸ¥ç­”æ¡ˆç”Ÿæˆæ—¶é—´çš„æ–¹æ³•ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘çœ‹å¥½å°å‹å¤§è¯­è¨€æ¨¡å‹å’Œæœ€è¿‘çš„ Mixtral å’Œ Phi-2 å‘å¸ƒï¼Œå®ƒä»¬æ­£åœ¨å¼•å¯¼æˆ‘ä»¬èµ°å‘è¿™ä¸ªæ–¹å‘ã€‚

éå¸¸æ„Ÿè°¢ä½ é˜…è¯»è¿™ç¯‡é•¿æ–‡ï¼

ä¸»è¦å‚è€ƒèµ„æ–™æ”¶é›†åœ¨æˆ‘çš„çŸ¥è¯†åº“ä¸­ï¼Œæœ‰ä¸€ä¸ª co-pilot å¯ä»¥ä¸è¿™ç»„æ–‡æ¡£å¯¹è¯ï¼š

https://app.iki.ai/playlist/236.