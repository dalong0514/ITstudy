# 领域驱动设计个人总结

[领域驱动设计个人总结（附高清书籍） - 掘金](https://juejin.im/post/5def0555e51d4557fb20eb2f)

## 00. 领域驱动设计 DDD 之概览

[领域驱动设计 DDD 之概览 - CoderV 的进阶笔记](http://vc2x.com/articles/2019/11/06/1572972339578.html)

更新于 2019-12-02   |   0 条评论   |   热度 417°C

在从事开发多年之后，你是否会感觉自己只是一个业务 CRUD Boy，并认为业务没有多少技术含量。你是否会陷入业务的泥潭中，各种复杂交错的业务规则使得代码开始腐烂开始失控，项目开始变得难以维护，迭代举步维艰。如果你开始意识到这个问题的话，那么我十分推荐你开始学习领域驱动设计面向领域建模的设计方式。

### 01. DDD 是什么呢？

DDD 即 Domain Driven Design，翻译成中文的话就是领域驱动设计，首先我们应该先理解这里的领域是什么意思？假设公司内部正在开发一套电商平台，而电商平台中包含了库存、订单、商品等核心业务。这些核心业务逻辑其实呈现的就是电商平台领域。通俗的理解就是一整套体系的业务知识即代表了一个领域。好比在线教育平台，它需要有一套体系的业务，包括招生、线上教学、课程等内容。我们将这些业务抽象出领域模型，而这些领域模型表达了产品经理所阐述的业务需求，我们反复地用这些领域模型与产品经理进行讨论沟通最终确定初步的领域模型。再使用初步的领域模型指导代码设计开发。

简而言之就是：业务知识 --> 领域模型 --> 项目设计与代码开发。

不同的电商平台的核心业务逻辑大都是相似的，这部分领域知识是可以进行复用，区别在于不同公司使用的不同的编程语言，不同的前端控制框架，数据库框架。采用领域驱动设计的好处在于项目以领域模型为核心，而 Spring MVC、Struts 等前端控制框架或者 Hibernate、Mybatis 对象数据库框架属于外围技术基础，领域模型其实并不与这些基础技术产生耦合，所以在领域模型不变的情况下，我们是很容易对我们的基础设施进行更换的。

那我们之前的开发也是有这些业务逻辑支撑？那我们之前传统的开发模式为什么不能称之为面向领域驱动设计呢？回想一下我们之前的代码开发，比如一个实现一个购物车下订单的功能，我们根据订单表的字段，依次用商品字段、金额字段、用户字段等拼凑出订单表中的一条记录，然后写入到订单表当中去。其实我们是面向数据库在进行开发，以数据库为重心，而业务逻辑零散地分布在各个 Service 当中去，采用的是面向过程的编程方式而不是面向对象的方式，也就没有形成一套有机的业务逻辑。

而面向领域驱动设计则不一样，它以领域为重心，以刚才的购物车下订单功能为例子。在 DDD 当中，会将购物车相关的业务逻辑封装到一个 ShoppingCart 对象中，并直接调用 shoppingCart.takeOrder() 下订单的方法，代码的重心从生成订单表中的记录转移到购物车对象本身，而具体数据库中如何生成这条记录并不属于我们的核心业务逻辑，它被下放到基础设施层，由 Repository 或者 Dao 等数据交互对象负责去持久化我们对领域模型下达的指令所产生的数据库变化。

项目中的代码通过不同领域模型之间的配合体现了领域专家的业务意图，使得系统内部形成一套自运行的有机整体。在以往面向过程式的开发方式，我们很难让领域专家或者产品经理直接看懂我们的业务逻辑，而 DDD 的优势在于 shoppingCart.takeOrder() 这种类似白话的方式直接体现出业务含义。而我们代码中的领域模型和领域专家口中的领域模型是一致的。甚至我们可以在没有基础设施技术支持的情况下，直接建模领域模型开始编写代码并测试验证业务逻辑。

领域模型总结：1）抽象了领域内的核心概念，并建立概念之间的关系；2）领域模型维护了领域内的数据之间一致性的，也即我们的业务规则；

### 02. 为什么我们需要 DDD

1、通过统一语言使得我们开发人员与领域专家（产品经理）能够更好的沟通。更准确的表达我们的业务，而这些业务代码按照正如领域专家所想的那样工作。

2、通过战术设计将业务知识进行集中，浓缩在领域模型当中。

3、以往的业务代码中，我们总需要嵌入许多注释，因为过程式的代码自解释的能力很差，而最好的设计就是代码本身。通过代码本身将领域中的知识呈现出来。

4、通过战略设计解构复杂的业务系统，并使其简单化。

战术设计和战略设计是 DDD 针对局部和整体的设计指导。

### 03. 贫血症和失忆症

传统的开发模式中，我们经常使用的是一个 JavaBean，其中只有映射到数据库的字段，并没有业务行为。通过填充这个 JavaBean，并在对象外部进行业务逻辑的编写，如计算订单的最终金额填充到 JavaBean 中再交由数据库映射框架进行持久化。

而其实这就是 Evans 所说的贫血症，因为数据和业务行为隔离开来，形成一种无机的代码组成。其实这并非面向对象的编码方式，当我们看到 Order 对象时，我们根本不知道它含有计算最终金额的业务逻辑，而这其实就是一种所谓的贫血症引起的失忆症。数据和行为并没有紧密的联系到一起。

```java
public static void buyProduct(Long orderId, Double price, Long productId, Float discount) {
        Order order = new Order();

        order.setOrderId(orderId);
        order.setProductId(productId);
        order.setDiscount(discount);
        order.setPrice(price);

        // 计算最终付款金额
        if(discount == 0) {
            throw new RuntimeException("折扣不可为0！");
        }

        Double paid = price * discount;
        order.setPaid(paid);

        OrderDao.save(order);
}
```

而更好的方式我们应该通过将数据和业务行为整合到一个对象中去，让二者形成一种有机的代码组成。在 GRASP 对象职责中有一个原则就是当一个对象拥有某个方法所需的属性时，那么更应该将这个方法放置到这个对象中去，而不是放在其他地方。

```java
public static void buyProduct_(Long orderId, Double price, Long productId, Float discount) {

        Order order = new Order(orderId, price, productId, discount);

        order.calculatePaid();

        OrderDao.save(order);
}
```

上面的例子更加符合我们对于业务的描述，但仅仅强调将业务逻辑封装到数据对象中去还不够，我们还需要通过这些对象之间的协作来进行业务的表达。一个很显而易见的例子就是关于转账的例子。

```java
public static void main(String[] args) {

    Account a = new Account(5);

    Account b = new Account(5);

    double transferMoney = 4;

    if (a.getMoney() < transferMoney) {
        throw new RuntimeException("余额不足！");
    }

    a.setMoney(a.getMoney() - transferMoney);

    b.setMoney(b.getMoney() + transferMoney);

}
```

更好的做法我们应该借鉴面向对象的建模方式，将领域知识封装到账户 Account 模型中去。

```java
public void transfer(Account another, double transferMoney) {
        if (money < transferMoney) {
            throw new RuntimeException("余额不足！");
        }

        money = money - transferMoney;
        another.setMoney(another.getMoney() + transferMoney);

    }

// A账户向B账户进行转账。

public static void main(String[] args) {
    Account a = new Account(5);
    Account b = new Account(5);

    double transferMoney = 4;

    a.transfer(b, transferMoney);
}
```

我们通过领域模型之间的协作，呈现出来的代码就像白话一样。有主语谓语宾语。主语是 A 账户，谓语是 transfer() 方法，宾语是 B 账户。这样一来，代码的自解释能力也就非常强了。就算产品经理不懂编程语言的话，看到我们的代码的话也能理解其中的业务目的。

1『很赞，通过 DDD 可以展示出代码的自我解释能力。』

### 04. DDD 的适用场景

那什么场景才是适合 DDD 的场景呢？在可预见的未来中，项目的业务复杂度会越来越高，那就非常适合使用 DDD 的设计方式。而如果项目全部都是一些非常简单的增删查改而很少包含业务知识的话，那真是想 D 也 D 不起来，因为 DDD 的思想就是为了通过模型来表达领域知识，而领域知识本身就很匮乏的话，表达也就无从谈起。

### 05. 如何 DDD

我们可以通过和领域专家（产品经理）使用一致的通用语言，利用通用语言抽象出领域模型，在根据这些领域模型进行代码的落地开发，这样一来便能更好的在代码中去体现业务领域知识。我们需要转变我们以往的思维惯性，少从技术层面考虑，而更应该从业务层面去考虑。我的理解是，DDD 是一套基于领域为核心的面向对象编程的方法论。它主要通过两种设计来实现 DDD。一种是战术设计，你可以理解为在单个微服务中的设计。一种是战略设计，你可以理解为多个微服务之间如何进行协作。

### 06. 战术设计

战术设计侧重点在于局部的设计，主要有以下几个概念：1）实体：有唯一标识有生命周期，可以理解为通过实体可以对应到数据库的记录。2）值对象：用来描述实体的属性。3）聚合：包含实体和值对象，并维护了事务一致性。4）资源库：用于获取或保存聚合。5）领域服务：放置一些不适合在聚合中的业务逻辑。

我们简单的讲解一下这几个概念是如何在单个限界上下文（即单个微服务）中进行工作的。聚合由实体、值对象进行组成，它维护了事务的一致性。而聚合又由资源库进行持久化以及查找或者获取。而当一些业务规则并不能很好的放入实体或者值对象上时，我们可以使用领域服务。

### 07. 战略建模

战略设计侧重点在于整体内的不同局部如何协作的设计，主要有以下几个概念：1）限界上下文：一类领域模型运作的环境。比如电商中的商品模块即一个限界上下文。2）上下文映射图：不同类的领域模型如何交互。比如在电商平台中商品模块是如何与库存模块进行交互的。3）限界上下文是一种概念上的边界，领域模型便工作于其中，也即一个限界上下文对应了我们设计的一个微服务。而不同上下文如何进行沟通的话，则利用上下文映射图的概念来进行指导开发。

关于 DDD 的讨论非常之多，每个人的见解都不一样，这也是 DDD 为什么难以流行起来的原因之一。但是 DDD 的思想还是非常值得借鉴的。关于 DDD 的学习个人非常推荐一定要阅读原著 DDD 以及 IDDD。

## 0101. 领域驱动设计 DDD 之实体

更新于 2019-11-19   |   0 条评论   |   热度 404°C

### 1.1 什么是实体？

实体最主要有两点特征，一是唯一标识，二是连续性。

唯一标志：当一些对象不是由属性定义，而是由一个唯一标志定义的话，我们就可以认为它是一个实体。好比我们不能通过一个人的外在特征去唯一定位一个人，因为人从小到大，从年轻到衰老其外在特征都是在改变的。而身份证号码可以贯穿一个人的一生而不发生变化。而且唯一标识不一定仅有一个属性表示，有可能通过多个属性标识某一个唯一对象，就好比数据库中的联合外键（可能有根据电话以及姓名唯一确定一个实体的情况）。

连续性：对象的连续性体现在对象是有生命周期的。在这个生命周期内，对象内的属性可能是变化着的。好比银行账户表，它就属于一个实体，用户的银行卡号可以唯一的确定一个人的账户，而账户的内的余额随着时间变化（利息）或者随着交易变化。

但实体并非一定是映射到我们现实世界的某个具体事物。实体可以是一个人，一辆车，也可以是一次交易或者是一场比赛。只要它们是满足两个条件的：一：它在整个生命周期是连续的，即变化的。可以通俗的理解为数据库中的一个用户信息表，用户的信息会发生一些改变。而系统中的操作日志表，我们不会再对其进行修改，我们也没有必要对某个操作日志做唯一的标识。二：它的区别不是由除了唯一标识之外的属性所区分开的。比如数据库中有一张银行账户表，有卡号、余额、账户类别三个字段。我们区分每个账户并不是通过余额和账户类别来区分一个银行账户，而是通过唯一的银行卡号来唯一区分。

实体不单单出现在同一张表或者同一个库，甚至实体会出现在不同的系统当中。而当我们需要区分对象的时候，实体模型应该要定义出当符合什么条件才能是算相同的事务。好比支付宝系统里的用户和银行系统里的用户想要打通，并对用户进行信用评分，那么他们如何知道支付宝里的某些流水和银行里的某些流水同属于某一个人呢？这个时候可能就需要通过银行开户的身份证和支付宝当时实名认证的身份证来进行甄别。

### 1.2 实体建模

```java
public class Customer {

    private Long customerID;

    private String name;

    private String phone;
    // 余额
    private String balance;
    // 会员等级
    private String vipLevel;

}
```

以上对 Customer 的建模我们可以适当地做一下改变，想想我们对实体最根本的理解，实体最主要的就是为了标识某个领域内的事物。在以上这个例子当中，余额和会员等级其实都不能去标识一个用户，而 name 字段虽然不唯一，但我们也经常用来识别账户。而电话则是唯一的，因为注册电话是唯一的。所以其实我们不仅可以通过 CustomerID 来识别某个用户，还可以通过 name 和 phone 来查找用户。所以我们的准则是有助于识别某个领域对象的属性我们放到实体当中去。

所以在上面的例子当中我们可以将余额 balance 和 vipLevel 两个字段从 Customer 实体类中移出转移到其他关联对象上，并通过这些关联对象履行职责。

```java
public class Customer {

    private Long customerID;

    private String name;

    private String phone;

}
```

### 1.3 生成实体唯一标识的四种方式

汇总：1）用户提供一个或者多个初始唯一值作为输入时，例如注册账户时填入自定义用户名或者邮箱或者电话等等。我们的系统必须保证这个值的唯一。2）程序内部通过某种算法自动生成身份标识，例如 UUID、雪花 ID 等机制去生成唯一算法。3）程序依赖于持久化存储，比如数据库生成的自增主键。4）通过其他的限界上下文决定出的唯一标识，作为程序的输入。

在某种特殊情况下，我们的实体是利用两个属性来进行标识对象，类似于数据库表中的联合主键，但是我们的数据库框架如 Hibernate 或者 Mybatis 实际修改表中的数据可能用到的是表中的 id 字段如 updateByPrimaryKey() 此类方法，这个时候我们可以让实体继承一个拥有 id 属性的抽象类，以解决上述问题。

```java
public abstract class IdentifiedDomainObject implements Serializable {

    private long id;

    protected long getId() {
        return id;
    }

    protected void setId(long id) {
        this.id = id;
    }

}
```

### 1.4 实体的不变性

有时候一个实体维护了一个或者多个不变条件，可以通俗的理解为我们的业务逻辑规则，比如一条订单的支付金额不可能大于商品总额，也不可能为负数。实体必须在整个生命周期中都保持这种一致性否者就是错误的。不变条件主要是由聚合所关注（后文会谈到）。我们可能还需要去验证实体内的属性是否符合我们的要求，如不能为 null，不能为空串，长度不能大于 100，需满足一定格式等等。我们可以在为实体填入参数的时候进行判别。

## 0102. 领域驱动设计 DDD 之值对象

更新于 2019-11-19   |   0 条评论   |   热度 338°C

### 2.1 值对象是什么？

之前我们讲到实体，它最主要的特征在于概念上的标识。而领域中存在一些不需要进行标识的对象，它们主要是对事物的描述。如何理解这段话呢？可以通俗的理解，之前我们认为实体是数据库中的一条记录，这条记录会发生更改，例如学生的信息表。而值对象对应到数据库中的什么呢？它们不会单独地映射一张表而是可能对应表中的几个字段。比如学生信息表中拥有省、市、区、地址四个字段构成学生的住址，这四个字段构成的是一个整体用来描述学生的详细地址。

1『所以说，一个对象里的数据时分 2 大类的，一类是元数据，描述自身信息的，一类是实体的其他属性字段。』

为什么我们将学生详细地址建模成值对象呢？因为我们并不需要追踪学生详细地址的变化，我们并不关系它的连续性。在很多 DDD 的博客文章中讲解到值对象都会用到了地址这一概念，可能有的人会误解地址天然就是值对象。并非如此，它有时可能作为值对象，有时可能作为实体。这需要看我们的业务场景。

值对象的情形：当你和你的舍友在淘宝上购买商品，你们在订单上填的地址是一样的，并不需要严格区分这两个地址，快递直接送到这个地址即可。（地址映射到订单表中的几个字段上，如：省市区地址）

实体的情形：当你们宿舍的宽带坏了，需要报修，这时候你和你的舍友都打了电话报修。但是宽带人员并不会派两个人来抢修宽带。因为宽带人员知道你们是同一个地址。（宿舍地址映射到宽带公司系统中的一条地址用户表，以地址来区别用户）

### 2.2 定义

当我们只关心一个模型元素的属性时，应把它归类为值对象。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。值对象应该是不可变的，不要为它分配任何标识，不要将它设计得跟实体一样复杂。

上面的定义，关于值对象的用来描述的事物的用途应该不难理解。那为什么规定值对象应该要不可变呢？我举一个很简单的例子。假设我们有三个历史订单的地址都是 A 市 B 区 C 街道。而我们将 A 市 B 区 C 街道这一地址建模成实体对应数据库里的 address 表。于是在订单表 order 当中就会存在 address_id 用来指向地址表中的 A 市 B 区 C 街道。那如果我们将地址表中的 A 市 B 区 C 街道改成 X 市 Y 区 Z 街道的话，其实历史订单就乱套了。原本历史订单记录的是送到 A 市 B 区 C 街道，结果也变成了 X 市 Y 区 Z 街道。

例子：如何发现领域中天然适合建模为值对象的模型呢？

```java
public class Customer {

    private Long customerID;

    private String name;

    private String province;

    private String city;

    private String street;

}
```

在以上这个例子中，省、市、街道天然是一个整体，并描述了客户的地址，此时可以将这三个属性合并起来成为一个值对象。

```java
public class Customer {

    private Long customerID;

    private String name;

    private Address address;

}

/**
 * 地址值对象
 */
class Address{

    private String province;

    private String city;

    private String street;

}
```

值对象有助于数据库中的优化，比如在数据库中我们经常要作连表查询，而值对象的不变性使得我们可以安全的将 B 表的信息冗余到 A 表当中去。举个例子，比如学生分数表含有 student\_id、score 两个字段，由于学生姓名不会更改，此时就可以将 student\_name 作为学生分数表的冗余字段，避免学生分数表和学生信息表进行连表查询的动作。这也是一种反范式的例子。

如果值对象不变的话，如何去更换值对象呢？此时我们可以利用整体性替换去更改实体持有的值对象。如下：

```java
Address currentAddress = new Address ("福建", "厦门", "前埔东路");
currentAddress = new Address ("广东", "深圳", "白云南路");
```

在 IDDD 书中，作者还建议值对象应该具有无副作用性。如何理解无副作用性呢？我举一个非常简单的例子，大家都知道 Java 中的 String 字符串是不可变的，那如果对 String 进行 replace 操作的话，会影响原来的字符串吗？其实是不会的。

```java
String alpha = "a";
alpha.replace("a", "b");
System.out.println(alpha);
```

上面的例子依然会输出字母 a，这就是一种无副作用的设计方式。在 BigDecimal 类的设计当中也是，BigDecimal 的数学运算都不会直接修改原值，而是产生一个新值进行返回。

1『确实，字符串修改不会改变原值，返回一个修改后新的字符串。』

以上我对值对象映射到表中的某几个字段的只是了便于通俗理解，值对象也可以持久化到数据库的单张表中。例子淘宝的用户地址栏，我们可以新增或者删除我们的个人地址。其实这已经将这些地址值对象进行持久化了。但是订单可能并非直接引用这些地址的 id，而是直接 copy 这些地址到订单中。

我们最后总结一下值对象的主要特征：1）它度量或者描述了领域中的一件东西。2）它可以作为不变量。3）它将不同的相关属性组合成了一个概念整体。4）它可以和其他值对象进行相等性比较。5）它不会对协作对象造成副作用。

## 1.3 领域驱动设计 DDD 之领域服务

更新于 2019-11-19   |   0 条评论   |   热度 419°C

### 3.1 什么是领域服务？

在战术建模当中，并非所有模型都是事物。有些模型是对领域中的一些行为操作进行建模。此类模型我们称之为领域服务。当一些重要的领域操作无法放到实体、值对象或者聚合时，他们本质是行为而不是事物。如果我们不寻找一些对象来封装这些领域行为的话，又会演变成之前过程式的编程方式。我们希望在领域设计当中统一用模型对象进行交互。此时领域服务使用细粒度的领域对象如实体或者值对象进行交互，在服务内部描述领域知识得出结果并将其返回。

1『妙啊，领域服务是一些领域操作封装后的对象，这些领域操作没法放到实体、值对象或者聚合里，任由放在外面的话无法使用面向对象的编程范式，所以就有了领域服务。』

领域服务的参数和返回类型应该是领域对象。三个特征：1）它是与领域相关的操作如执行一个显著的业务操作过程，但它又并不适合放入实体与值对象中。2）操作是无状态的。3）对领域对象进行转换，或以多个领域对象作为输入进行计算，结果产生一个值对象。

总结：当领域中的某个重要的过程或者转换操作不是实体和值对象的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其声明为领域服务。定义接口时要使用模式语言，并确保操作名称是业务统一通用语言的术语。除此之外领域服务要成为无状态的。

我们需要把握一个度，如果将所有领域知识都封装到实体当中去时，模型就会因为行为过多导致充血，充血情况下很多实体的行为都是勉强且不自然的。而让我们将行为一股脑的封装到领域服务当中去的话，此时模型就因毫无行为导致贫血，我们又回到了传统开发模式了。

1『醍醐灌顶，行为封装到实体对象中对应于充血，封装到领域服务中对应于贫血。』

### 3.2 区分不同的服务

在传统的开发中我们已经有 Service 服务的概念了，这时候再引入领域服务时，我们可能就会开始混淆。在领域驱动设计中我们主要将服务分为三类，一类是应用服务，一类是领域服务，一类是基础服务。如何去区分这三种服务呢？我的一个简单的理解是通过服务自身所服务的客户端来进行区分。应用服务提供面向用户的服务，它所完成的是一整个用户需求。领域服务提供面向应用层的服务，它所完成的是封装领域知识，供应用层使用。基础服务提供面向应用层和领域层的服务，它所提供的是项目中各个层都可能使用到的通用功能。

我们举一个银行转账的例子，通过不同服务所处理的事情来说明。1）应用服务：获取输入，发送消息给领域层，监听确认消息，决定使用基础服务来发送邮件。2）领域服务：协调账户模型和总账模型进行交互，执行相应的领域行为。3）基础服务：按照应用服务的指示发送邮件。

### 3.3 粒度

应用层负责对领域对象的行为进行协调，来满足某一个领域需求。但如果领域对象都是实体和值对象等细粒度的对象时，应用层就得去了解这些细粒度的对象如何交互才能满足领域需求。那此时便将领域内的知识泄露到应用层了。我们应该尽量避免领域知识泄露到应用层当中去。那此时领域服务就不失为一种良好的处理方式，通过将细粒度的领域对象封装到领域服务当中去，将领域知识限制在领域服务当中，形成粗粒度的领域对象。因此应用层调用粗粒度的领域服务时也就无需关心其中复杂的对象交互。

### 3.4 转换过程

我们举一个商铺系统中需要统计每日台账的功能，而这个功能我们放置到台账统计服务当中去。我们通过传入一个商铺实体以及日期，在方法内使用 Repository 资源库（同 DAO），进行获取领域模型，再利用领域模型间的交互来完成台账的统计，最后封装成一个台账模型返回出去。

```java
public class LedgerAccountor {

    public LedgerSumary ledgerSumary(Shop aShop, Date date){
        int totalIncome = 0;
        int totalExpense = 0;
        
        List<ShopTrade> trades = ShopTradeRepository.getShopTrades(ashop,date);
        
        for(ShopTrade trade : trades){
            
            totalIncome += trade.getIncome();
            totalExpense += trade.getExpense();
            
        }
        
        return new LedgerSumary(totalIncome, totalExpense);
        
    }
    
}
```

## 1.4 领域驱动设计 DDD 之聚合

更新于 2019-11-19   |   0 条评论   |   热度 411°C

### 4.1 为什么需要聚合？

当我们设计一个订单模块，用户下单时，我们需要确保用户的余额可供支付这笔订单，并且保存这个订单。通俗的理解就是当下单的时候，必须生成订单表记录，并且检查用户余额是否足够支付，并修改用户的余额表。再转换到我们领域驱动设计中，我们必须利用订单模型和账户模型联合来完成操作，并检查保证业务规则（余额可供支付）。那此时有两点缺陷，在保证事务的应用服务中，这些领域知识（业务规则）便从领域模型泄露应用服务层。代码中除了订单模型和账户模型在同一个应用服务中这点之外，客户程序员很难知道在下单请求中订单模型和账户模型之间必须在同一个事务中进行修改。

### 4.2 聚合描述

每个聚合都有一个根和一个边界，边界内定义了聚合的内部有什么。根则是聚合所包含的一个特定的实体。外部对象可以引用根，但不能引用聚合内部的其他对象，聚合内的对象之间可以相互引用，除了根实体外，其他实体拥有本地标识。

举个例子：在汽修厂的软件中会使用到汽车的模型，这里的汽车就是根实体，因为它具有全局唯一的标识：汽车识别号。汽修厂想要跟踪每台汽车上四个轮胎的使用情况。轮胎在汽车里才是实体，它们拥有本地标识，如汽车的四轮分为左前轮，右前轮，左后轮，右后轮。当轮胎报废了之后我们便不再关心这些轮胎的生命周期了，我们也不会在系统中寻找某一个轮胎现在安在哪台车上。因此，汽车便是这个聚合的根实体，轮胎就在这个聚合的边界之内。

再举个例子：在订单模块中，下单操作必须生成订单主表和购买商品附表，订单主表即是一个根，通过这个根我们可以找到当时这笔订单购买了哪些商品。但是我们并不会单独去查购买商品附表里的记录，脱离了订单主表，这些记录就没有了意义。

### 4.3 定义

我们应该将实体和值对象分门别类的聚集到聚合当中，并定义聚合的边界。在每个聚合当中，选择一个实体作为根。并通过根来控制边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能绕过它来修改内部对象。这种设计有利于确保聚合中的对象满足所有固定规则，也可以确保在任何状态变化时聚合作为一个整体满足固定规则。不变性和一致性边界即是聚合的设计依据和精髓。

### 4.4 不变性和一致性边界

这里的不变性指的是业务规则，该规则应该始终保持一致。一致性边界的意思是单个事务的修改范围。原则上我们应该在一个事务里只修改一个聚合。

如果理解这个不变性和之前实体和值对象的不变性的区别呢？之前的实体和值对象中的不变性，针对的是局部的规则，而聚合中的一致性针对的是，各个实体或者值对象共同维持的规则。

### 4.5 聚合的主要作用

1、主要为了维护对象生命周期内的完整性。关于聚合的生命周期，在初期的时候我们使用工厂 Factory 来创建聚合或者复杂对象，在生命周期的中期末期我们使用资源库 Repository 来提供检索对象或者持久化对象。虽然工厂和资源库本身不属于领域，但我们在使用聚合的过程当中，可以更容易的操作聚合。

2、通过定义清晰的所属关系和边界，在这个边界中的模型元素在生命周期内必须维护一致性，通俗的讲就是业务规则。聚合就是一组相关对象的集合，我们将他作为数据修改的单元。通俗的说，比如以往我们在一个事务中需要修改三张表，那这三张表映射出的实体和值对象就可以组成一个聚合。

### 4.6 聚合大小（边界范围）

在具有复杂关联的模型中，要想保证对象更改的一致性是很困难的。不仅互不关联的对象需要遵守一些固定规则。而且紧密关联的各组对象也要遵守一些固定规则。然而，过于谨慎的锁定机制又会导致多个用户之间毫无意义地互相干扰，从而使系统不可用。

因为聚合涉及到了事务，因为如果事务边界太大的话，会导致经常发生冲突。所以我们应该合理的设计事务边界。一方面为了对象组合上的方便而将聚合设计得很大，另一方面，我们设计的聚合又可能因为过于贫瘠而丧失了保护真正不变条件的目的。所以聚合的边界不可过大也不可过小，但推荐聚合应该在保证遵守固定规则的前提下尽可能的小。

小聚合：其中只包含最小数量的属性或者值类型属性，这里的最小数量表示所需的最小属性集合即不多也不少。怎么理解属性时所需的呢？即那些必须与其他属性保持一致的属性。比如三角形的三个角一定要等于 180 度，你把这三个角放置到不同的聚合的话，那就不合适了。小聚合不仅有性能和可伸缩性上的好处，也有助于事务的成功执行，即减少事务冲突。

举个例子：比如我们设计一个订单模块。订单模块涉及两张表，一张是订单主表，一张是订单商品附表。我们不能直接去访问订单商品附表，而是应该通过订单主表的 id，间接的获取对应的订单商品列表。在领域模型中则是，通过资源库获取订单根实体，再通过订单根实体去获取内部的订单列表。（订单列表可以一开始就在资源库方法中封装好，也可以延迟加载）。这边我们可能会限制一个特殊规则，订单商品数量不能超过订单时间的尾数。因此在每次创建订单或者修改订单的时候都不能破坏这个规则。这个规则是针对订单主表和订单商品附表的一个联合规则。他们应该放置在同一个事务里。如果没有在一个事务中的话，假设当前商品数量差一就会达到最大数量，此时张三和李四同时对这个订单新增了一个商品。此时就破坏了这个规则。

聚合并不是简单理解为比如人类聚合由头、身体、四肢等实体或者值对象组成。它不一定映射到现实中某一个事务的完整轮廓。比如我们的业务规则，只限定头和身子必须满足一定的比例，不关心四肢部分。那么这时候的聚合只包含了头和身体。

### 4.7 聚合特征

1、根实体具有全局的标识，它最终负责检查固定规则。

2、边界内的实体具有本地标识，这些标识只在聚合内部才是唯一的。

3、聚合外部的对象不能引用根实体之外的聚合内部对象。根实体可以将内部实体的引用传递给它们，但只能临时使用。或者传递一个值对象的副本出去，而不用关心它发生了什么变化。

4、只有根实体才能直接通过数据库直接查询，其他对象必须通过遍历关联来发现。（意思是根实体可以从资源库中的某个方法获取，但是聚合内的其他对象，资源库不提供直接的访问方法，而是在资源库内生成聚合的时候，直接添加进聚合）

5、根实体可以保持其他根实体的引用。

6、删除操作，比如删除聚合边界内的所有对象。

7、当对聚合边界内的任何对象做了修改时，整个聚合的所有固定规则都必须被满足。

### 4.8 设计原则

原则一：通过唯一标识去引用其他聚合。1）引用聚合和被引用的聚合不可以在同一个事务中进行修改。2）如果你在试图在单个事务中修改多个聚合，这往往意味着此时的一致性边界是错误的，发生这样的情况通常是我们遗留了某些建模点，或者尚未发现通用语言中的某个概念。3）当试图修改多个聚合的话，我们也应该采用最终一致性而非原子一致性。

```java
public class Order {
    private Product product;
}

// 应改为利用唯一标识去引用其他聚合

public class Order {
    private ProductId productId;
}
```

原则二：利用应用层来处理聚合内的依赖关系，避免在聚合中使用资源库或者领域服务。如果实在需要特定的复杂依赖关系，可以在聚合的命令方法中使用领域服务和资源库。

原则三：在边界之外使用最终一致性。如果单次用户请求，的确需要修改多个聚合实例的话，比如在一个聚合上执行命令方法时，如果还需要在其他的聚合上执行额外的业务规则，那么则需要使用最终一致性。我们可利用消息中间件之类的机制，完成最终一致性。

但以上这些原则不是完全不能打破的。当出现以下一些情况时，我们可以做出妥协。1）方便用户界面：用户界面可能允许用户一次性的给多个对象定义共有的属性，然后再进行批量处理。2）缺乏技术机制：最终一致性需要诸如消息，定时器，后台线程之类的技术，当我们的项目没有去使用这些技术的时候。就只能在单个事务中去修改多个聚合实例。3）全局事务：考虑遗留技术和企业政策所带来的英雄。4）查询性能：有时候还是在一个聚合中维护其他聚合的直接引用，有助于资源库的查询性能。

我们不应该去找借口来打破聚合原则。长远的来看，遵循聚合原则对整个项目是有益的。有时候原子一致性在技术、性能、资源上都不好实现的话。我们可以弱化一致性，我们可以转而使用最终一致性。

## 1.5 领域驱动设计 DDD 之工厂

更新于 2019-11-19   |   0 条评论   |   热度 364°C

### 5.1 为什么需要工厂

当创建一个复杂对象或聚合的过程很复杂并且暴露出了过多的内部结构时，我们则可以使用工厂进行封装。一个对象在它的生命周期中要承担大量的职责，如果再让复杂对象负责自身的创建，那么职责过载将会导致问题。

我们设计好领域模型供客户方调用，但如果客户方也必须使用如何装配这个对象，则必须知道对象的内部结构。好比你去驾校学车，却得先学会发动机的原理。对客户方开发来说这是很不友好的。其次，复杂对象或者聚合当中的领域知识（业务规则）需要得到满足，如果让客户方自己装配复杂对象或聚合的话，就会将领域知识泄露到客户方代码中去。

对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混在一起可能产生难以理解的拙劣设计。让客户直接负责创建对象又会使客户的设计陷入混乱，并且破坏被装配对象或聚合的封装，而且导致客户与被创建对象的实现之间产生过于紧密的耦合。

最重要的一点就是隐藏创建对象的细节。

### 5.2 定义

复杂对象的创建是领域层的职责，但这项任务并不一定属于那些用于表示模型的对象，他们没有对应模型中的事物，但又确实承担了领域层的职责。应该将创建复杂对象和聚合的职责转移给单独的对象，这个对象本身可能没有承担领域模型中的职责，但它仍然领域设计的一部分。提供一个封装所有复杂装配操作的接口，而且这个接口不需要客户引用要被实例化的对象的具体类。在创建聚合时要把它作为一个整体，并确保它满足固定规则。

### 5.3 工厂的设计要点

1、每个创建方法都应该是原子的，并保证生成的对象处于一致的状态。

2、可以使用独立的工厂或者在聚合根上使用工厂方法。当 A 对象的创建主要使用了 B 对象的数据或者规则时，那么可以在 B 对象上创建一个工厂方法来生成 A 对象。

3、以下情况只需使用构造函数即可。1）类仅仅是一种类型，没有其他子类，没有实现多态性。2）客户关心的是实现类。3）客户可以访问对象的所有属性，因此向客户公开的构造函数中没有嵌套的对象创建。4）构造过程很简单。5）公共构造函数必须遵守与工厂相同的规则，必须是原子操作且满足所有固定规则。6）不要在构造函数中调用其他构造函数，应保持构造函数的简单。

4、工厂方法的参数应该是较低层的对象。比如装配一辆汽车，应该传入较低层抽象的轮胎，发动机等对象。当我们利用购物车模型进行结算的时候，可以从购物车模型的下单方法去生成一个订单模型。这就通过购物车聚合的工厂方法去生成了订单聚合。

举个例子。我们以一个论坛对象发起一个讨论为例。

```java
public class Forum {
    
    public Discussion startDiscussion(DiscussionId aDiscussionId, Author anAuthor,
                                      String aSubject) {
    
        if(this.isClosed()){
            throw new IllegalStateException("Forum is closed!");
        }
        
        
        Discussion discussion = new Discussion(this.tenant(), this.forumId(),
                                               aDiscusstionId, anAuthor, aSubject);
                                               
        // .. 发布领域事件
        
    
        return discusstion;    
        
    }
    
    
}
```

客户端如何使用这个模型呢？

```java
// 由论坛实体生成这个讨论
Discussion discussion = aForum.startDiscussion(this.discussionRepository.nextIdentity(),
new Author("jdoe", "John Doe", "jdoe@gmail.com"), 
"Dealing with Aggregate Concurrency Issues");
// 保存这个讨论
this.discussionRepository.add(discussion);
```

工厂不仅达到了封装创建对象的细节，并有效的表达了限界上下文中的通用语言，减轻客户端在创建新聚合实例时的负担，确保所创建的实例处于正确的状态（符合业务规则）。

工厂有多种形式，可以是一个独立的 Factory 对象，也可以是聚合根上的工厂方法，也可以是领域服务。工厂不仅用于对象生命初期的创建，还用于在对象生命周期的中期从数据库中的数据装配成聚合的情况。

## 1.6 领域驱动设计 DDD 之资源库

发表于 2019-11-21   |   0 条评论   |   热度 527°C

### 6.1 为什么使用资源库？

如果完全按照领域模型的角度，完全通过遍历对象的方法来获取所有关联的对象。这种模型会过于错综复杂。对象嵌套的层级或者关联的层级非常深。例如通过 Customer.order.product.price 层层遍历来获取当时客户订单的商品的价格。

那如果完全按照数据库模型的角度，模型中的对象不需要完全连接起来，对象关系网就能保持在一个可控范围。但是这又会回到之前传统开发模式中，零散的使用各个 DAO 从各个表抽取数据自行拼凑出我们想要的模型。

这里就会出现一个问题，Customer 类需要保持客户所有已订的 Order，还是通过 CustomerID 在数据库中查找 Order 列表呢？

对象关联还是纯数据库？

客户需要一种有效的方式来获取已存在的领域对象的引用。如果基础设施提供了这方面的遍历，那么开发人员可能会增加很多可遍历的关联，这会使模型变得非常混乱。另一方面，开发人员可能使用查询从数据库中提取他们所需的数据，或是直接提取具体的对象，而不是通过聚合的根来得到这些对象。这样就导致领域逻辑进入查询和客户代码中，而实体和值对象变成了单纯的数据容器。采用大多数处理数据库访问的技术复杂性很快就会使客户代码变得混乱，这将导致开发人员简化领域层，最终使模型变得无关紧要。

我们需要找到一个恰当的方式。我们不需要对那么很容易通过遍历来找到的持久对象进行查询访问，如不需要单独的去获取地址，而可以通过 Person 对象来获取地址，意味着当我们获取 Person 对象的时候，地址值对象已经是填充好的。我们不需要特地利用另外一个资源库的方法，获取地址再进行填充。但当获取 Person 的所有订单记录时，由于订单的数量有时候过于庞大，加载 Person 的时候其实并不一定需要查看订单记录，我们应该使用 Repository 的另外方法来获取 Person 的订单记录。

对值对象的全局搜索通常是没有意义的。如果确实需要在数据库中搜索一个已知的值对象，那么值得考虑一下，搜索结果可能实际上是一个实体，尚未识别出它的标识。

### 6.2 定义

在所有持久化对象中，有一小部分必须通过基于对象属性的搜索来全局访问。当很难通过遍历的方式来访问某些聚合根的时候，就需要这种访问方式，它们通常是实体，有时可能是具有复杂内部结构的值对象。而其他对象则不适合使用这种访问方式，因为这会混淆它们之间的重要区别。随意的数据库查询会破坏领域对象的封装和聚合。技术基础设施的数据访问机制的暴露会增加客户的复杂度，并妨碍模型驱动的设计。

### 6.3 如何使用资源库

我们应该将资源库看作一个对象的集合。客户使用查询方法向资源库请求对象，这些查询方法根据客户所指定的条件来挑选对象。资源库检索被请求的对象，并封装数据库查询和元数据映射机制。他们可以返回汇总的信息，如多少个实例满足条件。甚至返回汇总计算，如所有匹配对象的某个数值属性的总和。

这样一来客户就只需与一个简单的、易于理解的接口进行对话，并根据模型向这个接口提出它的请求。

为每种需要全局访问的对象类型创建一个资源库，这个资源库相当于该类型的所有对象在内存的一个集合的「替身」。通过一个众所周知的全局接口来提供访问。提供添加和删除对象的方法，用这些方法来封装在数据存储中实际插入和删除数据的操作。根据提供具体条件来挑选对象的方法，并返回属性值满足条件的对象或者对象集合，从而将实际的存储和查询技术封装起来。只为那些确实需要直接访问的聚合根提供资源库，让客户始终聚焦于模型，而将所有对象的存储和访问操作交给资源库来完成。

让用户无感知的，以为就在内存中使用一个集合一样。

### 6.4 资源库的方法设计

方法参数：1）唯一标识。2）复杂的参数组合。3）值域（日期范围）。

返回值：1）对象。2）对象集合。3）某些类型的汇总。

### 6.5 资源库的实现

1）对类型进行抽象，比如有奔驰车宝马车，不应有两种资源库，而应该是只有一个抽象车类的资源库。2）充分利用与客户进行解耦。3）将事务的控制权交给客户。

### 6.6 资源库的优点

1）为客户提供了一个简单的模型，可用来获取持久化对象并管理他们的生命周期。2）他们将应用程序和领域设计与持久化技术进行解耦。3）它们体现了有关对象访问的设计决策。4）很容易测试，将利用集合直接替换资源库进行测试。

### 6.7 资源库中如何管理事务

对事务的管理绝对不应该放在领域模型和领域层中。通常来说，与领域模型相关的操作都非常的细粒度，以致于无法用于管理事务。另外，领域模型也不应该意识到事务的存在。通常我们将事务放在应用层，然后为每个主要的用例创建一个门面，一个用例对应一个门面业务方法，如果所有操作安全完成的话，门面中的业务方法提交事务，否则失败回滚。

## 0201. 领域驱动设计 DDD 之限界上下文

发表于 2019-11-28   |   0 条评论   |   热度 279°C

战术设计是从微观视角对单个微服务的编码设计，而战略设计是从宏观视角对多个微服务的交互设计。从人体学来说，一个器官的内部构造属于战术设计，多个器官之间的协作属于战略设计。好比心肺器官之间的协作配合。

### 1.1 为什么需要战略设计？

假设我们在设计订单模型时，下单操作涉及到会员等相关规则，比如增加积分等操作。（此时我们还未将订单子域和会员子域进行剥离）。其实一个用户的下单操作不需要与会员的积分产生强烈耦合。一旦会员的积分制度发生变动，又得需要在订单子域中进行修改，而订单子域又是我们的核心域，频繁的对核心域进行更改的风险较大。那如果将会员体系从订单核心域剥离出去呢？我们便使得两个子域的职能更为清晰并且解耦，这也体现了单一职责的设计原则。

假设一个开发小组既负责订单逻辑又要负责会员积分逻辑，则使得这个开发小组本身的职责变得复杂。如果使将订单和会员拆分开来，通过上下文之间的交互（即微服务之间的交互）使得订单开发小组成员、会员开发小组各自关心自己的领域（即各自只关心各自的业务逻辑）。

好比流水线上的工人，有利于分工，大家专注于自己负责的工序。

战略设计的元素主要有子域、限界上下文、上下文映射图。

### 1.2 领域、子域、限界上下文

从广义上讲，领域即是一个组织所做的事情以及其中所包含的一切。比如我们是一家网上生鲜超市，我们这个公司的业务范围就是线上的生鲜营销。而它即是我们正面对的领域。那如果在这个领域中创建一个统一大而全的模型，项目将会逐渐陷入混乱，更好的处理方式是在这一整个领域中再细分出子域。好比我们生鲜超市公司里面分了很多部门例如财务部，采购部，营销部，库存部等部门，大家各司其职，分工明确。如果公司不分门别类划分部门，只有一个部门的话，每个人都得会各个部门的一些工作。人员工作就变得杂乱无章且复杂，而公司管理也逐渐失控。DDD 的思想是提出限界上下文的概念，类比于不同的部门，采购部有采购部的模型，营销部有营销部的模型，模型只在限界上下文中变动，不影响其他限界上下文，将变动的影响范围控制在单个限界上下文中。使得风险在可控范围。限界上下文我们可以通俗的理解为微服务中的单个微服务，比如订单微服务，商品微服务等等。

试图去创建一个全功能的领域模型是非常困难的，并且最终很可能是失败的。我们可以试图去通过战略设计，按实际功能将这些交织的模型划分成逻辑上相互分离的子域，从而在一定程度上减少系统的复杂性。

限界上下文不一定是我们自己开发的，比如可能某些公司会使用外部的云库存服务，那么这个库存限界上下文就属于外部。

### 1.3 子域与限界上下文的关系

子域是否与限界上下文一一对应？不一定，比如我们的营销系统引入了会员优惠制度，但一开始我们的优惠规则非常简单，此时可以将会员优惠作为限界上下文中的一个模块。等到这个会员模块的规则逻辑开始愈加复杂之后，我们再将其进行剥离使其成为一个单独的限界上下文。

一般来说，一个子域对应一个限界上下文。为什么需要这么多子域呢？因为一个概念在不同子域的关注点并不一致。比如顾客的概念，在商品子域中，顾客的浏览记录，购买记录，偏好作为在商品子域的重要关注点。而在订单子域中，顾客的会员等级，余额，优惠券并是该子域的重要关注点。将模型放置在一个特定子域当中，才能使得该模型更为清晰。

不同限界上下文如何进行互通有无？此时就需要上下文映射图。

### 1.4 领域的种类划分

领域中的子域可分为核心域、支撑子域、通用子域。1）核心域：公司主要的业务领域，比如生鲜的商品子域以及订单子域。2）支撑子域：公司的库存帮助公司完成销售。他们就属于支撑子域。3）通用子域：会员子域，在许多的网上购物平台上都会使用到的会员体系。它属于通用子域。

核心域并非是绝对的。比如在外卖软件中，商店的位置服务是属于支撑子域，外卖软件中的外卖订单域便是核心域。但商店的位置服务是调用外部的地图服务商的 API，这种位置服务在该地图服务商的业务领域中则是核心域。

而不同的限界上下文为了解决某个问题而进行协作，如何协作呢？在上下文映射图中我们会继续谈到如何通过集成限界上下文的方式来完成不同通用语言间的映射。

### 1.5 为什么需要限界上下文

限界上下文是一个显式的边界，领域存在于这个边界之内。领域模型把通用语言表达成软件模型。创建边界的原因在于，每一个模型概念，包括它的属性和操作，在边界之内都具有特殊的含义。

举个例子，比如用户模型在权限上下文中代表了某个用户的权限，而在会员上下文中代表了某个用户的会员数据。那如果我们在整个领域中用一个用户模型既代表权限模型又代表会员模型的话，便会混淆开发人员的关注点，大而全的模型是对单一职责设计的破坏，使得后期维护更加困难。所以将模型拆分到不同的限界上下文，使得模型与我们的通用语言更加贴切符合。

在我们中文当中也有类似的情况，我举个例子。包袱这个词大家肯定都听过。但是它是一个多义词。在不同的语境下有不同的意思。例如：「请大家放心，不要有思想上的包袱。」这句话中包袱指的是负担。而「相声中的包袱」则指的是笑料。不同的语境相当于不同的限界上下文，限界上下文起到对模型的解释更加清晰的作用。

单个限界上下文的内容包含我们之前讲到的关于战术设计的建模工具。有时，我们可以使用模块来避免创建一些微小的限界上下文。通过分析分散在不同限界上下文的服务，你可能会发现，模块可以将多个限界上下文减少到一个。模块也可以用来拆分开发者的任务职责。因此我们可以使用更加战术化的手段来避免过多的限界上下文。

## 0202. 领域驱动设计 DDD 之上下文映射图

发表于 2019-11-29   |   0 条评论   |   热度 329°C

上下文映射图的英文是 Context Map 其实这个翻译挺难理解的，上下文映射图其实就是不同上下文是如何进行交流的关系。由于上下文映射图内容比较少。以下内容摘自《领域驱动设计精粹》。

三种集成方式：1）RPC 方式；2）消息队列或者发布 - 订阅机制；3）RESTful 方式。

上下文映射的种类。

1、合作关系：合作关系存在于两个团队之间。每个团队各自负责一个限界上下文。两个团队通过互相依赖的一整套目标联合起来形成合作关系。一损俱损，一荣俱荣。由于相互之间的联系非常紧密，他们经常会对同步日程安排和相互关联的工作。他们还必须使用持续集成对保持集成工作协调一致。

2、共享内核：两个或者多个团队之间共享着一个小规模但却通用的模型。团队必须就要共享的模型元素达成一致。有可能他们当中只有一个团队会维护，构建及测试共享模型的代码。

3、客户 - 供应商：两个限界上下文中，一方是供应商处于上游，一方是客户方处于下游。支配这种关系的是供应商，因为它必须提供客户需要的东西。客户需要与供应商共同制订规划来满足各种预期，但最终却还是由供应商来决定客户获得的是什么以及何时获得。

4、跟随者：上游团队没有任何动机去满足下游团队的具体需求。由于各种原因，下游团队也无法投入资源去翻译上游模型的通用语言来适应自己的特定需求，因此只能顺应上游的模型。例如当一个团队需要与一个非常庞大复杂的模型集成，而且这个模型已经非常成熟时，团队往往会成为它的跟随者。

5、防腐层：这是最具防御性的上下文映射关系，下游团队在其通用语言（模型）和位于它上游的通用语言（模型）之间创建了一个翻译层。防腐层隔离了下游模型与上游模型，并完成了两者之间的翻译。所以，这也是一种集成方式。

6、开放主机服务：开放主机服务会定义一套协议或者接口，让限界上下文可以被当做一组服务访问。该协议是开放的，所有需要与限界上下文进行集成的客户端都可以相对轻松地使用它。通过应用程序编程接口提供的服务都有详细的文档，用起来也很舒服。

个人认为比较好的方式是共享内核、防腐层、开放主机等形式的上下文映射。
